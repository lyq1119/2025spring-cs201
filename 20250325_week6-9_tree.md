# Week6~9 ğŸŒ²ç®—

Updated 1348 GMT+8 Apr 15, 2025

2025 spring, Complied by Hongfei Yan



> è¯´æ˜ï¼š
>
> 20250401 Week7è¯´æ˜ï¼šè¯¾ä»¶ä¸­ç¼–ç¨‹é¢˜ç›®ï¼Œâ€œç¤ºä¾‹ã€‚ã€‚ã€‚â€æ˜¯å­¦ä¹ äº†æ¦‚å¿µï¼Œé¡ºä¾¿çœ‹æ‡‚ç¤ºä¾‹ç¨‹åºã€‚â€œç»ƒä¹ ã€‚ã€‚ã€‚â€æ˜¯å¸Œæœ›å…ˆä¸çœ‹ç­”æ¡ˆï¼Œè‡ªå·±å°è¯•å…ˆå®Œæˆã€‚
>
> 20250326 Week6è¯´æ˜ï¼šä¸æ ‘ç›¸å…³çš„é¢˜ç›®ï¼Œè¿˜æŒºéš¾çš„ï¼Œå› ä¸ºé€šå¸¸æ¶‰åŠåˆ°æŠŠè¾“å…¥å­—ç¬¦ä¸²parse/buildæˆä¸€æ£µæ ‘ï¼Œè¿™ä¸ªè¿‡ç¨‹æ¯”è¾ƒéº»çƒ¦ï¼Œé€šå¸¸ç”¨åˆ°stack+dfsã€‚ç„¶åå†æŒ‰ç…§é¢˜é¢è¦æ±‚è¾“å‡ºã€‚
>
> 1ï¼‰è®¡åˆ’ä¸€è®²åŒ…æ‹¬æ ‘çš„ç›¸å…³æ¦‚å¿µã€è¡¨ç¤ºæ–¹æ³•ï¼›äºŒè®²æ ‘çš„æ„å»º/è§£æã€éå†ã€å“ˆå¤«æ›¼ç®—æ³•ï¼›ä¸‰è®²å †å®ç°ã€AVLå®ç°ã€å¹¶æŸ¥é›†ã€‚
>
> 2ï¼‰mdæ–‡ä»¶æœ‰ç›®å½•ï¼Œå†…å®¹æ¨è¿›æ€è·¯æ˜¯åŸç†å­¦ä¹ +ç¼–ç¨‹é¢˜ç›®å®é™…ã€‚



# å‰è¨€ï¼šæ ‘å½¢ç»“æ„å­¦ä¹ æ–¹æ³•

åœ¨è®¡ç®—æœºç§‘å­¦é¢†åŸŸå†…ï¼Œæ ‘å½¢ç»“æ„æ˜¯æœ€ä¸ºå…³é”®åŒæ—¶ä¹Ÿæ˜¯æŒæ¡éš¾åº¦è¾ƒé«˜çš„æ¦‚å¿µä¹‹ä¸€ã€‚ä¸åŒäºè®¡ç®—æœºæ¦‚è®ºï¼Œæ•°æ®ç»“æ„ä¸ç®—æ³•çš„å­¦ä¹ ä¸ä»…éœ€è¦å€ŸåŠ©é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æŠ½è±¡å’Œå¤ç”¨ç†å¿µï¼Œè¿˜è¦é€šè¿‡<mark>ä½¿ç”¨é“¾è¡¨æ¥è¡¨è¾¾æ ‘ç»“æ„ï¼Œå¹¶é‡‡ç”¨é€’å½’çš„æ–¹æ³•è¿›è¡Œæ ‘çš„éå†</mark>ã€‚åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œç»å…¸ç®—æ³•å’Œç¼–ç¨‹æŠ€å·§çš„åº”ç”¨è‡³å…³é‡è¦ï¼Œè€Œå¯¹äºæ—¶é—´å¤æ‚åº¦çš„ä¼˜åŒ–æŠ€å·§ä¹Ÿæ˜¯å¿…ä¸å¯å°‘çš„ã€‚

å³ä¾¿æ˜¯å‚åŠ è¿‡è®¡ç®—æœºæ¦‚è®ºæé«˜ç­çš„å­¦ç”Ÿï¼Œä¹Ÿå¯èƒ½ä¼šå‘ç°æ ‘ç»“æ„çš„å­¦ä¹ é¢‡å…·æŒ‘æˆ˜ã€‚ä¸€äº›å­¦ç”Ÿå¯èƒ½ä¼šé€šè¿‡ç±»æ¯”å’Œç»¼åˆçš„æ–¹å¼æ¥ä¿ƒè¿›ç†è§£ï¼Œæ¯”å¦‚é€šè¿‡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰æ¥æ·±å…¥ç†è§£æ ‘çš„å‰åºéå†å’Œååºéå†ï¼›æœ‰çš„å­¦ç”Ÿå¯èƒ½ä¼šé€šè¿‡åŸè¯µè¯—æ­Œæ¥æ¿€åŠ±è‡ªå·±ï¼›è¿˜æœ‰çš„å­¦ç”Ÿåˆ™æŠ•å…¥å¤§é‡æ—¶é—´å¤ç°ç»å…¸ç®—æ³•ï¼Œæˆ–åœ¨é›†æˆå¼€å‘ç¯å¢ƒï¼ˆIDEï¼‰ä¸­æ¢ç´¢å¦‚ä½•è°ƒè¯•é€’å½’ç¨‹åºã€‚

æ•™æä¸­ä¸å…å­˜åœ¨ä¸€äº›å†…å®¹é—æ¼æˆ–é€»è¾‘ä¸è¿è´¯çš„éƒ¨åˆ†ï¼Œå› æ­¤æˆ‘ä»¬åˆ¶ä½œçš„è¯¾ä»¶ä¹Ÿåœ¨æŒç»­æ›´æ–°ä»¥è¡¥å……å’Œå®Œå–„è¿™äº›å†…å®¹ã€‚
é¢„è®¡éœ€è¦è‡³å°‘ä¸‰å‘¨æŒæ¡æ ‘ç»“æ„çš„ç›¸å…³çŸ¥è¯†ã€‚

> ã€ŠPythonæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹ è¿™æœ¬ä¹¦ï¼Œæ ‘è¿™ä¸€ç« æ²¡æœ‰è®²generic treeï¼Œç›´æ¥å°±åˆ°binary treeäº†ã€‚ä¹‹å‰æ„Ÿè§‰å®ƒçš„ ç®—æ³•åˆ†æ é‚£ç« ä¸å¥½ï¼Œç°åœ¨æ„Ÿè§‰æ ‘è¿™ç« ä¹Ÿå·®å¼ºäººæ„ï¼Œå†™çš„æ¯”è¾ƒéšæ„ã€‚æ ‘æœ‰ä¸ªé‡è¦çš„åº”ç”¨ï¼Œæ–‡æœ¬å‹ç¼©â€”â€”å“ˆå¤«æ›¼ç¼–ç ã€‚åœ¨è¯¥ä¹¦ä¸­ï¼Œæœä¸åˆ°â€œå“ˆå¤«æ›¼â€ï¼Œä¹Ÿæœä¸åˆ°"Huffman"ã€‚
>



**Q: æœ‰æ²¡æœ‰ç›´æ¥çš„ç†è§£**ï¼Œå°±æ˜¯æ¯”å¦‚ç»™æˆ‘ä¸€æ£µæ ‘ï¼Œæˆ‘å¯ä»¥ç›´æ¥ç”¨éå†æ–¹æ³•ç»™å‡ºä¸­åºå’Œååº?

> å‰åºéå†å°±æ˜¯dfsåºåˆ—ï¼Œååºçš„ååºæ˜¯ä¸æ˜¯å°±æ˜¯åŸæ ‘ä¼˜å…ˆèµ°å³è¾¹çš„dfsã€‚
>
> ä½ çš„é—®é¢˜æ¶‰åŠåˆ°æ ‘çš„éå†æ–¹æ³•ä»¥åŠå®ƒä»¬ä¹‹é—´çš„å…³ç³»ã€‚æˆ‘ä»¬æ¥é€ä¸€åˆ†æï¼š
>



> **1. æ ‘çš„éå†æ–¹æ³•**
>
> å¯¹äºä¸€æ£µæ ‘ï¼ˆå°¤å…¶æ˜¯äºŒå‰æ ‘ï¼‰ï¼Œå¸¸è§çš„éå†æ–¹æ³•æœ‰ä¸‰ç§ï¼š
>
> - **å‰åºéå†**ï¼ˆPreorderï¼‰ï¼šæ ¹ -> å·¦å­æ ‘ -> å³å­æ ‘
>- **ä¸­åºéå†**ï¼ˆInorderï¼‰ï¼šå·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘
> - **ååºéå†**ï¼ˆPostorderï¼‰ï¼šå·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹
>
> è¿™äº›éå†æ–¹æ³•å¯ä»¥é€šè¿‡é€’å½’æˆ–è¿­ä»£å®ç°ï¼Œæœ¬è´¨ä¸Šæ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰çš„ä¸åŒå˜ä½“ã€‚
>
> ---
>
>**2. å‰åºéå†å’ŒDFSçš„å…³ç³»**
>>
>ä½ æåˆ°â€œå‰åºéå†å°±æ˜¯DFSåºåˆ—â€ï¼Œè¿™æ˜¯æ­£ç¡®çš„ï¼  
> - **å‰åºéå†**çš„é¡ºåºæ­£æ˜¯æ ‡å‡†çš„æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰è®¿é—®èŠ‚ç‚¹çš„é¡ºåºã€‚
> - åœ¨DFSè¿‡ç¨‹ä¸­ï¼Œç¬¬ä¸€æ¬¡è®¿é—®æŸä¸ªèŠ‚ç‚¹æ—¶å°±è®°å½•å®ƒï¼Œè¿™å°±æ˜¯å‰åºéå†çš„ç»“æœã€‚
> 
>ä¾‹å¦‚ï¼Œç»™å®šä»¥ä¸‹äºŒå‰æ ‘ï¼š
> ```
>     A
>    / \
>   B   C
>  / \
>D   E
> ```
> å‰åºéå†ç»“æœæ˜¯ï¼š`A -> B -> D -> E -> C`
> 
>è¿™æ­£æ˜¯DFSä»æ ¹èŠ‚ç‚¹å¼€å§‹è®¿é—®çš„é¡ºåºã€‚
> 
> ---
> 
> **3. ååºéå†çš„ååºä¸DFSçš„å…³ç³»**
> 
> ä½ æåˆ°â€œååºçš„ååºæ˜¯ä¸æ˜¯å°±æ˜¯åŸæ ‘ä¼˜å…ˆèµ°å³è¾¹çš„DFSâ€ï¼Œè¿™ä¸ªè¯´æ³•åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯å¯¹çš„ï¼Œä½†éœ€è¦å…·ä½“åˆ†æã€‚
> 
> **ååºéå†çš„ç‰¹ç‚¹**
> 
>ååºéå†çš„é¡ºåºæ˜¯ï¼šå…ˆè®¿é—®å·¦å­æ ‘ï¼Œå†è®¿é—®å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚  
> ä»¥ä¸Šé¢çš„æ ‘ä¸ºä¾‹ï¼Œååºéå†ç»“æœæ˜¯ï¼š`D -> E -> B -> C -> A`
>
> **ååºéå†çš„ååº**
>
> å°†ååºéå†ç»“æœåè½¬ï¼Œå¾—åˆ°ï¼š`A -> C -> B -> E -> D`
>
> **ä¼˜å…ˆèµ°å³è¾¹çš„DFS**
>
> å¦‚æœæˆ‘ä»¬åœ¨DFSè¿‡ç¨‹ä¸­ä¼˜å…ˆè®¿é—®å³å­æ ‘ï¼ˆå³å…ˆè®¿é—®å³å­æ ‘å†è®¿é—®å·¦å­æ ‘ï¼‰ï¼Œé‚£ä¹ˆå¾—åˆ°çš„è®¿é—®é¡ºåºæ˜¯ï¼š`A -> C -> B -> E -> D`
>
> å¯ä»¥çœ‹åˆ°ï¼Œååºéå†çš„ååºç¡®å®ç­‰äºä¼˜å…ˆèµ°å³è¾¹çš„DFSçš„é¡ºåºã€‚
> 
>---
> 
>**4. ä¸­åºéå†**
> 
>ä¸­åºéå†çš„é¡ºåºæ˜¯ï¼šå·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘ã€‚  
> ä»¥ä¸Šé¢çš„æ ‘ä¸ºä¾‹ï¼Œä¸­åºéå†ç»“æœæ˜¯ï¼š`D -> B -> E -> A -> C`
>
> ä¸­åºéå†æ²¡æœ‰ç›´æ¥ç­‰ä»·äºæŸç§DFSé¡ºåºï¼Œå› ä¸ºå®ƒçš„é¡ºåºä¾èµ–äºå·¦å­æ ‘ã€æ ¹ã€å³å­æ ‘çš„ç‰¹å®šæ’åˆ—ã€‚
>
> ---
>
> **æ€»ç»“**
>
> - **å‰åºéå†** = æ ‡å‡†DFSè®¿é—®é¡ºåºã€‚
>- **ååºéå†çš„ååº** = ä¼˜å…ˆèµ°å³è¾¹çš„DFSè®¿é—®é¡ºåºã€‚
> - **ä¸­åºéå†** = å·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘ï¼Œæ²¡æœ‰ç›´æ¥ç­‰ä»·äºæŸç§DFSé¡ºåºã€‚
> 



> ã€å¾€å¹´åŒå­¦ä½œä¸šæ€»ç»“ã€‘ï¼š
>
> æ ‘çŠ¶æ•°ç»„æƒ¨é­å†…å­˜è¶…å‡ºï¼Œç°å­¦åˆ†æ²»ä¾æ—§é¥é¥é¢†å…ˆã€‚
>åˆæ³•å‡ºæ ˆåºåˆ—ç®€å•æ¨¡æ‹Ÿï¼Œæ ‘èŠ‚æ— æ ‘æ±‚äºŒå‰æ ‘æ·±åº¦ã€‚
> åŒç«¯é˜Ÿåˆ—è¿˜æ˜¯å®å®å·´å£«ï¼Œæ³¢å…°è¡¨è¾¾å¼ä»æ¸¸åˆƒæœ‰ä½™ã€‚
>ä¸­åºè½¬ååºå†™äº†ä¸¤å°æ—¶ï¼Œæ°´å¹³ä¸å¤Ÿè¿˜å¾—å¤šå®¶ç»ƒä¹ ï¼
> 
>
> 
>æœ¬å‘¨ç®—æ˜¯çœŸæ­£è¿›å…¥äº†æ•°ç®—çš„é‡ç‚¹ç« èŠ‚ï¼Œéš¾åº¦è‚‰çœ¼å¯è§åœ°å¢é•¿ã€‚ç™¾å­—ä»¤ä¸€é¦–ï¼ŒèŠè¡¨æ„Ÿå—ã€‚
> æ ‘
>ä¸ç†Ÿ
>çœŸå¯æ¶
>>æ— èƒ½ç‹‚æ€’
>æ‰¾å¤§ä½¬æ±‚åŠ©
> WAç™¾èˆ¬è‹¦æ¥š
> å¿ƒèŒ«ç„¶æ‹”å‰‘å››é¡¾
> æ ˆä¸é˜Ÿåˆ—å‰åå¼¹å‡º
>å¥½åœ¨å­¦ä¸œè¥¿å¯ä»¥é¡¿æ‚Ÿ
> å„ç§åºè¡¨è¾¾å¼éœ€è¦å…³æ³¨
>é€æ¸è§£å†³äº†æœ¬å‘¨é¢˜ç›®
> å°¤å…¶å†™æ ˆæœ‰å¦‚ç¥åŠ©
>ä½†æ²¡åˆ°ç²¾é€šç¨‹åº¦
> é€’å½’å¾ªç¯æ¬¡æ•°
>ACè¶£å‘³è¶³
> ä¹ä¸æ€èœ€
> åˆšä¸Šè·¯
> åˆ»è‹¦
>èµ´ 





# ä¸€ã€ğŸŒ²çš„æ¦‚å¿µå’Œè¡¨ç¤ºæ–¹æ³•

## 0 Recap 

### 0.1 é€’å½’ & BFS

é‰´äºå„ç­åœ¨ã€Šè®¡ç®—æ¦‚è®ºBã€‹è¯¾ç¨‹ä¸­çš„è¿›åº¦ä¸ä¸€ï¼Œå„ä½è€å¸ˆå¯¹äºã€Šè®¡ç®—æ¦‚è®ºã€‹å’Œã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•ã€‹å†…å®¹çš„è¦†ç›–å’Œç†è§£ä¹Ÿå­˜åœ¨å·®å¼‚ï¼Œæˆ‘ä»¬å»ºè®®å¤ä¹ é€’å½’å’ŒBFSçš„ç›¸å…³å†…å®¹ã€‚

1ï¼‰<mark>**é€’å½’**æ˜¯æ•°ç®—ä¸­ä¸å¯æˆ–ç¼ºçš„æ ¸å¿ƒæŠ€èƒ½</mark>ï¼Œå¼ºçƒˆæ¨èä¼˜å…ˆæŒæ¡ã€‚å¯ä»¥å‚è€ƒ https://github.com/GMyhf/2024fall-cs101/blob/main/20241029_recursion.md

2ï¼‰<mark>**é˜Ÿåˆ—**åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ä¸­æœ‰ç€å¹¿æ³›çš„åº”ç”¨</mark>ã€‚è€ƒè™‘åˆ°å…¶ä»–ç­çº§å¯èƒ½å°šæœªè®²æˆæœç´¢ç®—æ³•ï¼Œæˆ‘ä»¬æä¾›å­¦ä¹ èµ„æºï¼Œhttps://github.com/GMyhf/2024fall-cs101/blob/main/20241119_searching.md



### 0.2ç”¨OOPå†™ç¨‹åº

æ¥ä¸‹æ¥å¼€å§‹å­¦ä¹ æ ‘ï¼Œæœ‰æ—¶ç¨‹åºä¼šç»™å‡ºç±»çš„å®ç°ä»£ç ã€‚å¤ä¹ ä¸€ä¸ªç±»å†™æ³•çš„å°ç¨‹åºï¼Œå¯ä»¥debugæ¨¡å¼è¿è¡Œï¼Œæˆ–è€… https://pythontutor.com å¯è§†åŒ–è¿è¡Œï¼Œè¾…åŠ©ç†è§£ã€‚ç±»å®ç°ç¨‹åºï¼Œè¡¥å……ç¼ºå¤±è¡Œä»£ç ã€‚æ˜¯ç¬”è¯•ä¸­å¿…è€ƒçš„é¢˜ç›®ã€‚

OOP çš„å†™æ³•å±äºè¯­æ³•èŒƒç•´ï¼Œå¯å‚çœ‹ https://www.runoob.com/python3/python3-class.html

æ•°ç®—çš„ç²¾åæ˜¯å¤åˆ¶ï¼ˆç±»çš„ç²¾åæ˜¯å¤åˆ¶ï¼‰ï¼Œä¸éœ€è¦æ·±æ‹·è´ï¼Œ<mark>åªè¦åˆ›å»ºå¤šä¸ªå¯¹è±¡ï¼Œå°±æœ‰å„è‡ªçš„å†…å­˜ç©ºé—´</mark>ã€‚ä¾‹å¦‚ä¸‹é¢å¹¶æŸ¥é›†çš„ä¾‹å­ï¼Œåˆ›å»ºäº†A, Bä¸¤ä¸ªå¯¹è±¡ï¼ŒAçš„ä¿®æ”¹ä¸å½±å“Bçš„ã€‚å¹¶æŸ¥é›†çš„å†…å®¹åœ¨ ä¸‰.7éƒ¨åˆ†ã€‚

```python
class DisjSet:
    def __init__(self, n):
        # Constructor to create and
        # initialize sets of n items
        self.rank = [1] * n
        self.parent = [i for i in range(n)]

    def find(self, x):
        # Find the root of the set in which element x belongs
        if self.parent[x] != x:
            # Path compression: Make the parent of x the root of its set
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        # Perform union of two sets
        x_root = self.find(x)
        y_root = self.find(y)

        if x_root == y_root:
            return

        # Attach smaller rank tree under root of higher rank tree
        if self.rank[x_root] < self.rank[y_root]:
            self.parent[x_root] = y_root
        elif self.rank[x_root] > self.rank[y_root]:
            self.parent[y_root] = x_root
        else:
            self.parent[y_root] = x_root
            self.rank[x_root] += 1


if __name__ == '__main__':
    A = DisjSet(5)
    B = DisjSet(5)

    A.union(0, 1)
    A.union(2, 3)

    print(A.rank)  # Output: [2, 1, 2, 1, 1]
    print(A.parent)  # Output: [0, 0, 2, 2, 4]
    print(B.rank)  # Output: [1, 1, 1, 1, 1]
    print(B.parent)  # Output: [0, 1, 2, 3, 4]

```



## 1 æœ¯è¯­Notations

**Q. è¯·è®²è§£æ•°æ®ç»“æ„ä¸­çš„æ ‘**

> **æ•°æ®ç»“æ„ä¸­çš„æ ‘**
>
> **æ ‘ï¼ˆTreeï¼‰** æ˜¯ä¸€ç§é‡è¦çš„éçº¿æ€§æ•°æ®ç»“æ„ï¼Œå®ƒç”±**èŠ‚ç‚¹ï¼ˆNodeï¼‰** ç»„æˆï¼ŒèŠ‚ç‚¹ä¹‹é—´å…·æœ‰**å±‚çº§å…³ç³»**ã€‚æ ‘ç»“æ„å¹¿æ³›åº”ç”¨äºè®¡ç®—æœºç§‘å­¦é¢†åŸŸï¼Œå¦‚æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“ç´¢å¼•ã€æœç´¢ç®—æ³•ç­‰ã€‚
>
> ---
>
> **1. æ ‘çš„åŸºæœ¬æ¦‚å¿µ**
>
> **(1) èŠ‚ç‚¹çš„ç»„æˆ**
>
> æ¯ä¸ªèŠ‚ç‚¹é€šå¸¸åŒ…å«ï¼š
> - **å€¼ï¼ˆValueï¼‰**ï¼šå­˜å‚¨çš„æ•°æ®ã€‚
> - **å­èŠ‚ç‚¹ï¼ˆChildrenï¼‰**ï¼šæŒ‡å‘å…¶ä»–èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
> - **çˆ¶èŠ‚ç‚¹ï¼ˆParentï¼‰**ï¼šæŒ‡å‘å…¶ä¸Šçº§èŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆæ ¹èŠ‚ç‚¹é™¤å¤–ï¼‰ã€‚
> - **åº¦ï¼ˆDegreeï¼‰**ï¼šèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ã€‚
> - **æ·±åº¦ï¼ˆDepthï¼‰**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ã€‚
> - **é«˜åº¦ï¼ˆHeightï¼‰**ï¼šä»å½“å‰èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„é•¿åº¦ã€‚
>
> **(2) æ ‘çš„æœ¯è¯­**
>
> - **æ ¹èŠ‚ç‚¹ï¼ˆRootï¼‰**ï¼šæ ‘çš„èµ·å§‹èŠ‚ç‚¹ï¼Œæ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚
> - **å¶å­èŠ‚ç‚¹ï¼ˆLeafï¼‰**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
> - **å­æ ‘ï¼ˆSubtreeï¼‰**ï¼šä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„éƒ¨åˆ†æ ‘ã€‚
> - **å±‚çº§ï¼ˆLevelï¼‰**ï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œæ ¹ä¸ºç¬¬ 0 å±‚ï¼Œæ ¹çš„å­èŠ‚ç‚¹ä¸ºç¬¬ 1 å±‚ï¼Œä»¥æ­¤ç±»æ¨ã€‚
> - **èŠ‚ç‚¹é—´å…³ç³»**ï¼šçˆ¶èŠ‚ç‚¹ã€å­èŠ‚ç‚¹ã€å…„å¼ŸèŠ‚ç‚¹ã€ç¥–å…ˆèŠ‚ç‚¹ã€åä»£èŠ‚ç‚¹ç­‰ã€‚
>
> ---
>
> **2. æ ‘çš„åˆ†ç±»**
>
> **(1) æ™®é€šæ ‘**
>
> æ™®é€šæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰ä»»æ„å¤šä¸ªå­èŠ‚ç‚¹ã€‚
>
> **(2) äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰**
>
> äºŒå‰æ ‘æ˜¯æ ‘çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰**ä¸¤ä¸ªå­èŠ‚ç‚¹**ï¼š
> - **æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰**ï¼šæ‰€æœ‰éå¶å­èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚
> - **å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰**ï¼šåªæœ‰æœ€åä¸€å±‚å¯ä»¥ä¸æ»¡ï¼Œå¹¶ä¸”èŠ‚ç‚¹ä»å·¦åˆ°å³æ’åˆ—ã€‚
> - **å¹³è¡¡äºŒå‰æ ‘ï¼ˆBalanced Binary Treeï¼‰**ï¼šå·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡ 1ï¼Œå¦‚ AVL æ ‘ã€‚
> - **äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼ŒBSTï¼‰**ï¼šå¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å°äºè¯¥èŠ‚ç‚¹å€¼ï¼Œå³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å¤§äºè¯¥èŠ‚ç‚¹å€¼ã€‚
>
> **(3) ç‰¹æ®Šæ ‘**
>
> - **å¹³è¡¡æœç´¢æ ‘ï¼ˆBalanced Search Treeï¼‰**ï¼šå¦‚ AVL æ ‘ã€çº¢é»‘æ ‘ï¼ˆRed-Black Treeï¼‰ã€‚
> - **B æ ‘ï¼ˆB-Treeï¼‰** å’Œ **B+ æ ‘ï¼ˆB+ Treeï¼‰**ï¼šç”¨äºæ•°æ®åº“ç´¢å¼•ã€‚
> - **Trie æ ‘ï¼ˆå‰ç¼€æ ‘ï¼‰**ï¼šç”¨äºå­—ç¬¦ä¸²å­˜å‚¨å’Œæœç´¢ã€‚ä¾‹å¦‚ï¼š<mark>OJçš„æŒ‰ç…§æ ‡é¢˜æœç´¢åŠŸèƒ½</mark>
> - **å †ï¼ˆHeapï¼‰**ï¼šå¦‚æœ€å¤§å †ï¼ˆMax Heapï¼‰ã€æœ€å°å †ï¼ˆMin Heapï¼‰ï¼Œç”¨äºä¼˜å…ˆé˜Ÿåˆ—ã€‚
>
> ---
>
> **3. æ ‘çš„åŸºæœ¬æ“ä½œ**
>
> æ ‘çš„å¸¸è§æ“ä½œåŒ…æ‹¬ï¼š
> 1. **æ’å…¥ï¼ˆInsertionï¼‰**
> 2. **åˆ é™¤ï¼ˆDeletionï¼‰**
> 3. **æŸ¥æ‰¾ï¼ˆSearchï¼‰**
> 4. **éå†ï¼ˆTraversalï¼‰**ï¼š
>    - **æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰**ï¼š
>      - **å‰åºéå†ï¼ˆPreorderï¼‰**ï¼šæ ¹ â†’ å·¦ â†’ å³
>      - **ä¸­åºéå†ï¼ˆInorderï¼‰**ï¼šå·¦ â†’ æ ¹ â†’ å³ï¼ˆBST ä¸­åºéå†ç»“æœä¸ºæœ‰åºæ•°ç»„ï¼‰
>      - **ååºéå†ï¼ˆPostorderï¼‰**ï¼šå·¦ â†’ å³ â†’ æ ¹
>    - **å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰**ï¼ˆå±‚åºéå†ï¼‰ï¼šæŒ‰å±‚ä»å·¦åˆ°å³ä¾æ¬¡éå†ã€‚
>
> ---
>
> **4. æ ‘çš„åº”ç”¨**
>
> - **æ–‡ä»¶ç³»ç»Ÿ**ï¼ˆç›®å½•ç»“æ„ï¼‰
> - **æ•°æ®åº“ç´¢å¼•**ï¼ˆB æ ‘ã€B+ æ ‘ï¼‰
> - **ç¼–è¯‘å™¨**ï¼ˆè¯­æ³•æ ‘ã€æŠ½è±¡è¯­æ³•æ ‘ ASTï¼‰
> - **ç½‘ç»œè·¯ç”±**ï¼ˆTrie æ ‘ï¼‰
> - **äººå·¥æ™ºèƒ½**ï¼ˆæœç´¢æ ‘ã€å†³ç­–æ ‘ï¼‰
> - **æ•°æ®å‹ç¼©**ï¼ˆHuffman æ ‘ï¼‰
>
> ---
>
> **5. æ ‘çš„ Python å®ç°**
>
> **(1) äºŒå‰æ ‘çš„åŸºæœ¬å®ç°**
>
> ```python
> class TreeNode:
>     def __init__(self, value):
>         self.value = value
>         self.left = None
>         self.right = None
> 
> # åˆ›å»ºäºŒå‰æ ‘
> root = TreeNode(1)
> root.left = TreeNode(2)
> root.right = TreeNode(3)
> root.left.left = TreeNode(4)
> root.left.right = TreeNode(5)
> ```
>
> **(2) äºŒå‰æ ‘çš„éå†**
>
> ```python
> # å‰åºéå†
> def preorder_traversal(node):
>     if node:
>         print(node.value, end=" ")
>         preorder_traversal(node.left)
>         preorder_traversal(node.right)
> 
> # ä¸­åºéå†
> def inorder_traversal(node):
>     if node:
>         inorder_traversal(node.left)
>         print(node.value, end=" ")
>         inorder_traversal(node.right)
> 
> # ååºéå†
> def postorder_traversal(node):
>     if node:
>         postorder_traversal(node.left)
>         postorder_traversal(node.right)
>         print(node.value, end=" ")
> 
> print("å‰åºéå†:")
> preorder_traversal(root)
> print("\nä¸­åºéå†:")
> inorder_traversal(root)
> print("\nååºéå†:")
> postorder_traversal(root)
> ```
>
> ---
>
> **æ€»ç»“**
>
> - **æ ‘æ˜¯ä¸€ç§å±‚çº§ç»“æ„çš„æ•°æ®ç»“æ„ï¼Œé€‚ç”¨äºå¤šç§åº”ç”¨åœºæ™¯ã€‚**
> - **äºŒå‰æ ‘æ˜¯æœ€å¸¸è§çš„æ ‘ç±»å‹ï¼Œå…·æœ‰å¤šç§å˜ä½“ï¼ˆå¦‚ BSTã€AVL æ ‘ã€çº¢é»‘æ ‘ï¼‰ã€‚**
> - **æ ‘çš„éå†æ–¹å¼ä¸»è¦åŒ…æ‹¬ DFSï¼ˆå‰åºã€ä¸­åºã€ååºï¼‰å’Œ BFSï¼ˆå±‚åºéå†ï¼‰ã€‚**
> - **æ ‘åœ¨æ•°æ®åº“ã€ç¼–è¯‘å™¨ã€æœç´¢ç®—æ³•ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚**
>



æ ‘ç®—è¦†ç›–çš„å†…å®¹å’ŒçŸ¥è¯†ç‚¹æ€»ç»“å¦‚ä¸‹ï¼šæ ‘çš„çŸ¥è¯†å›¾è°±ã€‚

```mermaid
mindmap
  root(Generic Tree)
    Notations{{**NOTATIONS**}}
    	Node,Edge
    	Root,Subtree
    	Parent,Children,Sibling,Leaf
    	Path: Level,Height,Depth
      
    Representation{{**REPRESENTATION**}}
      Nested Parentheses
      Node-Based
      Indented Tree
      Adjacency List
      	Disjoint Set
      	Trie
      
    Binary Tree{{**Binary Tree**}}
      Applications
      	Parse Tree
      	Tree Traversals
      	Huffman
      Priority Queues with Binary Heaps
      Binary Search Tree
      AVL Tree
      Segment Tree,BIT
      *KD Tree
```

<center>æ ‘çš„çŸ¥è¯†å›¾è°±</center>



**ğŸŒ²çš„ç¤ºä¾‹**ï¼Œæ ‘é€‚åˆè¡¨ç¤ºå±‚çº§ç»“æ„ï¼Œä¾‹å¦‚ï¼šæˆ‘çš„githubä¸­<mark>æ•°ç®—é¢˜è§£</mark>çš„åˆ†å¸ƒ, https://github.com/GMyhf

```mermaid
graph TD
    A[(GMyhf)]; 
    B[(2020fall-cs101)]; C[(2024spring-cs201)]; D[(2024fall-cs101)]
    
    E(2020fall_cs101.openjudge.cn_problems.md); F(2020fall_Codeforces_problems.md);
    G(2024spring_dsa_problems.md);H(2024fall_LeetCode_problems.md);
    S(sunnywhy_problems.md);

    A --- B; A --- C; A --- D;
    B --- E; B --- F; C --- G; C --- S;D --- H;
    
```



åœ¨çœ‹äº†æ ‘çš„ä¾‹å­ä¹‹åï¼Œç°åœ¨æ¥æ­£å¼åœ°å®šä¹‰æ ‘åŠå…¶æ„æˆã€‚

**èŠ‚ç‚¹ Node**ï¼šèŠ‚ç‚¹æ˜¯æ ‘çš„åŸºç¡€éƒ¨åˆ†ã€‚
æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰åç§°ï¼Œæˆ–â€œé”®å€¼â€ã€‚èŠ‚ç‚¹è¿˜å¯ä»¥ä¿å­˜é¢å¤–æ•°æ®é¡¹ï¼Œæ•°æ®é¡¹æ ¹æ®ä¸åŒçš„åº”ç”¨è€Œå˜ã€‚

**è¾¹ Edge**ï¼šè¾¹æ˜¯ç»„æˆæ ‘çš„å¦ä¸€ä¸ªåŸºç¡€éƒ¨åˆ†ã€‚
æ¯æ¡è¾¹æ°å¥½è¿æ¥ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œè¡¨ç¤ºèŠ‚ç‚¹ä¹‹é—´å…·æœ‰å…³è”ï¼Œè¾¹å…·æœ‰å‡ºå…¥æ–¹å‘ï¼›
æ¯ä¸ªèŠ‚ç‚¹ï¼ˆé™¤æ ¹èŠ‚ç‚¹ï¼‰æ°æœ‰ä¸€æ¡æ¥è‡ªå¦ä¸€èŠ‚ç‚¹çš„å…¥è¾¹ï¼›
æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰é›¶æ¡/ä¸€æ¡/å¤šæ¡è¿åˆ°å…¶å®ƒèŠ‚ç‚¹çš„å‡ºè¾¹ã€‚<u>å¦‚æœåŠ é™åˆ¶ä¸èƒ½æœ‰ â€œå¤šæ¡è¾¹â€ï¼Œè¿™é‡Œæ ‘ç»“æ„å°±ç‰¹æ®ŠåŒ–ä¸ºçº¿æ€§è¡¨</u>

**æ ¹èŠ‚ Root**: æ ‘ä¸­å”¯ä¸€æ²¡æœ‰å…¥è¾¹çš„èŠ‚ç‚¹ã€‚

**è·¯å¾„ Path**ï¼šç”±è¾¹ä¾æ¬¡è¿æ¥åœ¨ä¸€èµ·çš„æœ‰åºèŠ‚ç‚¹åˆ—è¡¨ã€‚æ¯”å¦‚ï¼Œå“ºä¹³çº²â†’é£Ÿè‚‰ç›®â†’çŒ«ç§‘â†’çŒ«å±â†’å®¶çŒ«å°±æ˜¯ä¸€æ¡è·¯å¾„ã€‚

**å­èŠ‚ç‚¹ Children**ï¼šå…¥è¾¹å‡æ¥è‡ªäºåŒä¸€ä¸ªèŠ‚ç‚¹çš„è‹¥å¹²èŠ‚ç‚¹ï¼Œç§°ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚

**çˆ¶èŠ‚ç‚¹ Parent**ï¼šä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¶æ‰€æœ‰å‡ºè¾¹è¿æ¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

**å…„å¼ŸèŠ‚ç‚¹ Sibling**ï¼šå…·æœ‰åŒä¸€çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ä¹‹é—´ä¸ºå…„å¼ŸèŠ‚ç‚¹ã€‚

**å­æ ‘ Subtree**ï¼šä¸€ä¸ªèŠ‚ç‚¹å’Œå…¶æ‰€æœ‰å­å­™èŠ‚ç‚¹ï¼Œä»¥åŠç›¸å…³è¾¹çš„é›†åˆã€‚

**å¶èŠ‚ç‚¹ Leaf Node**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ç§°ä¸ºå¶èŠ‚ç‚¹ã€‚

**å±‚çº§ Level**ï¼š
ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ°è¾¾ä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„ï¼Œ<mark>æ‰€åŒ…å«çš„è¾¹çš„æ•°é‡</mark>ï¼Œç§°ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å±‚çº§ã€‚
ä¸‹å›¾ä¸­ D çš„å±‚çº§ä¸º 2ï¼Œæ ¹èŠ‚ç‚¹çš„å±‚çº§ä¸º 0ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240204125813782.png" alt="image-20240204125813782" style="zoom:50%;" />

<center>å›¾ æ ‘çš„å±‚çº§æ˜¾ç¤º</center> 



**é«˜åº¦ Height**ï¼šæ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§å±‚çº§ç§°ä¸ºæ ‘çš„é«˜åº¦ï¼Œå¦‚å›¾1æ‰€ç¤ºæ ‘çš„é«˜åº¦ä¸º 2ã€‚

å¯¹äºåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ ‘æ¥è¯´ï¼Œé«˜åº¦ä¸º0ï¼Œæ·±åº¦ä¸º0ã€‚å¦‚æœæ˜¯ç©ºæ ‘ï¼Œé«˜åº¦ã€æ·±åº¦éƒ½æ˜¯ -1.

è¿™æ˜¯åˆç†çš„å®šä¹‰æ–¹å¼ï¼Œä½†éœ€è¦âš ï¸ï¼š

é«˜åº¦ï¼šé€šå¸¸å®šä¹‰ä¸ºä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„è¾¹æ•°ã€‚å¯¹äºç©ºæ ‘ï¼Œé«˜åº¦ä¸º -1 æ˜¯ä¸€ç§å¸¸è§çš„çº¦å®šï¼ˆ<mark>ä½†ä¹Ÿæœ‰äººå®šä¹‰ä¸ºç©ºæ ‘çš„é«˜åº¦ä¸º 0</mark>ï¼‰ã€‚
æ·±åº¦ï¼šé€šå¸¸æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸ªèŠ‚ç‚¹çš„è¾¹æ•°ã€‚å¯¹äºç©ºæ ‘ï¼Œæ·±åº¦æ²¡æœ‰æ„ä¹‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ä¸º -1ã€‚

> **1 æ•™æã€ŠPythonæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æï¼ˆç¬¬2ç‰ˆï¼‰ã€‹ç¬¬å…­ç« **
>
> å±‚çº§ Levelï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ°è¾¾ä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€åŒ…å«çš„è¾¹çš„æ•°é‡ï¼Œç§°ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å±‚çº§ã€‚æ ¹èŠ‚ç‚¹çš„å±‚çº§ä¸º 0ã€‚
>
> é«˜åº¦ Heightï¼šæ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§å±‚çº§ç§°ä¸ºæ ‘çš„é«˜åº¦ã€‚å› æ­¤ç©ºæ ‘çš„é«˜åº¦æ˜¯-1ã€‚
> 
>
> 
>**2 Tree (graph theory)**
> 
>https://en.wikipedia.org/wiki/Tree_(graph_theory)#:~:text=The%20height%20of%20a%20vertex,its%20root%20(root%20path).
> 
><mark>The *height* of a vertex in a rooted tree is the length of the longest downward path to a leaf</mark> from that vertex. The *height* of the tree is the height of the root. <mark>The *depth* of a vertex is the length of the path to its root (*root path*)</mark>. This is commonly needed in the manipulation of the various self-balancing trees, AVL trees in particular. The root has depth zero, leaves have height zero, and a tree with only a single vertex (hence both a root and leaf) has depth and height zero. 
> 
>Conventionally, an empty tree (a tree with no vertices, if such are allowed) has depth and height âˆ’1.
> 
>
> 
>**3 2013-book-DataStructuresAndAlgorithmsInPython, page 308, Chapter 8. Trees**
> 
>Let p be the position of a node of a tree T . The depth of p is the number of ancestors of p, excluding p itself. Note that this definition implies that the depth of the root of T is 0. The depth of p can also be recursively defined as follows:
> â€¢ If p is the root, then the depth of p is 0.
>â€¢ Otherwise, the depth of p is one plus the depth of the parent of p
> 
>```python
> def depth(self, p):
># Return the number of levels separating Position p from the root.
> if self.is_root(p):
>  return 0
> else:
>   return 1 + self.depth(self.parent(p))
> 
>```
> 
> 
>  
>  Height and Depth of a node in a Binary Tree,  https://www.geeksforgeeks.org/height-and-depth-of-a-node-in-a-binary-tree/   The depth of a node is the number of edges present in path from the root node of a tree to that node.
>    The height of a node is the number of edges present in the longest path connecting that node to a leaf node.
>  



æ ¹æ®å‰å››ä¸ªå‚è€ƒå‡ºå¤„ï¼Œé«˜åº¦ã€æ·±åº¦ï¼Œéƒ½æ˜¯æ•°è¾¹çš„ä¸ªæ•°ã€‚

**4 âš ï¸æœ‰çš„é¢˜ç›®ä¸­å®šä¹‰**ï¼šä¸ä¸Šé¢å¸¸è§çš„æ·±åº¦å®šä¹‰ä¸ä¸€è‡´ã€‚ä¾‹å¦‚ï¼š

> 06646:äºŒå‰æ ‘çš„æ·±åº¦ï¼Œhttp://cs101.openjudge.cn/practice/06646/
>
> äºŒå‰æ ‘æ·±åº¦ï¼šä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºæ ‘çš„æ·±åº¦ã€‚
>
> 
> 
>LC104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/
> 
>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root` ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚
> 
>äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚



**æ ‘ Tree**:

å®šä¹‰åŸºæœ¬æœ¯è¯­åï¼Œå°±å¯ä»¥è¿›ä¸€æ­¥ç»™å‡ºæ ‘çš„æ­£å¼å®šä¹‰ã€‚å°†æä¾›ä¸¤ç§å®šä¹‰ï¼Œå…¶ä¸­ä¸€ç§æ¶‰åŠèŠ‚ç‚¹å’Œè¾¹ï¼Œå¦ä¸€ç§æ¶‰åŠé€’å½’ã€‚åœ¨åé¢ä¼šçœ‹åˆ°ï¼Œ<mark>é€’å½’å®šä¹‰å¾ˆæœ‰ç”¨ã€‚</mark>

**å®šä¹‰ä¸€ï¼š**æ ‘ç”±èŠ‚ç‚¹åŠè¿æ¥èŠ‚ç‚¹çš„è¾¹æ„æˆã€‚æ ‘æœ‰ä»¥ä¸‹å±æ€§ï¼š
â æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼›
â é™¤æ ¹èŠ‚ç‚¹å¤–ï¼Œå…¶ä»–æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¸å…¶å”¯ä¸€çš„çˆ¶èŠ‚ç‚¹ç›¸è¿ï¼›
â ä»æ ¹èŠ‚ç‚¹åˆ°å…¶ä»–æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸”ä»…æœ‰ä¸€æ¡è·¯å¾„ï¼›
â å¦‚æœæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±ç§°è¿™æ ·çš„æ ‘ä¸ºäºŒå‰æ ‘ã€‚
å›¾2å±•ç¤ºäº†ä¸€æ£µç¬¦åˆå®šä¹‰ä¸€çš„æ ‘ã€‚è¾¹çš„ç®­å¤´è¡¨ç¤ºè¿æ¥æ–¹å‘ã€‚



![image](https://raw.githubusercontent.com/GMyhf/img/main/img/treedef1.png)

<center>å›¾2 ç”±èŠ‚ç‚¹å’Œè¾¹æ„æˆçš„æ ‘</center>



**å®šä¹‰äºŒï¼š**ä¸€æ£µæ ‘è¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆç”±ä¸€ä¸ªæ ¹èŠ‚ç‚¹å’Œé›¶æ£µæˆ–å¤šæ£µå­æ ‘æ„æˆï¼Œå­æ ‘æœ¬èº«ä¹Ÿæ˜¯ä¸€æ£µæ ‘ã€‚æ¯æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹é€šè¿‡ä¸€æ¡è¾¹è¿åˆ°çˆ¶æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚å›¾3å±•ç¤ºäº†æ ‘çš„é€’å½’å®šä¹‰ã€‚ä»æ ‘çš„é€’å½’å®šä¹‰å¯çŸ¥ï¼Œå›¾ä¸­çš„æ ‘è‡³å°‘æœ‰4ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºä¸‰è§’å½¢ä»£è¡¨çš„å­æ ‘å¿…å®šæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚è¿™æ£µæ ‘æˆ–è®¸æœ‰æ›´å¤šçš„èŠ‚ç‚¹ï¼Œä½†å¿…é¡»æ›´æ·±å…¥åœ°æŸ¥çœ‹å­æ ‘åæ‰èƒ½ç¡®å®šã€‚

![image](https://raw.githubusercontent.com/GMyhf/img/main/img/TreeDefRecursive.png)

<center>å›¾3 æ ‘çš„é€’å½’å®šä¹‰</center>



> Q: æ ‘ç”¨é€’å½’å®ç°æ‰ç®€æ´æ˜“æ‡‚å§ï¼Ÿ
>
> A: æ˜¯çš„ï¼Œé€’å½’å®ç°é€šå¸¸æ›´ç®€æ´æ˜“æ‡‚ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†æ ‘è¿™ç§é€’å½’ç»“æ„æ—¶ã€‚<mark>é€’å½’çš„æ€æƒ³ä¸æ ‘çš„ç»“æ„è‡ªç„¶å¥‘åˆ</mark>ï¼Œå› ä¸ºæ ‘çš„å®šä¹‰æœ¬èº«å°±æ˜¯é€’å½’çš„ï¼šæ ‘ç”±æ ¹èŠ‚ç‚¹å’Œè‹¥å¹²å­æ ‘ç»„æˆï¼Œæ¯ä¸ªå­æ ‘ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯ä¸€æ£µæ ‘ã€‚
>
> é€’å½’å®ç°çš„ä¼˜ç‚¹åŒ…æ‹¬ï¼š
>
> 1. è‡ªç„¶è€Œç›´è§‚ï¼šé€’å½’å®ç°èƒ½å¤Ÿç›´æ¥æ¨¡æ‹Ÿæ ‘çš„ç»“æ„ï¼Œæ›´ç¬¦åˆæˆ‘ä»¬å¯¹æ ‘çš„ç›´è§‰è®¤çŸ¥ï¼Œä½¿ä»£ç æ›´æ˜“ç†è§£å’Œç¼–å†™ã€‚
>
> 2. ä»£ç ç®€æ´ï¼šé€’å½’å®ç°é€šå¸¸æ¯”è¿­ä»£å®ç°ä»£ç æ›´ä¸ºç®€æ´ï¼Œå› ä¸ºé€’å½’èƒ½å¤Ÿåˆ©ç”¨å‡½æ•°çš„è‡ªèº«è°ƒç”¨æ¥å¤„ç†å­æ ‘ã€‚
>
> 3. é€»è¾‘æ¸…æ™°ï¼šé€’å½’å®ç°èƒ½å¤Ÿæ¸…æ™°åœ°è¡¨è¾¾æ ‘çš„éå†å’Œå¤„ç†é€»è¾‘ï¼Œä½¿ä»£ç æ›´æ˜“è¯»ã€‚
>
> ç„¶è€Œï¼Œé€’å½’å®ç°ä¹Ÿæœ‰ä¸€äº›æ½œåœ¨çš„ç¼ºç‚¹ï¼Œä¾‹å¦‚åœ¨å¤„ç†å¤§è§„æ¨¡çš„æ ‘æ—¶å¯èƒ½å¯¼è‡´æ ˆæº¢å‡ºï¼ˆStack Overflowï¼‰çš„é—®é¢˜ã€‚æ­¤å¤–ï¼Œé€’å½’å®ç°æœ‰æ—¶å¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½è¾ƒå·®ï¼Œå› ä¸ºåœ¨é€’å½’è¿‡ç¨‹ä¸­å¯èƒ½ä¼šè¿›è¡Œé‡å¤çš„è®¡ç®—ã€‚
>
> 
>
> Q: æ ‘çš„è§„æ¨¡è¾ƒå°ï¼Œè¾ƒå¤§ï¼Œå…·ä½“å¤§æ¦‚æŒ‡å¤šå°‘ä¸ªèŠ‚ç‚¹å‘¢ï¼Ÿ
>
> A: ä¸€èˆ¬æ¥è¯´ï¼Œæ ‘çš„è§„æ¨¡è¾ƒå°å’Œè¾ƒå¤§æ˜¯ç›¸å¯¹çš„æ¦‚å¿µï¼Œå…·ä½“çš„èŠ‚ç‚¹æ•°é‡å–å†³äºé—®é¢˜çš„ä¸Šä¸‹æ–‡å’Œå®é™…éœ€æ±‚ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„èŠ‚ç‚¹æ•°é‡èŒƒå›´ï¼Œå°½ç®¡è¿™åªæ˜¯ä¸€ç§å¸¸è§çš„åˆ’åˆ†ï¼Œå¹¶ä¸æ˜¯ä¸¥æ ¼çš„ç•Œå®šï¼š
>
> 1. å°å‹æ ‘ï¼šé€šå¸¸æŒ‡èŠ‚ç‚¹æ•°é‡åœ¨å‡ ååˆ°å‡ ç™¾ä¸ªä¹‹é—´çš„æ ‘ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé€’å½’å®ç°å¾€å¾€æ˜¯ç®€æ´æ˜“æ‡‚çš„é€‰æ‹©ï¼Œå¹¶ä¸”æ€§èƒ½æ–¹é¢çš„å·®å¼‚å¯èƒ½å¹¶ä¸æ˜æ˜¾ã€‚
>
> 2. ä¸­å‹æ ‘ï¼šé€šå¸¸æŒ‡èŠ‚ç‚¹æ•°é‡åœ¨å‡ ç™¾åˆ°å‡ åƒä¸ªä¹‹é—´çš„æ ‘ã€‚å¯¹äºä¸­å‹æ ‘ï¼Œé€’å½’å®ç°ä»ç„¶å¯ä»¥è€ƒè™‘ä½¿ç”¨ï¼Œä½†åœ¨æ€§èƒ½æ–¹é¢å¯èƒ½éœ€è¦æ›´åŠ è°¨æ…ï¼Œä»¥é¿å…æ½œåœ¨çš„æ ˆæº¢å‡ºé—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿­ä»£å®ç°å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚
>
> 3. å¤§å‹æ ‘ï¼šé€šå¸¸æŒ‡èŠ‚ç‚¹æ•°é‡åœ¨å‡ åƒåˆ°å‡ ç™¾ä¸‡ï¼ˆç”šè‡³æ›´å¤šï¼‰ä¹‹é—´çš„æ ‘ã€‚å¯¹äºå¤§å‹æ ‘ï¼Œé€’å½’å®ç°å¯èƒ½ä¼šé¢ä¸´æ ˆæº¢å‡ºçš„é£é™©ï¼Œå¹¶ä¸”æ€§èƒ½æ–¹é¢çš„å·®å¼‚å¯èƒ½ä¼šæ›´åŠ æ˜æ˜¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿­ä»£å®ç°é€šå¸¸æ˜¯æ›´å¯é å’Œé«˜æ•ˆçš„é€‰æ‹©ã€‚



**Application of Tree Data Structure**

**æ ‘æ•°æ®ç»“æ„çš„åº”ç”¨**

- **æ–‡ä»¶ç³»ç»Ÿ**ï¼šè¿™ä½¿å¾—æ–‡ä»¶çš„å¯¼èˆªå’Œç»„ç»‡æ›´åŠ é«˜æ•ˆã€‚
- **æ•°æ®å‹ç¼©**ï¼š<mark>**éœå¤«æ›¼ç¼–ç ï¼ˆHuffman codingï¼‰**</mark> æ˜¯ä¸€ç§æµè¡Œçš„æ•°æ®å‹ç¼©æŠ€æœ¯ï¼Œå®ƒé€šè¿‡æ„å»ºä¸€æ£µäºŒå‰æ ‘æ¥å®ç°ï¼Œå…¶ä¸­å¶å­èŠ‚ç‚¹è¡¨ç¤ºå­—ç¬¦åŠå…¶å‡ºç°é¢‘ç‡ã€‚ç”Ÿæˆçš„æ ‘ç”¨äºä»¥æœ€å°åŒ–å­˜å‚¨éœ€æ±‚çš„æ–¹å¼å¯¹æ•°æ®è¿›è¡Œç¼–ç ã€‚
- **ç¼–è¯‘å™¨è®¾è®¡**ï¼šåœ¨ç¼–è¯‘å™¨è®¾è®¡ä¸­ï¼Œ<mark>**æŠ½è±¡è¯­æ³•æ ‘ï¼ˆAbstract Syntax Treeï¼‰** </mark>ç”¨äºè¡¨ç¤ºç¨‹åºçš„ç»“æ„ã€‚
- **æ•°æ®åº“ç´¢å¼•**ï¼šB æ ‘å’Œå…¶ä»–æ ‘ç»“æ„è¢«ç”¨äºæ•°æ®åº“ç´¢å¼•ï¼Œä»¥ä¾¿é«˜æ•ˆåœ°æœç´¢å’Œæ£€ç´¢æ•°æ®ã€‚

---

**æ ‘æ•°æ®ç»“æ„çš„ä¼˜ç‚¹**

- æ ‘æä¾›**é«˜æ•ˆçš„æœç´¢**ï¼Œå…·ä½“æ•ˆç‡å–å†³äºæ ‘çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œåƒ AVL æ ‘è¿™æ ·çš„å¹³è¡¡æ ‘ï¼Œå…¶å¹³å‡æœç´¢æ—¶é—´ä¸º O(log n)ã€‚
- æ ‘ä»¥åˆ†å±‚æ–¹å¼è¡¨ç¤ºæ•°æ®ï¼Œä½¿å¤§é‡ä¿¡æ¯çš„**ç»„ç»‡å’Œå¯¼èˆªå˜å¾—ç®€å•**ã€‚
- <mark>æ ‘çš„é€’å½’ç‰¹æ€§ä½¿å…¶èƒ½å¤Ÿé€šè¿‡é€’å½’ç®—æ³•**è½»æ¾éå†å’Œæ“ä½œ**ã€‚</mark>

---

**æ ‘æ•°æ®ç»“æ„çš„ç¼ºç‚¹**

- ä¸å¹³è¡¡çš„æ ‘ä¼šå¯¼è‡´æ ‘çš„é«˜åº¦åå‘ä¸€ä¾§ï¼Œä»è€Œå¯èƒ½å¼•å‘**ä½æ•ˆçš„æœç´¢æ—¶é—´**ã€‚
- æ ‘éœ€è¦**æ›´å¤šçš„å†…å­˜ç©ºé—´**ï¼Œç›¸æ¯”æ•°ç»„å’Œé“¾è¡¨ç­‰å…¶ä»–æ•°æ®ç»“æ„ï¼Œå°¤å…¶æ˜¯åœ¨æ ‘éå¸¸å¤§çš„æƒ…å†µä¸‹ã€‚



> - **File System**: This allows for efficient navigation and organization of files.
> - **Data Compression**: <mark>**Huffman coding**</mark> is a popular technique for data compression that involves constructing a binary tree where the leaves represent characters and their frequency of occurrence. The resulting tree is used to encode the data in a way that minimizes the amount of storage required.
> - **Compiler Design:** In compiler design, a **syntax tree** is used to represent the structure of a program. 
> - **Database Indexing**: B-trees and other tree structures are used in database indexing to efficiently search for and retrieve data. 
>
> 
>
> **Advantages of Tree Data Structure**
>
> - Tree offer **Efficient Searching** depending on the type of tree, with average search times of O(log n) for balanced trees like AVL. 
> - Trees provide a hierarchical representation of data, making it **easy to organize and navigate** large amounts of information.
> - <mark>The recursive nature of trees makes them **easy to traverse and manipulate** using recursive algorithms.</mark>
>
> 
>
> **Disadvantages of Tree Data Structure**
>
> - Unbalanced Trees, meaning that the height of the tree is skewed towards one side, which can lead to **inefficient search times.**
> - Trees demand **more memory space requirements** than some other data structures like arrays and linked lists, especially if the tree is very large.
>



### 1.1 né˜¶å¤šå‰æ ‘ (N-ary Trees)

æ™®é€šæ ‘ï¼ˆGeneric treesï¼‰æ˜¯ç”±è‹¥å¹²èŠ‚ç‚¹ç»„æˆçš„é›†åˆï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ŒåŒ…å«è®°å½•å’Œä¸€ä¸ªæŒ‡å‘å…¶å­èŠ‚ç‚¹çš„å¼•ç”¨åˆ—è¡¨ï¼ˆä¸å…è®¸é‡å¤å¼•ç”¨ï¼‰ã€‚ä¸é“¾è¡¨ä¸åŒï¼Œæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨äº†å¤šä¸ªèŠ‚ç‚¹çš„åœ°å€ã€‚<mark>æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶å­èŠ‚ç‚¹çš„åœ°å€</mark>ï¼Œè€Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€åˆ™å­˜å‚¨åœ¨ä¸€ä¸ªåä¸º<mark>æ ¹ï¼ˆrootï¼‰</mark>çš„ç‹¬ç«‹æŒ‡é’ˆä¸­ã€‚

æ™®é€šæ ‘æ˜¯ N å‰æ ‘çš„ä¸€ç§ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

1. æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ªå­èŠ‚ç‚¹ã€‚
2. æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡äº‹å…ˆæœªçŸ¥ã€‚

> https://www.geeksforgeeks.org/generic-treesn-array-trees/?ref=outind
>
> Last Updated : 27 Jul, 2024
>
> Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children (duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes. <mark>Every node stores address of its children</mark> and the very first nodeâ€™s address will be stored in a separate pointer called <mark>root</mark>.
>
> The Generic trees are the N-ary trees which have the following properties: 
>
> â€‹      1. Many children at every node.
>
> â€‹      2. The number of nodes for each node is not known in advance.
>

**Example:** 


 ![img](https://raw.githubusercontent.com/GMyhf/img/main/img/generic-tree_gfg.png)



Generic Tree

ä¸ºäº†è¡¨ç¤ºä¸Šè¿°æ ‘ç»“æ„ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘æœ€åçš„æƒ…å†µï¼Œå³æ‹¥æœ‰æœ€å¤šå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼ˆåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæœ‰ 6 ä¸ªå­èŠ‚ç‚¹ï¼‰ï¼Œå¹¶ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ†é…ç›¸åº”æ•°é‡çš„æŒ‡é’ˆã€‚  
åŸºäºæ­¤æ–¹æ³•çš„èŠ‚ç‚¹è¡¨ç¤ºå¯ä»¥å†™ä¸ºï¼š

> To represent the above tree, we have to consider the worst case, that is the node with maximum children (in above example, 6 children) and allocate that many pointers for each node.
> The node representation based on this method can be written as:

```python
class Node: 
	def __init__(self, data): 
		self.data = data 
		self.firstchild = None
		self.secondchild = None
		self.thirdchild = None
		self.fourthchild = None
		self.fifthchild = None
		self.sixthchild = None

```



ä¸Šè¿°è¡¨ç¤ºæ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼š

1. **å†…å­˜æµªè´¹** â€“ å¹¶éæ‰€æœ‰æƒ…å†µä¸‹éƒ½éœ€è¦ç”¨åˆ°æ‰€æœ‰çš„æŒ‡é’ˆï¼Œå› æ­¤ä¼šé€ æˆå¤§é‡çš„å†…å­˜æµªè´¹ã€‚
2. **å­èŠ‚ç‚¹æ•°é‡æœªçŸ¥** â€“ æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡äº‹å…ˆæ— æ³•ç¡®å®šã€‚



**ç®€å•æ–¹æ³•ï¼š**

<mark>ä¸ºäº†å­˜å‚¨èŠ‚ç‚¹ä¸­å­èŠ‚ç‚¹çš„åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ•°ç»„æˆ–é“¾è¡¨</mark>ã€‚ä½†ä¸¤ç§æ–¹æ³•éƒ½ä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ã€‚

1. åœ¨**é“¾è¡¨**ä¸­ï¼Œæˆ‘ä»¬æ— æ³•éšæœºè®¿é—®ä»»æ„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œå› æ­¤æ•ˆç‡è¾ƒä½ï¼Œæˆæœ¬è¾ƒé«˜ã€‚
2. åœ¨**æ•°ç»„**ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥éšæœºè®¿é—®ä»»æ„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œä½†åªèƒ½å­˜å‚¨å›ºå®šæ•°é‡çš„å­èŠ‚ç‚¹åœ°å€ã€‚



**æ›´å¥½çš„æ–¹æ³•ï¼š**

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**åŠ¨æ€æ•°ç»„**æ¥å­˜å‚¨å­èŠ‚ç‚¹çš„åœ°å€ã€‚å®ƒæ—¢å¯ä»¥éšæœºè®¿é—®ä»»æ„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œå…¶å¤§å°ï¼ˆå®¹é‡ï¼‰ä¹Ÿæ²¡æœ‰å›ºå®šçš„é™åˆ¶ã€‚

> Disadvantages of the above representation are: 
>
> 1. Memory Wastage â€“ All the pointers are not required in all the cases. Hence, there is lot of memory wastage.
> 2. Unknown number of children â€“ The number of children for each node is not known in advance.
>
> 
>
> Simple Approach: 
>
> <mark>For storing the address of children in a node we can use an array or linked list</mark>. But we will face some issues with both of them.
>
> 1. In **Linked list**, we can not randomly access any childâ€™s address. So it will be expensive.
> 2. In **array**, we can randomly access the address of any child, but we can store only fixed number of childrenâ€™s addresses in it.
>
> 
>
> **Better Approach:**
>
> We can use **Dynamic Arrays** for storing the address of children. We can randomly access any childâ€™s address and the size of the vector is also not fixed.
>

```python
class Node: 
	
	def __init__(self,data): 
		self.data=data 
		self.children=[]

```



#### é«˜æ•ˆæ–¹æ³•ï¼šé•¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•

åœ¨â€œé•¿å­ / ä¸‹ä¸€ä¸ªå…„å¼Ÿâ€è¡¨ç¤ºæ³•ä¸­ï¼Œé‡‡å–çš„æ­¥éª¤å¦‚ä¸‹ï¼š

1. å°†åŒä¸€çˆ¶èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼ˆå³å…„å¼ŸèŠ‚ç‚¹ï¼‰ä»å·¦åˆ°å³é“¾æ¥èµ·æ¥ã€‚
2. ç§»é™¤çˆ¶èŠ‚ç‚¹åˆ°æ‰€æœ‰å­èŠ‚ç‚¹çš„é“¾æ¥ï¼Œåªä¿ç•™åˆ°ç¬¬ä¸€ä¸ªå­©å­çš„é“¾æ¥ã€‚

ç”±äºå­èŠ‚ç‚¹ä¹‹é—´å·²ç»å»ºç«‹äº†é“¾æ¥ï¼Œå› æ­¤ä¸éœ€è¦ä»çˆ¶èŠ‚ç‚¹åˆ°æ‰€æœ‰å­èŠ‚ç‚¹çš„é¢å¤–é“¾æ¥ã€‚è¿™ç§è¡¨ç¤ºæ³•å…è®¸æˆ‘ä»¬é€šè¿‡ä»çˆ¶èŠ‚ç‚¹çš„ç¬¬ä¸€ä¸ªå­©å­å¼€å§‹ï¼Œéå†æ‰€æœ‰çš„å…ƒç´ ã€‚



> #### Efficient Approach
>
> <mark>First child / Next sibling representation</mark>
>
>  In the first child/next sibling representation, the steps taken are: 
>
> At each node-link the children of the same parent(siblings) from left to right.
>
> - Remove the links from parent to all children except the first child.
>
> Since we have a link between children, we do not need extra links from parents to all the children. This representation allows us to traverse all the elements by starting at the first child of the parent.
>




 <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/generictree_gfg.png" alt="img" style="zoom:67%;" />



FIRST CHILD/NEXT SIBLING REPRESENTATION



The node declaration for first child / next sibling representation can be written as: 

```python
class Node: 
	def __init__(self, data): 
		self.data = data 
		self.firstChild = None
		self.nextSibling = None

		# This code is contributed by aadityamaharshi

```

**ä¼˜ç‚¹ï¼š**

- **å†…å­˜é«˜æ•ˆ** â€“ ä¸éœ€è¦é¢å¤–çš„é“¾æ¥ï¼Œå› æ­¤èŠ‚çœäº†å¤§é‡å†…å­˜ã€‚
- **å¯è§†ä¸ºäºŒå‰æ ‘** â€“ ç”±äºæˆ‘ä»¬èƒ½å¤Ÿå°†ä»»ä½•é€šç”¨æ ‘è½¬æ¢ä¸ºäºŒå‰æ ‘è¡¨ç¤ºå½¢å¼ï¼Œå› æ­¤å¯ä»¥<mark>å°†æ‰€æœ‰ä½¿ç”¨â€œç¬¬ä¸€ä¸ªå­©å­/ä¸‹ä¸€ä¸ªå…„å¼Ÿâ€è¡¨ç¤ºæ³•çš„é€šç”¨æ ‘è§†ä¸ºäºŒå‰æ ‘</mark>ã€‚æˆ‘ä»¬åªéœ€ä½¿ç”¨ `firstChild`ï¼ˆç¬¬ä¸€ä¸ªå­©å­ï¼‰å’Œ `nextSibling`ï¼ˆä¸‹ä¸€ä¸ªå…„å¼Ÿï¼‰ï¼Œè€Œä¸ç”¨ä¼ ç»Ÿçš„å·¦æŒ‡é’ˆå’Œå³æŒ‡é’ˆã€‚
- **ç®—æ³•æ›´æ˜“è¡¨è¾¾** â€“ å› ä¸ºå®ƒæœ¬è´¨ä¸Šæ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œè®¸å¤šç®—æ³•å¯ä»¥æ›´è½»æ¾åœ°å®ç°ã€‚
- **èŠ‚ç‚¹å¤§å°å›ºå®š** â€“ æ¯ä¸ªèŠ‚ç‚¹çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå› æ­¤ä¸éœ€è¦è¾…åŠ©æ•°ç»„æˆ–å‘é‡æ¥å­˜å‚¨å­èŠ‚ç‚¹ä¿¡æ¯ã€‚

> **Advantages:** 
>
> - Memory efficient â€“ No extra links are required, hence a lot of memory is saved.
> - Treated as binary trees â€“ Since we are able to convert any generic tree to binary representation, we can <mark>treat all generic trees with a first child/next sibling representation as binary trees</mark>. Instead of left and right pointers, we just use firstChild and nextSibling.
> - Many algorithms can be expressed more easily because it is just a binary tree.
> - Each node is of fixed size, so no auxiliary array or vector is required.
>



##### ç¬”è¯•å¡«ç©º@20240618

Q. è®¾æ£®æ—Fä¸­æœ‰4æ£µæ ‘ï¼Œç¬¬1ã€2ã€3ã€4æ£µæ ‘çš„ç»“ç‚¹ä¸ªæ•°åˆ†åˆ«ä¸º10ã€9ã€11ã€7ï¼Œå½“æŠŠæ£®æ—Fè½¬æ¢æˆä¸€æ£µäºŒå‰æ ‘åï¼Œå…¶æ ¹ç»“ç‚¹çš„å³å­æ ‘ä¸­æœ‰å¤šå°‘ä¸ªç»“ç‚¹ï¼Ÿ

> **æ£®æ—è½¬æ¢ä¸ºäºŒå‰æ ‘**
>
> åœ¨æ ‘çš„è½¬æ¢è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ **â€œé•¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•â€**ï¼Œå³ï¼š
> 1. **æ¯æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä¸å˜**ï¼Œå®ƒçš„**ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹**ä½œä¸ºå®ƒçš„**å·¦å­©å­**ã€‚
> 2. **æ¯ä¸ªèŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹**ä½œä¸ºå®ƒçš„**å³å­©å­**ã€‚
>
> **åˆ†æé¢˜ç›®**
>
> æ£®æ— \( F \) ç”± 4 æ£µæ ‘ç»„æˆï¼š
> - **ç¬¬ 1 æ£µæ ‘**ï¼š10 ä¸ªèŠ‚ç‚¹
> - **ç¬¬ 2 æ£µæ ‘**ï¼š9 ä¸ªèŠ‚ç‚¹
> - **ç¬¬ 3 æ£µæ ‘**ï¼š11 ä¸ªèŠ‚ç‚¹
> - **ç¬¬ 4 æ£µæ ‘**ï¼š7 ä¸ªèŠ‚ç‚¹
>
> æ£®æ—è½¬æ¢ä¸ºäºŒå‰æ ‘åï¼š
> - **äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹** æ˜¯ **æ£®æ—çš„ç¬¬ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹**ã€‚
> - **æ ¹èŠ‚ç‚¹çš„å³å­©å­** æ˜¯ **ç¬¬äºŒæ£µæ ‘çš„æ ¹èŠ‚ç‚¹**ï¼Œå®ƒçš„å³å­©å­æ˜¯ **ç¬¬ä¸‰æ£µæ ‘çš„æ ¹èŠ‚ç‚¹**ï¼Œä¾æ¬¡ç±»æ¨ã€‚
> - **æ ¹èŠ‚ç‚¹çš„å³å­æ ‘** åŒ…å« **æ‰€æœ‰å…¶ä»–æ ‘çš„èŠ‚ç‚¹**ï¼Œå³**ç¬¬ 2ã€3ã€4 æ£µæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹**ã€‚
>
> **è®¡ç®—æ ¹èŠ‚ç‚¹å³å­æ ‘çš„èŠ‚ç‚¹æ•°**
>
> æ ¹èŠ‚ç‚¹çš„å³å­æ ‘åŒ…æ‹¬ï¼š
> - ç¬¬ 2 æ£µæ ‘çš„ 9 ä¸ªèŠ‚ç‚¹
> - ç¬¬ 3 æ£µæ ‘çš„ 11 ä¸ªèŠ‚ç‚¹
> - ç¬¬ 4 æ£µæ ‘çš„ 7 ä¸ªèŠ‚ç‚¹
>
> 9 + 11 + 7 = 27



### 1.2 ğŸŒ²çš„é¢˜ç›®é€’å½’å†™æ³•é€šå¸¸æ˜¯é¦–é€‰

æ ‘ç»“æ„çš„é¢˜ç›®éå¸¸é€‚åˆç”¨é€’å½’æ¥è§£å†³ï¼Œå› ä¸ºæ ‘æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€’å½’å®šä¹‰çš„æ•°æ®ç»“æ„â€”â€”æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªåŒ…å«å­èŠ‚ç‚¹çš„å°æ ‘ã€‚ä½¿ç”¨é€’å½’æ–¹æ³•æ¥è§£å†³é—®é¢˜å¯ä»¥ä½¿ä»£ç æ›´ç®€æ´ã€æ˜“è¯»ï¼Œå¹¶ä¸”é€šå¸¸æ›´å®¹æ˜“ç†è§£ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„æ ‘æ“ä½œç¤ºä¾‹ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨é€’å½’<mark>ä¼˜é›…</mark>åœ°å®ç°å®ƒä»¬ã€‚

ä½¿ç”¨ç±»ï¼ˆclassï¼‰æ¥å®šä¹‰æ ‘çš„èŠ‚ç‚¹ã€‚æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸‰ä¸ªå±æ€§ï¼šèŠ‚ç‚¹çš„å€¼ (`val`)ã€æŒ‡å‘å·¦å­èŠ‚ç‚¹çš„å¼•ç”¨ (`left`) å’ŒæŒ‡å‘å³å­èŠ‚ç‚¹çš„å¼•ç”¨ (`right`)ã€‚

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```



#### 1. éå†ï¼ˆTraversalï¼‰

##### å‰åºéå†ï¼ˆPre-order Traversalï¼‰

å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’åœ°å‰åºéå†å·¦å­æ ‘ï¼Œæœ€åé€’å½’åœ°å‰åºéå†å³å­æ ‘ã€‚

```python
def preorder_traversal(root):
    if root:
        print(root.val)  # è®¿é—®æ ¹èŠ‚ç‚¹
        preorder_traversal(root.left)  # é€’å½’éå†å·¦å­æ ‘
        preorder_traversal(root.right)  # é€’å½’éå†å³å­æ ‘
```



##### ä¸­åºéå†ï¼ˆIn-order Traversalï¼‰

å…ˆé€’å½’åœ°ä¸­åºéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åé€’å½’åœ°ä¸­åºéå†å³å­æ ‘ã€‚

```python
def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)  # é€’å½’éå†å·¦å­æ ‘
        print(root.val)  # è®¿é—®æ ¹èŠ‚ç‚¹
        inorder_traversal(root.right)  # é€’å½’éå†å³å­æ ‘
```



###### ç¤ºä¾‹LC94.äºŒå‰æ ‘çš„ä¸­åºéå†

https://leetcode.cn/problems/binary-tree-inorder-traversal/

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› *å®ƒçš„ **ä¸­åº** éå†* ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom: 50%;" />

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,3,2]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
- `-100 <= Node.val <= 100`



```python
from typing import Optional, List

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        
        def dfs(node: Optional[TreeNode]):
            if not node:
                return
            dfs(node.left)
            result.append(node.val)
            dfs(node.right)
        
        dfs(root)
        return result
```



> ç”¨stackæ¨¡æ‹Ÿçš„â€œ<mark>é¢œè‰²å¡«å……æ³•</mark>â€ï¼Œå’Œé€’å½’çš„æ€è·¯å…¶å®å¾ˆç›¸ä¼¼ã€‚
>
> æ ¸å¿ƒæ€æƒ³å¦‚ä¸‹ï¼š
>
> - ä½¿ç”¨é¢œè‰²æ ‡è®°èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œæ–°èŠ‚ç‚¹ä¸ºç™½è‰²ï¼Œå·²è®¿é—®çš„èŠ‚ç‚¹ä¸ºç°è‰²ã€‚
>- å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸ºç™½è‰²ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºç°è‰²ï¼Œç„¶åå°†å…¶å³å­èŠ‚ç‚¹ã€è‡ªèº«ã€å·¦å­èŠ‚ç‚¹ä¾æ¬¡å…¥æ ˆã€‚
> - å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸ºç°è‰²ï¼Œåˆ™å°†èŠ‚ç‚¹çš„å€¼è¾“å‡ºã€‚
>
> ```python
> # Definition for a binary tree node.
> # class TreeNode:
>#     def __init__(self, val=0, left=None, right=None):
> #         self.val = val
> #         self.left = left
> #         self.right = right
> class Solution:
>     def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
>         white, gray = 0, 1
>         res = []
>         stack = [(white, root)]
>         while stack:
>             color, node = stack.pop()
>             if node is None: continue
>             if color == white:
>                 stack.append((white, node.right))
>                 stack.append((gray, node))
>                 stack.append((white, node.left))
>             else:
>                 res.append(node.val)
>         return res
> ```
> 



##### ååºéå†ï¼ˆPost-order Traversalï¼‰

å…ˆé€’å½’åœ°ååºéå†å·¦å­æ ‘ï¼Œç„¶åé€’å½’åœ°ååºéå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚

```python
def postorder_traversal(root):
    if root:
        postorder_traversal(root.left)  # é€’å½’éå†å·¦å­æ ‘
        postorder_traversal(root.right)  # é€’å½’éå†å³å­æ ‘
        print(root.val)  # è®¿é—®æ ¹èŠ‚ç‚¹
```



##### å±‚åºéå†ï¼šæŒ‰å±‚ä»å·¦åˆ°å³ä¾æ¬¡éå†

###### ç»ƒä¹ LC102.äºŒå‰æ ‘çš„å±‚åºéå†

bfs, https://leetcode.cn/problems/binary-tree-level-order-traversal/

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†** ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" style="zoom:67%;" />

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-1000 <= Node.val <= 1000`





```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)
            level = []

            for _ in range(level_size):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)

        return result
        
```





#### 2. æ±‚æ ‘çš„é«˜åº¦/æ·±åº¦

```python
def tree_height(root):
    if not root:  # ç©ºæ ‘çš„é«˜åº¦ä¸º 0
        return 0
    
    left_height = tree_height(root.left)  # å·¦å­æ ‘çš„é«˜åº¦
    right_height = tree_height(root.right)  # å³å­æ ‘çš„é«˜åº¦
    
    return max(left_height, right_height) + 1  # æ ‘çš„é«˜åº¦æ˜¯å·¦å³å­æ ‘æœ€å¤§é«˜åº¦åŠ  1
```



###### ç¤ºä¾‹LC104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

tree, dfs, https://leetcode.cn/problems/maximum-depth-of-binary-tree/

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root` ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" style="zoom:50%;" />

 

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š3
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1,null,2]
è¾“å‡ºï¼š2
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨ `[0, 10^4]` åŒºé—´å†…ã€‚
- `-100 <= Node.val <= 100`



å·²çŸ¥æ ‘æ ¹root

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def tree_depth(node):
            if node is None:
                return 0
            left_depth = tree_depth(node.left)
            right_depth = tree_depth(node.right)
            return max(left_depth, right_depth) + 1
        
        return tree_depth(root)
```



###### ç»ƒä¹ M06646: äºŒå‰æ ‘çš„æ·±åº¦

http://cs101.openjudge.cn/practice/06646/

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è¯¥äºŒå‰æ ‘çš„æ·±åº¦

äºŒå‰æ ‘**æ·±åº¦**å®šä¹‰ï¼šä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºæ ‘çš„æ·±åº¦

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºäºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚äºŒå‰æ ‘ç»“ç‚¹ç¼–å·ä»1åˆ°nï¼Œæ ¹ç»“ç‚¹ä¸º1ï¼Œn <= 10
æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œä¾æ¬¡å¯¹åº”äºŒå‰æ ‘çš„nä¸ªèŠ‚ç‚¹ã€‚
æ¯è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„å·¦å„¿å­å’Œå³å„¿å­çš„èŠ‚ç‚¹ç¼–å·ã€‚å¦‚æœç¬¬ä¸€ä¸ªï¼ˆç¬¬äºŒä¸ªï¼‰æ•°ä¸º-1åˆ™è¡¨ç¤ºæ²¡æœ‰å·¦ï¼ˆå³ï¼‰å„¿å­

**è¾“å‡º**

è¾“å‡ºä¸€ä¸ªæ•´å‹æ•°ï¼Œè¡¨ç¤ºæ ‘çš„æ·±åº¦

æ ·ä¾‹è¾“å…¥

```
3
2 3
-1 -1
-1 -1
```

æ ·ä¾‹è¾“å‡º

```
2
```



 æ¨èè¿™ç§ç±»çš„å†™æ³•ï¼Œåœ¨ç¬”è¯•ä¸­ä¹Ÿå¸¸è§ã€‚<mark>æ ¹æ®è¾“å…¥å»ºæ ‘ï¼ŒçŸ¥é“æ ‘æ ¹ä½ç½®</mark>ã€‚

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def build_tree(nodes):
    if not nodes:
        return None

    tree_nodes = [None] * (len(nodes) + 1)
    for i in range(1, len(nodes) + 1):
        tree_nodes[i] = TreeNode(i)

    for i, (left, right) in enumerate(nodes, start=1):
        if left != -1:
            tree_nodes[i].left = tree_nodes[left]
        if right != -1:
            tree_nodes[i].right = tree_nodes[right]

    return tree_nodes[1]


def tree_depth(root):
    if not root:
        return 0
    left_depth = tree_depth(root.left)
    right_depth = tree_depth(root.right)
    return max(left_depth, right_depth) + 1


def main():
    n = int(input())
    nodes = []
    index = 1
    for _ in range(n):
        left, right = map(int, input().split())
        nodes.append((left, right))

    root = build_tree(nodes)
    depth = tree_depth(root)
    print(depth)


if __name__ == "__main__":
    main()

```





###### ç»ƒä¹ M27638: æ±‚äºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­æ•°ç›®

http://cs101.openjudge.cn/practice/27638/

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è¯¥äºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­æ•°ç›®äºŒå‰æ ‘**é«˜åº¦**å®šä¹‰ï¼šä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„ç»“ç‚¹æ•°å‡1ä¸ºæ ‘çš„é«˜åº¦ã€‚åªæœ‰ä¸€ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œé«˜åº¦æ˜¯0ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºäºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚äºŒå‰æ ‘ç»“ç‚¹ç¼–å·ä»0åˆ°n-1ï¼Œæ ¹ç»“ç‚¹n <= 100 æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œä¾æ¬¡å¯¹åº”äºŒå‰æ ‘çš„ç¼–å·ä¸º0,1,2....n-1çš„èŠ‚ç‚¹ã€‚ æ¯è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„å·¦å„¿å­å’Œå³å„¿å­çš„ç¼–å·ã€‚å¦‚æœç¬¬ä¸€ä¸ªï¼ˆç¬¬äºŒä¸ªï¼‰æ•°ä¸º-1åˆ™è¡¨ç¤ºæ²¡æœ‰å·¦ï¼ˆå³ï¼‰å„¿å­

**è¾“å‡º**

åœ¨ä¸€è¡Œä¸­è¾“å‡º2ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºäºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­ç»“ç‚¹ä¸ªæ•°

æ ·ä¾‹è¾“å…¥

```
3
-1 -1
0 2
-1 -1
```

æ ·ä¾‹è¾“å‡º

```
1 2
```



æ ¹æ®è¾“å…¥å»ºæ ‘ï¼Œ<mark>æ‰¾åˆ°æ ‘æ ¹</mark>ã€‚

```python
class TreeNode:
    def __init__(self):
        self.left = None
        self.right = None

def tree_height(node):
    if node is None:
        return -1  # æ ¹æ®å®šä¹‰ï¼Œç©ºæ ‘é«˜åº¦ä¸º-1
    return max(tree_height(node.left), tree_height(node.right)) + 1

def count_leaves(node):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        return 1
    return count_leaves(node.left) + count_leaves(node.right)

n = int(input())  # è¯»å–èŠ‚ç‚¹æ•°é‡
nodes = [TreeNode() for _ in range(n)]
has_parent = [False] * n  # ç”¨æ¥æ ‡è®°èŠ‚ç‚¹æ˜¯å¦æœ‰çˆ¶èŠ‚ç‚¹

for i in range(n):
    left_index, right_index = map(int, input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index]
        has_parent[left_index] = True
    if right_index != -1:
        #print(right_index)
        nodes[i].right = nodes[right_index]
        has_parent[right_index] = True

# å¯»æ‰¾æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹
root_index = has_parent.index(False)
root = nodes[root_index]

# è®¡ç®—é«˜åº¦å’Œå¶å­èŠ‚ç‚¹æ•°
height = tree_height(root)
leaves = count_leaves(root)

print(f"{height} {leaves}")
```






#### 3. åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒ

```python
def is_same_tree(p, q):
    if not p and not q:
        return True
    if not p or not q:
        return False
    return (p.val == q.val and
            is_same_tree(p.left, q.left) and
            is_same_tree(p.right, q.right))
```



###### ç¤ºä¾‹LC101.å¯¹ç§°äºŒå‰æ ‘

https://leetcode.cn/problems/symmetric-tree/

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
è¾“å‡ºï¼štrue
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
è¾“å‡ºï¼šfalse
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[1, 1000]` å†…
- `-100 <= Node.val <= 100`



```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        def isMirror(left: TreeNode, right: TreeNode) -> bool:
            if not left and not right:
                return True
            if not left or not right:
                return False
            return (left.val == right.val) and isMirror(left.left, right.right) and isMirror(left.right, right.left)

        return isMirror(root.left, root.right)
```



#### 4. ç¿»è½¬äºŒå‰æ ‘

```python
def invert_tree(root):
    if root:
        root.left, root.right = invert_tree(root.right), invert_tree(root.left)
    return root
```



###### ç¤ºä¾‹LC226.ç¿»è½¬äºŒå‰æ ‘

https://leetcode.cn/problems/invert-binary-tree/

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
è¾“å‡ºï¼š[4,7,2,9,6,3,1]
```

**ç¤ºä¾‹ 2ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [2,1,3]
è¾“å‡ºï¼š[2,3,1]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´åœ¨ `[0, 100]` å†…
- `-100 <= Node.val <= 100`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```





#### 5. å¯»æ‰¾äºŒå‰æœç´¢æ ‘ä¸­çš„æœ€å°å€¼/æœ€å¤§å€¼

å¯¹äºäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæœ€å°å€¼åœ¨æœ€å·¦è¾¹ï¼Œæœ€å¤§å€¼åœ¨æœ€å³è¾¹ã€‚<mark>BSTå„ç§ç¿»è¯‘çš„åå­—éƒ½éœ€è¦è®¤è¯†</mark>ã€‚

| ä¸­æ–‡ç¿»è¯‘  | è‹±æ–‡åŸå                    | ä½¿ç”¨åœºæ™¯         |
| ----- | ---------------------------- | ------------ |
| äºŒå‰æœç´¢æ ‘ | **Binary Search Tree (BST)** | æœ€å¸¸è§ç¿»è¯‘ï¼Œé€šç”¨æ€§å¼º   |
| äºŒå‰æŸ¥æ‰¾æ ‘ | **Binary Search Tree**       | å¼ºè°ƒæŸ¥æ‰¾åŠŸèƒ½       |
| äºŒå‰æ’åºæ ‘ | **Binary Ordered Tree**      | å¼ºè°ƒæ’åºç‰¹æ€§       |
| äºŒå‰æ£€ç´¢æ ‘ | **Binary Retrieval Tree**    | å¼ºè°ƒæ£€ç´¢åŠŸèƒ½       |
| æœ‰åºäºŒå‰æ ‘ | **Ordered Binary Tree**      | å¼ºè°ƒæœ‰åºæ€§        |
| BST   | **BST (Binary Search Tree)** | æŠ€æœ¯æ–‡æ¡£ã€ä»£ç æ³¨é‡Šä¸­å¸¸ç”¨ |


```python
def find_min(root):
    if not root.left:
        return root.val
    return find_min(root.left)

def find_max(root):
    if not root.right:
        return root.val
    return find_max(root.right)
```



###### ç»ƒä¹ M230.äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 

https://leetcode.cn/problems/kth-smallest-element-in-a-bst/

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œå’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ `k` å°çš„å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [3,1,4,null,2], k = 1
è¾“å‡ºï¼š1
```

**ç¤ºä¾‹ 2ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [5,3,6,2,4,null,null,1], k = 3
è¾“å‡ºï¼š3
```

 

 

**æç¤ºï¼š**

- æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ä¸º `n` ã€‚
- `1 <= k <= n <= 10^4`
- `0 <= Node.val <= 10^4`

 

**è¿›é˜¶ï¼š**å¦‚æœäºŒå‰æœç´¢æ ‘ç»å¸¸è¢«ä¿®æ”¹ï¼ˆæ’å…¥/åˆ é™¤æ“ä½œï¼‰å¹¶ä¸”ä½ éœ€è¦é¢‘ç¹åœ°æŸ¥æ‰¾ç¬¬ `k` å°çš„å€¼ï¼Œä½ å°†å¦‚ä½•ä¼˜åŒ–ç®—æ³•ï¼Ÿ



BSTçš„ä¸­åºéå†æ˜¯å‡åºçš„ã€‚åªéœ€è¦å¯¹BSTè¿›è¡Œ **ä¸­åºéå†**ï¼Œéå†åˆ°ç¬¬ `k` ä¸ªèŠ‚ç‚¹æ—¶è¿”å›å®ƒå³å¯ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root, k):
        self.k = k
        self.result = None

        def inorder(node):
            if not node or self.result is not None:
                return
            inorder(node.left)
            self.k -= 1
            if self.k == 0:
                self.result = node.val
                return
            inorder(node.right)

        inorder(root)
        return self.result

        
```



#### 6. åˆ¤æ–­æ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘

ä¸€ä¸ªäºŒå‰æ ‘æ˜¯å¹³è¡¡çš„ï¼Œå¦‚æœå®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1ã€‚

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_balanced(root):
    def check_height(node):
        if not node:
            return 0
        
        left_height = check_height(node.left)
        if left_height == -1:
            return -1  # Left subtree is unbalanced
        
        right_height = check_height(node.right)
        if right_height == -1:
            return -1  # Right subtree is unbalanced
        
        if abs(left_height - right_height) > 1:
            return -1  # Current node is unbalanced
        
        return max(left_height, right_height) + 1
    
    return check_height(root) != -1


# æ„å»ºå¦‚ä¸‹æ‰€ç¤ºçš„å¹³è¡¡äºŒå‰æ ‘ï¼š
#         3
#        / \
#       9  20
#         /  \
#        15   7

root_balanced = TreeNode(3)
root_balanced.left = TreeNode(9)
root_balanced.right = TreeNode(20, TreeNode(15), TreeNode(7))

print("Balanced Tree:", "Yes" if is_balanced(root_balanced) else "No")
# Balanced Tree: Yes

# æ„å»ºå¦‚ä¸‹æ‰€ç¤ºçš„ä¸å¹³è¡¡äºŒå‰æ ‘ï¼š
#         1
#          \
#           2
#            \
#             3
#              \
#               4

root_unbalanced = TreeNode(1)
root_unbalanced.right = TreeNode(2)
root_unbalanced.right.right = TreeNode(3)
root_unbalanced.right.right.right = TreeNode(4)

print("Unbalanced Tree:", "Yes" if is_balanced(root_unbalanced) else "No")
# Unbalanced Tree: No
```

ä»¥ä¸Šè¿™äº›ä¾‹å­å±•ç¤ºäº†å¦‚ä½•é€šè¿‡é€’å½’ä¼˜é›…åœ°è§£å†³ä¸€äº›å¸¸è§çš„æ ‘é—®é¢˜ã€‚é€’å½’è§£æ³•é€šå¸¸èƒ½å¤Ÿæ¸…æ™°åœ°è¡¨è¾¾ç®—æ³•é€»è¾‘ï¼Œä½¿å¾—ä»£ç æ›´åŠ å®¹æ˜“ç†è§£å’Œç»´æŠ¤ã€‚ä¸è¿‡ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œé€’å½’å¯èƒ½ä¼šå¯¼è‡´æ ˆæº¢å‡ºçš„é—®é¢˜ï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†éå¸¸æ·±çš„æ ‘æ—¶ã€‚ç„¶è€Œï¼Œé€šå¸¸æ ‘çš„é¢˜ç›®ä¸å¡æ—¶é—´ï¼Œå› æ­¤é€’å½’å†™æ³•é€šå¸¸æ˜¯é¦–é€‰</mark>ã€‚



### 1.3 ç¼–ç¨‹é¢˜ç›®more

åŠ›æ‰£çƒ­é¢˜100ä¸­ï¼Œæœ‰15ä¸ªé¢˜ç›®æ˜¯äºŒå‰æ ‘ç›¸å…³ï¼Œæ˜¯æ¯”é‡æœ€å¤§çš„ä¸€ç±»é¢˜ç›®ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250325135922245.png" alt="image-20250325135922245" style="zoom:50%;" />



ã€Šç®—æ³•ç¬”è®°ã€‹é…å¥—æ™´é—®ç½‘ç«™ä¸­ï¼Œæœ‰46ä¸ªé¢˜ç›®æ˜¯æ ‘ç›¸å…³ï¼Œæ˜¯æ¯”é‡æœ€å¤§çš„ä¸€ç±»é¢˜ç›®ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250325140647186.png" alt="image-20250325140647186" style="zoom: 33%;" />





## 2 ğŸŒ²çš„è¡¨ç¤ºæ–¹æ³•Representation

https://blog.csdn.net/qq_41891805/article/details/104473065

2020-02-24

æ ‘æ˜¯n (n>=0) ä¸ªç»“ç‚¹çš„æœ‰é™é›†ã€‚åœ¨ä»»æ„ä¸€æ£µéç©ºæ ‘ä¸­ï¼š
ï¼ˆ1ï¼‰æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ ¹ç»“ç‚¹ï¼›ï¼ˆ2ï¼‰é™¤æ ¹ç»“ç‚¹å¤–ï¼Œå…¶ä½™çš„ç»“ç‚¹å¯åˆ†ä¸ºm (m>=0) ä¸ªäº’ä¸ç›¸äº¤çš„å­æ ‘ã€‚



**æ ‘çš„è¡¨ç¤ºæ–¹æ³•åŒ…æ‹¬**

### 2.1 åµŒå¥—æ‹¬å·è¡¨ç¤ºæ³• 

Nested parentheses representation æ˜¯ä¸€ç§è¡¨ç¤ºæ ‘ç»“æ„çš„æ–¹æ³•ï¼Œé€šè¿‡æ‹¬å·çš„åµŒå¥—æ¥è¡¨ç¤ºæ ‘çš„å±‚æ¬¡å…³ç³»ã€‚

å…ˆå°†æ ¹ç»“ç‚¹æ”¾å…¥ä¸€å¯¹åœ†æ‹¬å·ä¸­ï¼Œç„¶åæŠŠå®ƒçš„å­æ ‘æŒ‰ç”±å·¦è€Œå³çš„é¡ºåºæ”¾å…¥æ‹¬å·ä¸­ï¼Œè€Œå¯¹å­æ ‘ä¹Ÿé‡‡ç”¨åŒæ ·æ–¹æ³•å¤„ç†ï¼šåŒå±‚å­æ ‘ä¸å®ƒçš„æ ¹ç»“ç‚¹ç”¨åœ†æ‹¬å·æ‹¬èµ·æ¥ï¼ŒåŒå±‚å­æ ‘ä¹‹é—´ç”¨é€—å·éš”å¼€ï¼Œæœ€åç”¨é—­æ‹¬å·æ‹¬èµ·æ¥ã€‚ä¾‹å¦‚ä¸‹å›¾å¯å†™æˆå¦‚ä¸‹å½¢å¼
$(a(b,c,d,e))$
    a
/ | | \
b c d e



#### ç»ƒä¹ T27637:æ‹¬å·åµŒå¥—äºŒå‰æ ‘

dfs, stack, http://cs101.openjudge.cn/practice/27637

å¯ä»¥ç”¨æ‹¬å·åµŒå¥—çš„æ–¹å¼æ¥è¡¨ç¤ºä¸€æ£µäºŒå‰æ ‘ã€‚

æ–¹æ³•å¦‚ä¸‹ï¼š

`*`è¡¨ç¤ºç©ºçš„äºŒå‰æ ‘ã€‚å¦‚æœä¸€æ£µäºŒå‰æ ‘åªæœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œåˆ™è¯¥æ ‘å°±ç”¨ä¸€ä¸ªé`*`å­—ç¬¦è¡¨ç¤ºï¼Œä»£è¡¨å…¶æ ¹ç»“ç‚¹ã€‚

å¦‚æœä¸€æ£µäºŒå‰å·¦å³å­æ ‘éƒ½éç©ºï¼Œåˆ™ç”¨â€œæ ‘æ ¹(å·¦å­æ ‘,å³å­æ ‘)â€çš„å½¢å¼è¡¨ç¤ºã€‚æ ‘æ ¹æ˜¯ä¸€ä¸ªé'*'å­—ç¬¦ï¼Œå·¦å³å­æ ‘ä¹‹é—´ç”¨é€—å·éš”å¼€ï¼Œæ²¡æœ‰ç©ºæ ¼ã€‚å·¦å³å­æ ‘éƒ½ç”¨æ‹¬å·åµŒå¥—æ³•è¡¨ç¤ºã€‚

å¦‚æœå·¦å­æ ‘éç©ºè€Œå³å­æ ‘ä¸ºç©ºï¼Œåˆ™ç”¨`æ ‘æ ¹(å·¦å­æ ‘,*)`å½¢å¼è¡¨ç¤ºï¼›å¦‚æœå·¦å­æ ‘ä¸ºç©ºè€Œå³å­æ ‘éç©ºï¼Œåˆ™ç”¨<mark>`æ ‘æ ¹(*,å³å­æ ‘)`</mark>å½¢å¼è¡¨ç¤ºã€‚

ç»™å‡ºä¸€æ£µæ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼ï¼Œè¯·è¾“å‡ºå…¶å‰åºéå†åºåˆ—ã€ä¸­åºéå†åºåˆ—ã€ååºéå†åºåˆ—ã€‚ä¾‹å¦‚ï¼Œ`A(B(*,C),D(E))`è¡¨ç¤ºçš„äºŒå‰æ ‘å¦‚å›¾æ‰€ç¤º

<img src="http://media.openjudge.cn/images/upload/1636/1707558029.jpg" alt="img" style="zoom:67%;" />

è¾“å…¥

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°nè¡¨ç¤ºæœ‰næ£µäºŒå‰æ ‘(n<100) æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œæ¯è¡Œæ˜¯1æ£µäºŒå‰æ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼

è¾“å‡º

å¯¹æ¯æ£µäºŒå‰æ ‘ï¼Œè¾“å‡ºå…¶å‰åºéå†åºåˆ—å’Œä¸­åºéå†åºåˆ—

æ ·ä¾‹è¾“å…¥

```
2
A
A(B(*,C),D(E,*))
```

æ ·ä¾‹è¾“å‡º

```
A
A
ABCDE
BCAED
```

æ¥æºï¼šæ”¹ç¼–è‡ª http://dsbpython.openjudge.cn/dspythonbook/P0680/



å°†è¾“å…¥çš„æ‹¬å·åµŒå¥—å½¢å¼è½¬æ¢æˆäºŒå‰æ ‘ï¼Œç„¶åå®ç°äº†å‰åºå’Œä¸­åºéå†ã€‚

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


def parse_tree(s):
    """ è§£ææ‹¬å·åµŒå¥—æ ¼å¼çš„äºŒå‰æ ‘ """
    if s == '*':  # å¤„ç†ç©ºæ ‘
        return None
    if '(' not in s:  # åªæœ‰å•ä¸ªæ ¹èŠ‚ç‚¹
        return TreeNode(s)

    root_value = s[0]  # æ ¹èŠ‚ç‚¹å€¼
    subtrees = s[2:-1]  # å»æ‰æ ¹èŠ‚ç‚¹å’Œå¤–å±‚æ‹¬å·

    # ä½¿ç”¨æ ˆæ‰¾åˆ°é€—å·ä½ç½®
    stack = []
    comma_index = None
    for i, char in enumerate(subtrees):
        if char == '(':
            stack.append(char)
        elif char == ')':
            stack.pop()
        elif char == ',' and not stack:
            comma_index = i
            break

    left_subtree = subtrees[:comma_index] if comma_index is not None else subtrees
    right_subtree = subtrees[comma_index + 1:] if comma_index is not None else None

    root = TreeNode(root_value)
    root.left = parse_tree(left_subtree)  # è§£æå·¦å­æ ‘
    root.right = parse_tree(right_subtree) if right_subtree else None  # è§£æå³å­æ ‘
    return root


def preorder_traversal(root):
    """å‰åºéå†ï¼šæ ¹ -> å·¦ -> å³"""
    return root.value + preorder_traversal(root.left) + preorder_traversal(root.right) if root else ""


def inorder_traversal(root):
    """ä¸­åºéå†ï¼šå·¦ -> æ ¹ -> å³"""
    return inorder_traversal(root.left) + root.value + inorder_traversal(root.right) if root else ""


# è¯»å–è¾“å…¥
n = int(input().strip())  
results = []

for _ in range(n):
    tree_string = input().strip().replace(" ", "")  # å»æ‰å¯èƒ½çš„ç©ºæ ¼
    tree = parse_tree(tree_string)
    results.append(preorder_traversal(tree))
    results.append(inorder_traversal(tree))

print("\n".join(results))  # æŒ‰æ ¼å¼è¾“å‡º

```





### 2.2 æ ‘å½¢è¡¨ç¤º

<mark>Node-Based</mark> or Node-Link structure
In computer science, a general tree is typically represented using this data structure. Each node in the tree contains information and references (links) to its child nodes.

```mermaid
graph TD
    A((A)); 
    B((B)); C((C)); D((D));
    E((E)); F((F)); G((G)); H((H)); I((I)); J((J));
    K((K)); L((L)); M((M))
    A --- B; A --- C; A --- D
    B --- E; B --- F; C --- G; D --- H; D --- I; D --- J;
    E --- K; E --- L; H --- M
```

> å®ƒçš„åµŒå¥—æ‹¬å·è¡¨ç¤ºä¸ºï¼š
>
> $(A(B(E(K,L),F),C(G),D(H(M),I,J))$â€‹
>



#### ç»ƒä¹ M08581: æ‰©å±•äºŒå‰æ ‘

http://cs101.openjudge.cn/practice/08581/

ç”±äºå…ˆåºã€ä¸­åºå’Œååºåºåˆ—ä¸­çš„ä»»ä¸€ä¸ªéƒ½ä¸èƒ½å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ‰€ä»¥å¯¹äºŒå‰æ ‘åšå¦‚ä¸‹å¤„ç†ï¼Œå°†äºŒå‰æ ‘çš„ç©ºç»“ç‚¹ç”¨Â·è¡¥é½ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚æˆ‘ä»¬æŠŠè¿™æ ·å¤„ç†åçš„äºŒå‰æ ‘ç§°ä¸ºåŸäºŒå‰æ ‘çš„æ‰©å±•äºŒå‰æ ‘ï¼Œæ‰©å±•äºŒå‰æ ‘çš„å…ˆåºå’Œååºåºåˆ—èƒ½å”¯ä¸€ç¡®å®šå…¶äºŒå‰æ ‘ã€‚ ç°ç»™å‡ºæ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—ï¼Œè¦æ±‚è¾“å‡ºå…¶ä¸­åºå’Œååºåºåˆ—ã€‚

![img](http://media.openjudge.cn/images/upload/1440300244.png)

**è¾“å…¥**

æ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—ï¼ˆå…¨éƒ¨éƒ½ç”±å¤§å†™å­—æ¯æˆ–è€….ç»„æˆï¼‰

**è¾“å‡º**

ç¬¬ä¸€è¡Œï¼šä¸­åºåºåˆ—
ç¬¬äºŒè¡Œï¼šååºåºåˆ—

æ ·ä¾‹è¾“å…¥

```
ABD..EF..G..C..
```

æ ·ä¾‹è¾“å‡º

```
DBFEGAC
DFGEBCA
```



é€šè¿‡é€’å½’æ–¹æ³•è§£ææ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—ï¼Œå¹¶è¾“å‡ºå…¶ä¸­åºå’Œååºåºåˆ—ï¼š

```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def build_tree(s, index):
    # å¦‚æœå½“å‰å­—ç¬¦ä¸º'.'ï¼Œè¡¨ç¤ºç©ºç»“ç‚¹ï¼Œè¿”å›Noneï¼Œå¹¶å°†ç´¢å¼•åç§»ä¸€ä½
    if s[index] == '.':
        return None, index + 1
    # å¦åˆ™åˆ›å»ºä¸€ä¸ªç»“ç‚¹
    node = Node(s[index])
    index += 1
    # é€’å½’æ„é€ å·¦å­æ ‘
    node.left, index = build_tree(s, index)
    # é€’å½’æ„é€ å³å­æ ‘
    node.right, index = build_tree(s, index)
    return node, index

def inorder(node, res):
    if node is None:
        return
    inorder(node.left, res)
    res.append(node.val)
    inorder(node.right, res)

def postorder(node, res):
    if node is None:
        return
    postorder(node.left, res)
    postorder(node.right, res)
    res.append(node.val)

def main():
    s = input().strip()
    root, _ = build_tree(s, 0)
    
    in_res = []
    inorder(root, in_res)
    
    post_res = []
    postorder(root, post_res)
    
    print("".join(in_res))
    print("".join(post_res))

if __name__ == '__main__':
    main()
```

ä»£ç è¯´æ˜

- **build_tree å‡½æ•°**  
  é€’å½’åœ°æ ¹æ®æ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—æ„é€ äºŒå‰æ ‘ï¼š  
  - å½“é‡åˆ° `'.'` æ—¶è¡¨ç¤ºç©ºç»“ç‚¹ï¼Œç›´æ¥è¿”å› `None`ã€‚  
  - å¦åˆ™ä»¥å½“å‰å­—ç¬¦åˆ›å»ºä¸€ä¸ªç»“ç‚¹ï¼Œç„¶åé€’å½’æ„é€ å…¶å·¦å­æ ‘å’Œå³å­æ ‘ã€‚

- **inorder å’Œ postorder å‡½æ•°**  
  åˆ†åˆ«å®ç°ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰å’Œååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰ã€‚

- **main å‡½æ•°**  
  è¯»å–è¾“å…¥å­—ç¬¦ä¸²ï¼Œæ„é€ æ ‘åè®¡ç®—ä¸­åºå’Œååºéå†ç»“æœï¼Œå¹¶è¾“å‡ºã€‚  





### 2.3 æ–‡æ°å›¾

Venn diagram

Vennå›¾æ˜¯åœ¨æ‰€è°“çš„é›†åˆè®ºï¼ˆæˆ–è€…ç±»çš„ç†è®ºï¼‰æ•°å­¦åˆ†æ”¯ä¸­ï¼Œåœ¨ä¸å¤ªä¸¥æ ¼çš„æ„ä¹‰ä¸‹ç”¨ä»¥è¡¨ç¤ºé›†åˆï¼ˆæˆ–ç±»ï¼‰çš„ä¸€ç§è‰å›¾ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250324204152280.png" alt="image-20250324204152280" style="zoom:67%;" />

### 2.4 å‡¹å…¥è¡¨

Indented Tree Representation

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://raw.githubusercontent.com/GMyhf/img/main/img/20200224102939456.png)



#### ç»ƒä¹ T02775: æ–‡ä»¶ç»“æ„â€œå›¾â€

http://cs101.openjudge.cn/practice/02775/

åœ¨è®¡ç®—æœºä¸Šçœ‹åˆ°æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„é€šå¸¸å¾ˆæœ‰ç”¨ã€‚Microsoft Windowsä¸Šé¢çš„"explorer"ç¨‹åºå°±æ˜¯è¿™æ ·çš„ä¸€ä¸ªä¾‹å­ã€‚ä½†æ˜¯åœ¨æœ‰å›¾å½¢ç•Œé¢ä¹‹å‰ï¼Œæ²¡æœ‰å›¾å½¢åŒ–çš„è¡¨ç¤ºæ–¹æ³•çš„ï¼Œé‚£æ—¶å€™æœ€å¥½çš„æ–¹å¼æ˜¯æŠŠç›®å½•å’Œæ–‡ä»¶çš„ç»“æ„æ˜¾ç¤ºæˆä¸€ä¸ª"å›¾"çš„æ ·å­ï¼Œè€Œä¸”ä½¿ç”¨ç¼©æ’çš„å½¢å¼æ¥è¡¨ç¤ºç›®å½•çš„ç»“æ„ã€‚æ¯”å¦‚ï¼š



```
ROOT
|     dir1
|     file1
|     file2
|     file3
|     dir2
|     dir3
|     file1
file1
file2
```

è¿™ä¸ªå›¾è¯´æ˜ï¼šROOTç›®å½•åŒ…æ‹¬ä¸‰ä¸ªå­ç›®å½•å’Œä¸¤ä¸ªæ–‡ä»¶ã€‚ç¬¬ä¸€ä¸ªå­ç›®å½•åŒ…å«3ä¸ªæ–‡ä»¶ï¼Œç¬¬äºŒä¸ªå­ç›®å½•æ˜¯ç©ºçš„ï¼Œç¬¬ä¸‰ä¸ªå­ç›®å½•åŒ…å«ä¸€ä¸ªæ–‡ä»¶ã€‚

**è¾“å…¥**

ä½ çš„ä»»åŠ¡æ˜¯å†™ä¸€ä¸ªç¨‹åºè¯»å–ä¸€äº›æµ‹è¯•æ•°æ®ã€‚æ¯ç»„æµ‹è¯•æ•°æ®è¡¨ç¤ºä¸€ä¸ªè®¡ç®—æœºçš„æ–‡ä»¶ç»“æ„ã€‚æ¯ç»„æµ‹è¯•æ•°æ®ä»¥`*`ç»“å°¾ï¼Œè€Œæ‰€æœ‰åˆç†çš„è¾“å…¥æ•°æ®ä»¥`#`ç»“å°¾ã€‚ä¸€ç»„æµ‹è¯•æ•°æ®åŒ…æ‹¬ä¸€äº›æ–‡ä»¶å’Œç›®å½•çš„åå­—ï¼ˆè™½ç„¶åœ¨è¾“å…¥ä¸­æˆ‘ä»¬æ²¡æœ‰ç»™å‡ºï¼Œä½†æ˜¯æˆ‘ä»¬æ€»å‡è®¾ROOTç›®å½•æ˜¯æœ€å¤–å±‚çš„ç›®å½•ï¼‰ã€‚åœ¨è¾“å…¥ä¸­,ä»¥`]`è¡¨ç¤ºä¸€ä¸ªç›®å½•çš„å†…å®¹çš„ç»“æŸã€‚ç›®å½•åå­—çš„ç¬¬ä¸€ä¸ªå­—æ¯æ˜¯'d'ï¼Œæ–‡ä»¶åå­—çš„ç¬¬ä¸€ä¸ªå­—æ¯æ˜¯`f`ã€‚æ–‡ä»¶åå¯èƒ½æœ‰æ‰©å±•åä¹Ÿå¯èƒ½æ²¡æœ‰ï¼ˆæ¯”å¦‚`fmyfile.dat`å’Œ`fmyfile`ï¼‰ã€‚æ–‡ä»¶å’Œç›®å½•çš„åå­—ä¸­éƒ½ä¸åŒ…æ‹¬ç©ºæ ¼,é•¿åº¦éƒ½ä¸è¶…è¿‡30ã€‚ä¸€ä¸ªç›®å½•ä¸‹çš„å­ç›®å½•ä¸ªæ•°å’Œæ–‡ä»¶ä¸ªæ•°ä¹‹å’Œä¸è¶…è¿‡30ã€‚

**è¾“å‡º**

åœ¨æ˜¾ç¤ºä¸€ä¸ªç›®å½•ä¸­å†…å®¹çš„æ—¶å€™ï¼Œå…ˆæ˜¾ç¤ºå…¶ä¸­çš„å­ç›®å½•ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œç„¶åå†æ˜¾ç¤ºæ–‡ä»¶ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚<u>æ–‡ä»¶è¦æ±‚æŒ‰ç…§åå­—çš„å­—æ¯è¡¨çš„é¡ºåºæ˜¾ç¤º</u>ï¼ˆç›®å½•ä¸ç”¨æŒ‰ç…§åå­—çš„å­—æ¯è¡¨é¡ºåºæ˜¾ç¤ºï¼Œåªéœ€è¦æŒ‰ç…§ç›®å½•å‡ºç°çš„å…ˆåæ˜¾ç¤ºï¼‰ã€‚å¯¹æ¯ä¸€ç»„æµ‹è¯•æ•°æ®ï¼Œæˆ‘ä»¬è¦å…ˆè¾“å‡º`DATA SET x:`ï¼Œè¿™é‡Œ`x`æ˜¯æµ‹è¯•æ•°æ®çš„ç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰ã€‚åœ¨ä¸¤ç»„æµ‹è¯•æ•°æ®ä¹‹é—´è¦è¾“å‡ºä¸€ä¸ªç©ºè¡Œæ¥éš”å¼€ã€‚

ä½ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª`|`å’Œ5ä¸ªç©ºæ ¼æ¥è¡¨ç¤ºå‡ºç¼©æ’çš„å±‚æ¬¡ã€‚

æ ·ä¾‹è¾“å…¥

```
file1
file2
dir3
dir2
file1
file2
]
]
file4
dir1
]
file3
*
file2
file1
*
#
```

æ ·ä¾‹è¾“å‡º

```
DATA SET 1:
ROOT
|     dir3
|     |     dir2
|     |     file1
|     |     file2
|     dir1
file1
file2
file3
file4

DATA SET 2:
ROOT
file1
file2
```

æç¤º

ä¸€ä¸ªç›®å½•å’Œå®ƒçš„å­ç›®å½•å¤„äºä¸åŒçš„å±‚æ¬¡
ä¸€ä¸ªç›®å½•å’Œå®ƒçš„é‡Œé¢çš„æ–‡ä»¶å¤„äºåŒä¸€å±‚æ¬¡

æ¥æº

ç¿»è¯‘è‡ª Pacific Northwest 1998 çš„è¯•é¢˜



```python
# å¤å¤©æ˜ï¼Œå…ƒåŸ¹å­¦é™¢
from sys import exit

class dir:
    def __init__(self, dname):
        self.name = dname
        self.dirs = []
        self.files = []
    
    def getGraph(self):
        g = [self.name]
        for d in self.dirs:
            subg = d.getGraph()
            g.extend(["|     " + s for s in subg])
        for f in sorted(self.files):
            g.append(f)
        return g

n = 0
while True:
    n += 1
    stack = [dir("ROOT")]
    while (s := input()) != "*":
        if s == "#": exit(0)
        if s[0] == 'f':
            stack[-1].files.append(s)
        elif s[0] == 'd':
            stack.append(dir(s))
            stack[-2].dirs.append(stack[-1])
        else:
            stack.pop()
    print(f"DATA SET {n}:")
    print(*stack[0].getGraph(), sep='\n')
    print()
```





### 2.5 é‚»æ¥è¡¨è¡¨ç¤ºæ³•

é‚»æ¥è¡¨è¡¨ç¤ºæ³•ï¼ˆAdjacency List Representationï¼‰æ˜¯ä¸€ç§å¸¸è§çš„æ ‘çš„è¡¨ç¤ºæ–¹æ³•ï¼Œç‰¹åˆ«<mark>é€‚ç”¨äºè¡¨ç¤ºç¨€ç–æ ‘</mark>ï¼ˆæ ‘ä¸­èŠ‚ç‚¹çš„åº¦æ•°ç›¸å¯¹è¾ƒå°ï¼‰ã€‚

åœ¨é‚»æ¥è¡¨è¡¨ç¤ºæ³•ä¸­ï¼Œ<mark>ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ ‘çš„èŠ‚ç‚¹ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ å¯¹åº”ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œä½¿ç”¨é“¾è¡¨æˆ–æ•°ç»„ç­‰æ•°æ®ç»“æ„æ¥å­˜å‚¨å®ƒçš„å­èŠ‚ç‚¹ã€‚</mark>

ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨é‚»æ¥è¡¨è¡¨ç¤ºæ³•è¡¨ç¤ºä¸€ä¸ªæ ‘ï¼š

å‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹æ ‘çš„ç»“æ„ï¼š

```
       A
     / | \
    B  C  D
   / \    \
  E   F    G
       \
        H
```

ä½¿ç”¨é‚»æ¥è¡¨è¡¨ç¤ºæ³•ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„è¡¨ç¤ºï¼š

```
A: ['B', 'C', 'D']
B: ['E', 'F']
E: []
F: ['H']
H: []
C: []
D: ['G']
G: []
```

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç”¨ä¸€ä¸ªæ•°ç»„æ¥è¡¨ç¤ºï¼Œæ•°ç»„çš„ç´¢å¼•å¯¹åº”èŠ‚ç‚¹çš„æ ‡è¯†ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œå­˜å‚¨äº†è¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚

è¿™ç§è¡¨ç¤ºæ–¹æ³•å¯ä»¥æœ‰æ•ˆåœ°å­˜å‚¨æ ‘çš„ç»“æ„ï¼Œå¹¶ä¸”å¯ä»¥å¿«é€Ÿåœ°æŸ¥æ‰¾å’Œè®¿é—®èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []

def build_tree():
    # åˆ›å»ºæ ‘èŠ‚ç‚¹
    root = TreeNode('A')
    node_b = TreeNode('B')
    node_c = TreeNode('C')
    node_d = TreeNode('D')
    node_e = TreeNode('E')
    node_f = TreeNode('F')
    node_g = TreeNode('G')
    node_h = TreeNode('H')

    # æ„å»ºæ ‘çš„ç»“æ„
    root.children.extend([node_b, node_c, node_d])
    node_b.children.extend([node_e, node_f])
    node_d.children.append(node_g)
    node_f.children.append(node_h)

    return root

def print_tree_adjacency_list(root):
    adjacency_list = {}

    # é€’å½’æ„å»ºé‚»æ¥è¡¨
    def build_adjacency_list(node):
        adjacency_list[node.value] = [child.value for child in node.children]
        for child in node.children:
            build_adjacency_list(child)

    # æ„å»ºå¹¶æ‰“å°é‚»æ¥è¡¨
    build_adjacency_list(root)
    for node, children in adjacency_list.items():
        print(f"{node}: {children}")

# æ„å»ºæ ‘
root_node = build_tree()

# æ‰“å°é‚»æ¥è¡¨è¡¨ç¤ºçš„æ ‘
print_tree_adjacency_list(root_node)

"""
A: ['B', 'C', 'D']
B: ['E', 'F']
E: []
F: ['H']
H: []
C: []
D: ['G']
G: []
"""
```



é‚»æ¥è¡¨ï¼Œä¸é™Œç”Ÿã€‚

18182: æ‰“æ€ªå…½ï¼Œdata structures, http://cs101.openjudge.cn/practice/18182/

ç”¨å­—å…¸æ¨¡æ‹Ÿé‚»æ¥è¡¨ï¼Œå­˜å‚¨ç›¸åŒæ—¶åˆ»çš„æŠ€èƒ½ã€‚



#### ç»ƒä¹ T24729: æ‹¬å·åµŒå¥—æ ‘

http://cs101.openjudge.cn/practice/24729/

å¯ä»¥ç”¨æ‹¬å·åµŒå¥—çš„æ–¹å¼æ¥è¡¨ç¤ºä¸€æ£µæ ‘ã€‚è¡¨ç¤ºæ–¹æ³•å¦‚ä¸‹ï¼š

1) å¦‚æœä¸€æ£µæ ‘åªæœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œåˆ™è¯¥æ ‘å°±ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯è¡¨ç¤ºï¼Œä»£è¡¨å…¶æ ¹ç»“ç‚¹ã€‚
2) å¦‚æœä¸€æ£µæ ‘æœ‰å­æ ‘ï¼Œåˆ™ç”¨â€œæ ‘æ ¹(å­æ ‘1,å­æ ‘2,...,å­æ ‘n)â€çš„å½¢å¼è¡¨ç¤ºã€‚æ ‘æ ¹æ˜¯ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œå­æ ‘ä¹‹é—´ç”¨é€—å·éš”å¼€ï¼Œæ²¡æœ‰ç©ºæ ¼ã€‚å­æ ‘éƒ½æ˜¯ç”¨æ‹¬å·åµŒå¥—æ³•è¡¨ç¤ºçš„æ ‘ã€‚

ç»™å‡ºä¸€æ£µä¸è¶…è¿‡26ä¸ªç»“ç‚¹çš„æ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼ï¼Œè¯·è¾“å‡ºå…¶å‰åºéå†åºåˆ—å’Œååºéå†åºåˆ—ã€‚

è¾“å…¥æ ·ä¾‹ä»£è¡¨çš„æ ‘å¦‚ä¸‹å›¾ï¼š

<img src="http://media.openjudge.cn/images/upload/5805/1653472173.png" alt="img" style="zoom:67%;" />

**è¾“å…¥**

ä¸€è¡Œï¼Œä¸€æ£µæ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼

**è¾“å‡º**

ä¸¤è¡Œã€‚ç¬¬ä¸€è¡Œæ˜¯æ ‘çš„å‰åºéå†åºåˆ—ï¼Œç¬¬äºŒè¡Œæ˜¯æ ‘çš„ååºéå†åºåˆ—



æ ·ä¾‹è¾“å…¥

```
A(B(E),C(F,G),D(H(I)))
```

æ ·ä¾‹è¾“å‡º

```
ABECFGDHI
EBFGCIHDA
```

æ¥æºï¼šGuo Wei



ä¸»è¦æ­¥éª¤ï¼š

1. **è§£ææ‹¬å·åµŒå¥—è¡¨ç¤º**ï¼šç”¨æ ˆæ¥æ„å»ºæ ‘ç»“æ„ï¼Œæ¯æ¬¡é‡åˆ°å­—æ¯åˆ›å»ºèŠ‚ç‚¹ï¼Œé‡åˆ° `)` å¼¹å‡ºæ ˆé¡¶èŠ‚ç‚¹è¡¨ç¤ºå­æ ‘ç»“æŸã€‚
2. **å‰åºéå†**ï¼šæ ¹èŠ‚ç‚¹ -> ä¾æ¬¡éå†å­èŠ‚ç‚¹ã€‚
3. **ååºéå†**ï¼šä¾æ¬¡éå†å­èŠ‚ç‚¹ -> æ ¹èŠ‚ç‚¹ã€‚

ä¸‹é¢ä¸¤ä¸ªä»£ç ã€‚å…ˆç»™å‡ºç”¨ç±»è¡¨ç¤ºnode

```python
class TreeNode:
    def __init__(self, value): #ç±»ä¼¼å­—å…¸
        self.value = value
        self.children = []

def parse_tree(s):
    stack = []
    node = None
    for char in s:
        if char.isalpha():  # å¦‚æœæ˜¯å­—æ¯ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹
            node = TreeNode(char)
            if stack:  # å¦‚æœæ ˆä¸ä¸ºç©ºï¼ŒæŠŠèŠ‚ç‚¹ä½œä¸ºå­èŠ‚ç‚¹åŠ å…¥åˆ°æ ˆé¡¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ—è¡¨ä¸­
                stack[-1].children.append(node)
        elif char == '(':  # é‡åˆ°å·¦æ‹¬å·ï¼Œå½“å‰èŠ‚ç‚¹å¯èƒ½ä¼šæœ‰å­èŠ‚ç‚¹
            if node:
                stack.append(node)  # æŠŠå½“å‰èŠ‚ç‚¹æ¨å…¥æ ˆä¸­
                node = None
        elif char == ')':  # é‡åˆ°å³æ‹¬å·ï¼Œå­èŠ‚ç‚¹åˆ—è¡¨ç»“æŸ
            if stack:
                node = stack.pop()  # å¼¹å‡ºå½“å‰èŠ‚ç‚¹
    return node  # æ ¹èŠ‚ç‚¹


def preorder(node):
    output = [node.value]
    for child in node.children:
        output.extend(preorder(child))
    return ''.join(output)

def postorder(node):
    output = []
    for child in node.children:
        output.extend(postorder(child))
    output.append(node.value)
    return ''.join(output)

# ä¸»ç¨‹åº
def main():
    s = input().strip()
    s = ''.join(s.split())  # å»æ‰æ‰€æœ‰ç©ºç™½å­—ç¬¦
    root = parse_tree(s)  # è§£ææ•´æ£µæ ‘
    if root:
        print(preorder(root))  # è¾“å‡ºå‰åºéå†åºåˆ—
        print(postorder(root))  # è¾“å‡ºååºéå†åºåˆ—
    else:
        print("input tree string error!")

if __name__ == "__main__":
    main()
```



ç”¨å­—å…¸è¡¨ç¤ºnode

```python
def parse_tree(s):
    stack = []
    node = None
    for char in s:
        if char.isalpha():  # å¦‚æœæ˜¯å­—æ¯ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹
            node = {'value': char, 'children': []}
            if stack:  # å¦‚æœæ ˆä¸ä¸ºç©ºï¼ŒæŠŠèŠ‚ç‚¹ä½œä¸ºå­èŠ‚ç‚¹åŠ å…¥åˆ°æ ˆé¡¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ—è¡¨ä¸­
                stack[-1]['children'].append(node)
        elif char == '(':  # é‡åˆ°å·¦æ‹¬å·ï¼Œå½“å‰èŠ‚ç‚¹å¯èƒ½ä¼šæœ‰å­èŠ‚ç‚¹
            if node:
                stack.append(node)  # æŠŠå½“å‰èŠ‚ç‚¹æ¨å…¥æ ˆä¸­
                node = None
        elif char == ')':  # é‡åˆ°å³æ‹¬å·ï¼Œå­èŠ‚ç‚¹åˆ—è¡¨ç»“æŸ
            if stack:
                node = stack.pop()  # å¼¹å‡ºå½“å‰èŠ‚ç‚¹
    return node  # æ ¹èŠ‚ç‚¹


def preorder(node):
    output = [node['value']]
    for child in node['children']:
        output.extend(preorder(child))
    return ''.join(output)

def postorder(node):
    output = []
    for child in node['children']:
        output.extend(postorder(child))
    output.append(node['value'])
    return ''.join(output)

# ä¸»ç¨‹åº
def main():
    s = input().strip()
    s = ''.join(s.split())  # å»æ‰æ‰€æœ‰ç©ºç™½å­—ç¬¦
    root = parse_tree(s)  # è§£ææ•´æ£µæ ‘
    if root:
        print(preorder(root))  # è¾“å‡ºå‰åºéå†åºåˆ—
        print(postorder(root))  # è¾“å‡ºååºéå†åºåˆ—
    else:
        print("input tree string error!")

if __name__ == "__main__":
    main()
```



#### ç»ƒä¹ M27928:éå†æ ‘

http://cs101.openjudge.cn/practice/27928/

è¯·ä½ å¯¹è¾“å…¥çš„æ ‘åšéå†ã€‚éå†çš„è§„åˆ™æ˜¯ï¼šéå†åˆ°æ¯ä¸ªèŠ‚ç‚¹æ—¶ï¼ŒæŒ‰ç…§è¯¥èŠ‚ç‚¹å’Œæ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼ä»å°åˆ°å¤§è¿›è¡Œéå†ï¼Œä¾‹å¦‚ï¼š

```
        7
    /   |   \
  10    3     6
```

å¯¹äºè¿™ä¸ªæ ‘ï¼Œä½ åº”è¯¥å…ˆéå†å€¼ä¸º3çš„å­èŠ‚ç‚¹ï¼Œç„¶åæ˜¯å€¼ä¸º6çš„å­èŠ‚ç‚¹ï¼Œç„¶åæ˜¯çˆ¶èŠ‚ç‚¹7ï¼Œæœ€åæ˜¯å€¼ä¸º10çš„å­èŠ‚ç‚¹ã€‚

æœ¬é¢˜ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ä¸ºäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°ï¼Œæœ€å¤§ä¸è¶…è¿‡9999999ã€‚

è¾“å…¥

ç¬¬ä¸€è¡Œï¼šèŠ‚ç‚¹ä¸ªæ•°n (n<500)

æ¥ä¸‹æ¥çš„nè¡Œï¼šç¬¬ä¸€ä¸ªæ•°æ˜¯æ­¤èŠ‚ç‚¹çš„å€¼ï¼Œä¹‹åçš„æ•°åˆ†åˆ«è¡¨ç¤ºå®ƒçš„æ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼ã€‚æ¯ä¸ªæ•°ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œè¯¥è¡Œä¾¿åªæœ‰ä¸€ä¸ªæ•°ã€‚

è¾“å‡º

è¾“å‡ºéå†ç»“æœï¼Œä¸€è¡Œä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚

æ ·ä¾‹è¾“å…¥

```
sample1 input:
4
7 10 3 6
10
6
3

sample1 output:
3
6
7
10
```

æ ·ä¾‹è¾“å‡º

```
sample2 input:
6
10 3 1
7
9 2 
2 10
3 7
1

sample2 output:
2
1
3
7
10
9
```

æ¥æºï¼š2024spring zht



æ€»ä½“æ€è·¯åˆ†ä¸ºä¸‰æ­¥ï¼š1.é€šè¿‡å­—å…¸å»ºç«‹è¾“å…¥æ•°æ®çš„çˆ¶å­å…³ç³»ï¼›2.æ‰¾åˆ°æ ‘çš„æ ¹ï¼ˆè¿™é‡Œæˆ‘å°†çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹åˆ†åˆ«ç”¨ä¸¤ä¸ªåˆ—è¡¨è®°å½•ï¼Œæœ€åä½¿ç”¨é›†åˆå‡æ³•ï¼‰ï¼›3.é€šè¿‡é€’å½’å®ç°è¦æ±‚çš„ä»å°åˆ°å¤§éå†ã€‚



```python
from collections import defaultdict
import sys
sys.setrecursionlimit(10000)

def main():
    n = int(sys.stdin.readline())
    tree = defaultdict(list)
    all_nodes = set()
    child_nodes = set()
    
    for _ in range(n):
        parts = list(map(int, sys.stdin.readline().split()))
        parent, *children = parts
        tree[parent].extend(children)
        all_nodes.add(parent)
        all_nodes.update(children)
        child_nodes.update(children)
    
    # æ ¹èŠ‚ç‚¹ = å‡ºç°åœ¨ all_nodes ä½†æ²¡å‡ºç°åœ¨ child_nodes çš„é‚£ä¸ª
    root = (all_nodes - child_nodes).pop()
    
    def traverse(u):
        # æŠŠ u è‡ªå·±å’Œå®ƒçš„æ‰€æœ‰ç›´æ¥å­©å­æ”¾ä¸€èµ·æ’åº
        group = tree[u] + [u]
        group.sort()
        for x in group:
            if x == u:
                print(u)
            else:
                traverse(x)
    
    traverse(root)

if __name__ == "__main__":
    main()

```





#### Height of a generic tree from parent array

https://www.geeksforgeeks.org/height-generic-tree-parent-array/

Last Updated : 01 Nov, 2024

ç»™å®šä¸€æ£µ**å¤§å°ä¸º n**çš„æ ‘ï¼Œä»¥æ•°ç»„ `parent[0..n-1]` çš„å½¢å¼è¡¨ç¤ºï¼Œå…¶ä¸­ `parent[]` ä¸­çš„æ¯ä¸ªç´¢å¼• `i` ä»£è¡¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œ `i` å¤„çš„å€¼è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„**ç›´æ¥çˆ¶èŠ‚ç‚¹**ã€‚å¯¹äºæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º **-1**ã€‚ <mark>æ ¹æ®ç»™å®šçš„çˆ¶èŠ‚ç‚¹é“¾æ¥ï¼Œæ±‚è¿™æ£µé€šç”¨æ ‘çš„**é«˜åº¦**ã€‚</mark>

> Given a tree of **size n** as array `parent[0..n-1]` where every index `i` in the `parent[]` represents a node and the value at `i` represents the **immediate parent** of that node. For root, the node value will be **-1**. <mark>Find the **height** of the generic tree given the parent links.</mark>
>

**Examples:** 

> ```
> Input : parent[] = [-1, 0, 0, 0, 3, 1, 1, 2]
> Output : 2
> ```
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/Tree7-300x151.jpg" alt="Height of a generic tree from parent array 1" style="zoom:67%;" />
>
> ```
> Input  : parent[] = [-1, 0, 1, 2, 3]
> Output : 4
> ```
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/Tree-_5.jpg" alt="Height of a generic tree from parent array 2" style="zoom: 67%;" />
>
> 
>
> 
>
> Here, a **generic tree** is sometimes also called an N-ary tree or N-way tree where N denotes the maximum number of child a node can have. In this problem, the array represents n number of nodes in the tree.



æœ´ç´ çš„æ–¹æ³•æ˜¯ä»**èŠ‚ç‚¹**å‘ä¸Š**éå†**æ ‘ï¼Œç›´åˆ°åˆ°è¾¾å€¼ä¸º **-1** çš„**æ ¹èŠ‚ç‚¹**ã€‚åœ¨éå†æ¯ä¸ªèŠ‚ç‚¹æ—¶ï¼Œè®°å½•**æœ€å¤§è·¯å¾„é•¿åº¦**ã€‚è¯¥è§£å†³æ–¹æ¡ˆçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚

> The naive approach is to **traverse** up the tree from the **node** till the **root node** is reached with node **value -1**. While Traversing for each node stores **maximum path length**. The Time Complexity of this solution is $O(n^2)$.
>



**[Expected Approach â€“ 1] Using BFS â€“ O(n) Time and O(n) Space**

> Build **graph** for **N-ary Tree in O(n)** time and apply **BFS** on the stored graph in **O(n)** time and while doing BFS store **maximum reached level.** This solution does **two iterations** to find the **height** of N-ary tree.

**Implementation:**

```python
# find height of N-ary tree in O(n)
from collections import deque

MAX = 1001
adj = [[] for i in range(MAX)] # Adjacency list to store N-ary tree

def build_tree(arr, n): # Build tree in tree in O(n)
    root_index = 0

    for i in range(n):
        if (arr[i] == -1): # if root node, store index
            root_index = i
        else:
            adj[i].append(arr[i])
            adj[arr[i]].append(i)

    return root_index


def BFS(start):
    vis = {} # map is used as visited array

    q = deque()
    max_level_reached = 0

    q.append([start, 0]) # height of root node is zero

    # p[0] denotes node in adjacency list
    # p[1] denotes level of p[0]
    p = []

    while (len(q) > 0):
        p = q.popleft()
        vis[p[0]] = 1

        max_level_reached = max(max_level_reached, p[1])

        for i in range(len(adj[p[0]])):
            if (adj[p[0]][i] not in vis):
                q.append([adj[p[0]][i], p[1] + 1]) # adding 1 to pre_level

    return max_level_reached


# Driver code
if __name__ == '__main__':
    parent = [-1, 0, 1, 2, 3] # node 0 to node n-1
    n = len(parent) # Number of nodes in tree

    root_index = build_tree(parent, n)
    ma = BFS(root_index)
    print("Height of N-ary Tree =", ma)

# output: Height of N-ary Tree = 4

```

**Time Complexity:** O(n) which converges to O(n) for very large n.
**Auxiliary Space:** O(n), we are using an <mark>adjacency list</mark> to store the tree in memory. The size of the adjacency list is proportional to the number of nodes in the tree, so the space complexity of the algorithm is O(n).



**[Expected Approach â€“ 2\] Without using map â€“ O(n) Time and O(n) Space**

æˆ‘ä»¬å¯ä»¥åœ¨**ä¸€æ¬¡è¿­ä»£**ä¸­æ‰¾åˆ°**Nå‰æ ‘**çš„**é«˜åº¦**ã€‚æˆ‘ä»¬ä»¥è¿­ä»£æ–¹å¼è®¿é—®ä»**0 åˆ° n-1**çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶é€’å½’åœ°æ ‡è®°é‚£äº›å°šæœªè¢«è®¿é—®è¿‡çš„**ç¥–å…ˆèŠ‚ç‚¹**ï¼Œç›´åˆ°åˆ°è¾¾ä¸€ä¸ªå·²è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œæˆ–è€…åˆ°è¾¾**æ ¹èŠ‚ç‚¹**ã€‚<mark>å¦‚æœåœ¨é€šè¿‡çˆ¶èŠ‚ç‚¹é“¾æ¥å‘ä¸Šéå†æ ‘æ—¶é‡åˆ°ä¸€ä¸ªå·²è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼šä½¿ç”¨å®ƒçš„**é«˜åº¦**ï¼Œå¹¶åœæ­¢è¿›ä¸€æ­¥çš„é€’å½’ã€‚</mark>

> We can find the **height** of the **N-ary Tree** in only one **iteration**. We visit nodes from **0 to n-1** iteratively and mark the unvisited **ancestors** recursively if they are not visited before till we reach a node which is visited, or we reach the **root** node. If we reach the visited node while traversing up the tree using parent links, then we use its **height** and will not go further in recursion.

```python
# find height of N-ary tree in O(n) (Efficient Approach)

# Recur For Ancestors of node and store height of node at last
def fillHeight(p, node, visited, height):
    if (p[node] == -1):  # If root node
        visited[node] = 1  # mark root node as visited
        return 0

    if (visited[node]):
        return height[node]

    visited[node] = 1

    # recur for the parent node
    height[node] = 1 + fillHeight(p, p[node], visited, height)

    # return calculated height for node
    return height[node]


def findHeight(parent):
    n = len(parent)
    maxHeight = 0
    visited = [0] * n
    height = [0] * n

    for i in range(n):
        if (not visited[i]):
            height[i] = fillHeight(parent, i, visited, height)

        maxHeight = max(maxHeight, height[i])

    return maxHeight


if __name__ == '__main__':
    parent = [-1, 0, 0, 0, 3, 1, 1, 2]
    n = len(parent)

    print(findHeight(parent))

# 2

```

**Time Complexity:** O(n)
**Auxiliary Space**: O(n), this is because we need to store the visited and height arrays which are of size n.



#### General Tree Level Order Traversalå±‚åºéå†

https://www.geeksforgeeks.org/generic-tree-level-order-traversal/

Last Updated : 14 Mar, 2023

<mark>æ ‘çš„éå†ï¼Œé™¤äº†å‰åºã€ä¸­åºã€ååºï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯å±‚åºéå†ï¼Œå°±æ˜¯ä½¿ç”¨é˜Ÿåˆ—çš„bfsæ–¹å¼ã€‚</mark>

Given a generic tree, perform a Level order traversal and print all of its nodes

**Examples:** 

```
Input :            10
             /   /    \   \
            2  34    56   100
           / \        |   / | \
          77  88      1   7  8  9

Output : 10
         2 34 56 100
         77 88 1 7 8 9

Input :             1
             /   /    \   \
            2  3      4    5
           / \        |  /  | \
          6   7       8 9  10  11
Output : 1
         2 3 4 5
         6 7 8 9 10 11
```

The approach to this problem is similar to [Level Order traversal in a binary tree](https://www.geeksforgeeks.org/level-order-tree-traversal/). We Start with pushing root node in a queue and for each node we pop it, print it and push all its child in the queue.

In case of a generic tree we store child nodes in a vector. Thus we put all elements of the vector in the queue. 

> å®ç°ä»£ç ï¼Œæˆ‘åšäº†éƒ¨åˆ†è°ƒæ•´ï¼Œä¸»è¦æ˜¯ç”¨deque

```python
# do level order traversal of a generic tree
from collections import deque

# Represents a node of an n-ary tree
class Node:
    def __init__(self, key):
        self.key = key
        self.children = []  


def create_node(key):
    """Helper function to create a new node."""
    return Node(key)


def level_order_traversal(root):
    """
    Perform level order traversal (BFS) of a generic n-ary tree.
    Prints nodes level by level.
    """
    if root is None:
        return

    queue = deque([root])  # Initialize the queue with the root node

    while queue:
        level_size = len(queue)  # Number of nodes at the current level

        # Process all nodes in the current level
        for _ in range(level_size):
            current_node = queue.popleft()  # Dequeue the front node
            print(current_node.key, end=' ')  # Print the node's key

            # Enqueue all children of the current node
            for child in current_node.children:
                queue.append(child)

        print()  # Separate levels with a newline


# Driver program
if __name__ == '__main__':
    '''
    Create the following n-ary tree:
               10
            / / \ \
           2 34 56 100
         / \      | / | \
        77 88     1 7 8 9
    '''
    root = create_node(10)
    root.children.append(create_node(2))
    root.children.append(create_node(34))
    root.children.append(create_node(56))
    root.children.append(create_node(100))
    
    root.children[0].children.append(create_node(77))
    root.children[0].children.append(create_node(88))
    
    root.children[2].children.append(create_node(1))
    
    root.children[3].children.append(create_node(7))
    root.children[3].children.append(create_node(8))
    root.children[3].children.append(create_node(9))

    print("Level order traversal of the tree:")
    level_order_traversal(root)

"""
Level order traversal Before Mirroring
10 
2 34 56 100 
77 88 1 7 8 9 
"""

```

Time Complexity: O(n) where n is the number of nodes in the n-ary tree.
Auxiliary Space: O(n)





# äºŒã€ğŸŒ²çš„åŸºæœ¬æ€§è´¨ã€AST & Huffman

## 3 æ ‘çš„åŸºæœ¬æ€§è´¨

### 3.1 $ m $-å‰æ ‘çš„æ€§è´¨

1. **<mark>æ€»ç»“ç‚¹æ•°</mark>**ï¼šè®¾æ ‘ä¸­æ€»çš„ç»“ç‚¹æ•°ä¸º $ N $ï¼Œåˆ™ï¼š
   $$
   N = N_0 + N_1 + N_2 + \dots + N_m
   $$
   å…¶ä¸­ $ N_0 $ è¡¨ç¤ºåº¦æ•°ä¸º 0 çš„ç»“ç‚¹æ•°ï¼ˆå³å¶ç»“ç‚¹ï¼‰ï¼Œ$ N_1, N_2, \dots, N_m $ åˆ†åˆ«è¡¨ç¤ºåº¦æ•°ä¸º 1, 2, ..., $ m $ çš„ç»“ç‚¹æ•°ã€‚

2. **<mark>æ€»åˆ†æ”¯æ•°</mark>**ï¼šåœ¨æ ‘ä¸­ï¼Œæ¯ä¸ªåº¦æ•°ä¸º $ k $ çš„ç»“ç‚¹è´¡çŒ®äº† $ k $ æ¡åˆ†æ”¯ã€‚å› æ­¤ï¼Œæ ‘ä¸­çš„æ€»åˆ†æ”¯æ•°å¯ä»¥è¡¨ç¤ºä¸ºï¼š
   $$
   \text{æ€»åˆ†æ”¯æ•°} = 1 \cdot N_1 + 2 \cdot N_2 + \dots + m \cdot N_m
   $$

3. **æ ‘çš„æ€»åˆ†æ”¯æ•°ä¸æ€»ç»“ç‚¹æ•°çš„å…³ç³»**ï¼šå¯¹äºä¸€æ£µæ ‘ï¼Œæ€»åˆ†æ”¯æ•°ç­‰äºæ€»ç»“ç‚¹æ•°å‡å» 1ï¼ˆå› ä¸ºé™¤äº†æ ¹ç»“ç‚¹å¤–ï¼Œæ¯ä¸ªç»“ç‚¹éƒ½ç”±ä¸€æ¡åˆ†æ”¯è¿æ¥åˆ°å…¶çˆ¶ç»“ç‚¹ï¼‰ã€‚å› æ­¤ï¼š
   $$
   \text{æ€»åˆ†æ”¯æ•°} = N - 1
   $$

> å°†ä»¥ä¸Šå…³ç³»ç»“åˆèµ·æ¥ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å…³äº $ N_0 $ çš„æ–¹ç¨‹ã€‚



<mark>å¯¹ä»»ä½•ä¸€æ£µéç©ºäºŒå‰æ ‘ï¼Œå¦‚æœå¶èŠ‚ç‚¹æ•° $n_0$ï¼Œåº¦ä¸º2çš„éå¶èŠ‚ç‚¹æ•° $n_2$ï¼Œåˆ™ï¼š</mark>

<mark>$n_0 = n_2 + 1$</mark>

> åœ¨ä¸€æ£µäºŒå‰æ ‘ä¸­ï¼Œé™¤äº†åº¦ä¸º0çš„å¶å­èŠ‚ç‚¹ï¼Œå°±æ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹å’Œä¸º2çš„èŠ‚ç‚¹ï¼Œåˆ™æ ‘çš„æ€»èŠ‚ç‚¹æ•°ä¸ºï¼š
>
> $N = n_0 + n_1 + n_2$
>
> åœ¨äºŒå‰æ ‘ä¸­èŠ‚ç‚¹æ€»æ•°ä¸º $N$ å’Œè¾¹æ•°ä¹‹é—´çš„å…³ç³»æ˜¯ï¼š<mark>è¾¹æ•° = $N - 1$</mark>ï¼Œæ‰€ä»¥æœ‰ï¼š
>
> $n_0 + n_1 + n_2 - 1 = 2n_2 + n_1$ 
>
> æœ€åå¾—åˆ°ï¼š$n_0 = n_2 + 1$



#### ç¬”è¯•å¡«ç©º@20240618

è®¾ä¸€æ£µmå‰æ ‘ä¸­æœ‰$N_1$ä¸ªåº¦æ•°ä¸º1çš„ç»“ç‚¹ï¼ˆåº¦æ•°è¡¨ç¤ºå­ç»“ç‚¹ä¸ªæ•°ï¼‰ï¼Œ$N_2$ä¸ªåº¦æ•°ä¸º2çš„ç»“ç‚¹ï¼Œâ€¦â€¦ï¼Œ$N_m$ä¸ªåº¦æ•°ä¸ºmçš„ç»“ç‚¹ï¼Œåˆ™è¯¥må‰æ ‘ä¸­å…±æœ‰$\underline{\hspace{4cm}}$ä¸ªç»ˆç«¯ç»“ç‚¹ï¼ˆå³å¶ç»“ç‚¹ï¼‰ã€‚<mark>$ 1 + \sum_{i=2}^{m} (i-1) N_i $</mark>

> ä»æ ‘çš„æ€»ç»“ç‚¹æ•°å’Œæ€»åˆ†æ”¯æ•°ä¸¤æ¡æ€§è´¨å‡ºå‘ï¼š
>
> 1. æ€»åˆ†æ”¯æ•°çš„ä¸¤ç§è¡¨è¾¾å¼ç›¸ç­‰ï¼š
>    $$
>    1 \cdot N_1 + 2 \cdot N_2 + \dots + m \cdot N_m = N - 1
>    $$
>
> 2. å°† $ N = N_0 + N_1 + N_2 + \dots + N_m $ ä»£å…¥ä¸Šå¼ï¼š
>    $$
>    1 \cdot N_1 + 2 \cdot N_2 + \dots + m \cdot N_m = (N_0 + N_1 + N_2 + \dots + N_m) - 1
>    $$
>
> 3. åŒ–ç®€åå¾—åˆ°ï¼š
>    $$
>    N_0 = 1 + (0 \cdot N_0) + (1 \cdot N_1) + (2 \cdot N_2) + \dots + (m \cdot N_m) - (N_1 + N_2 + \dots + N_m)
>    $$
>
> 4. åˆå¹¶åŒç±»é¡¹ï¼š
>    $$
>    N_0 = 1 + \sum_{k=1}^m (k - 1) N_k
>    $$
>
> ---
>
> **æœ€ç»ˆå…¬å¼**
>
> ä¸€æ£µ $ m $-å‰æ ‘ä¸­ï¼Œå¶ç»“ç‚¹çš„æ•°é‡ $ N_0 $ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
> $$
> N_0 = 1 + \sum_{k=1}^m (k - 1) N_k
> $$
>
> å…¶ä¸­ï¼š
>
> - $ N_k $ æ˜¯åº¦æ•°ä¸º $ k $ çš„ç»“ç‚¹æ•°ï¼›
> - $ k - 1 $ è¡¨ç¤ºæ¯ä¸ªåº¦æ•°ä¸º $ k $ çš„ç»“ç‚¹å¯¹å¶ç»“ç‚¹æ•°é‡çš„è´¡çŒ®ã€‚



#### ç¬”è¯•å¡«ç©º@20240618

è®¾æ£®æ—Fä¸­æœ‰4æ£µæ ‘ï¼Œç¬¬1ã€2ã€3ã€4æ£µæ ‘çš„ç»“ç‚¹ä¸ªæ•°åˆ†åˆ«ä¸º10ã€9ã€11ã€7ï¼Œå½“æŠŠæ£®æ—Fè½¬æ¢æˆä¸€æ£µäºŒå‰æ ‘åï¼Œå…¶æ ¹ç»“ç‚¹çš„å³å­æ ‘ä¸­æœ‰$\underline{\hspace{4cm}}$ä¸ªç»“ç‚¹ã€‚<mark>27</mark>

> 
>
> **æ£®æ—è½¬æ¢ä¸ºäºŒå‰æ ‘çš„è§„åˆ™**
>
> 1. **ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹**ï¼šæ£®æ—ä¸­ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºäºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚
> 2. **å·¦å­æ ‘**ï¼šæ¯æ£µæ ‘çš„æ ¹ç»“ç‚¹çš„å·¦å­æ ‘æ˜¯å…¶åœ¨åŸæ ‘ä¸­çš„ç¬¬ä¸€ä¸ªå­æ ‘ã€‚
> 3. **å³å­æ ‘**ï¼šæ¯æ£µæ ‘çš„æ ¹ç»“ç‚¹çš„å³å­æ ‘æ˜¯æ£®æ—ä¸­ä¸‹ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹ã€‚
>
> æ¢å¥è¯è¯´ï¼š
>
> - ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºäºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚
> - ç¬¬ä¸€æ£µæ ‘çš„å­æ ‘æ„æˆäºŒå‰æ ‘æ ¹ç»“ç‚¹çš„å·¦å­æ ‘ã€‚
> - ç¬¬äºŒæ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬ä¸€æ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
> - ç¬¬ä¸‰æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬äºŒæ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ï¼Œä¾æ­¤ç±»æ¨ã€‚
>
> ---
>
> **åˆ†æé¢˜ç›®**
>
> æ£®æ— $ F $ ä¸­æœ‰ 4 æ£µæ ‘ï¼Œåˆ†åˆ«åŒ…å« 10ã€9ã€11ã€7 ä¸ªç»“ç‚¹ã€‚æŒ‰ç…§ä¸Šè¿°è§„åˆ™ï¼š
>
> - ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºäºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚
> - ç¬¬äºŒæ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬ä¸€æ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
> - ç¬¬ä¸‰æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬äºŒæ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
> - ç¬¬å››æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬ä¸‰æ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
>
> å› æ­¤ï¼ŒäºŒå‰æ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘åŒ…å«çš„æ˜¯**ç¬¬äºŒã€ç¬¬ä¸‰å’Œç¬¬å››æ£µæ ‘çš„æ‰€æœ‰ç»“ç‚¹**ã€‚



### 3.2 äºŒå‰æ ‘çš„æ€§è´¨

> 1. **æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹**ï¼š
>
> äºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ†åˆ«æ˜¯â€œå·¦å­èŠ‚ç‚¹â€å’Œâ€œå³å­èŠ‚ç‚¹â€ã€‚
>
> 2. **äºŒå‰æ ‘çš„é«˜åº¦ä¸æ·±åº¦**ï¼š
>
> - **æ ‘çš„é«˜åº¦**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„çš„é•¿åº¦ï¼ˆå³ç»è¿‡çš„è¾¹çš„æ•°é‡ï¼‰ã€‚ç©ºæ ‘çš„é«˜åº¦ä¸º-1ï¼Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ—¶æ ‘çš„é«˜åº¦ä¸º0ã€‚
> - **èŠ‚ç‚¹çš„æ·±åº¦**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ï¼ˆå³ç»è¿‡çš„è¾¹çš„æ•°é‡ï¼‰ã€‚æ ¹èŠ‚ç‚¹çš„æ·±åº¦ä¸º0ï¼Œå…¶ä»–èŠ‚ç‚¹çš„æ·±åº¦æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„æ·±åº¦åŠ 1ã€‚
>
> 3. **äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°**ï¼š
>
> - å¯¹äºä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ•°ç›®ä¸æ ‘çš„é«˜åº¦hæœ‰å…³ç³»ï¼šèŠ‚ç‚¹æ•° `n <= 2^(h+1) - 1`ã€‚
> - å¯¹äºä¸€èˆ¬äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ•°ç›®æ˜¯æœ‰é™çš„ï¼Œå¯ä»¥é€šè¿‡éå†è®¡ç®—ã€‚
>
> 4. **æ»¡äºŒå‰æ ‘**ï¼š
>
> - æ»¡äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼ˆå³æ¯ä¸ªéå¶å­èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼‰ã€‚å‡è®¾æ ‘çš„é«˜åº¦ä¸ºhï¼Œåˆ™æ»¡äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ä¸º `2^(h+1) - 1`ã€‚
>
> 5. **å®Œå…¨äºŒå‰æ ‘**ï¼š
>
> - å®Œå…¨äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½è¢«å®Œå…¨å¡«æ»¡ï¼Œä¸”æœ€åº•å±‚çš„èŠ‚ç‚¹é›†ä¸­åœ¨å·¦è¾¹ã€‚å¦‚æœä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘æœ‰nä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå®ƒçš„é«˜åº¦ä¸º `log2(n)`ï¼ˆå‘ä¸‹å–æ•´ï¼‰ã€‚
>
> 6. **å¶å­èŠ‚ç‚¹å’Œéå¶å­èŠ‚ç‚¹**ï¼š
>
> - **å¶å­èŠ‚ç‚¹**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
> - **éå¶å­èŠ‚ç‚¹**ï¼šæœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> 7. **äºŒå‰æ ‘çš„éå†æ–¹å¼**ï¼š
>
> - **å‰åºéå†**ï¼ˆPre-orderï¼‰ï¼šæ ¹èŠ‚ç‚¹ -> å·¦å­æ ‘ -> å³å­æ ‘
> - **ä¸­åºéå†**ï¼ˆIn-orderï¼‰ï¼šå·¦å­æ ‘ -> æ ¹èŠ‚ç‚¹ -> å³å­æ ‘
> - **ååºéå†**ï¼ˆPost-orderï¼‰ï¼šå·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹èŠ‚ç‚¹
> - **å±‚åºéå†**ï¼ˆLevel-orderï¼‰ï¼šä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³é€å±‚è®¿é—®èŠ‚ç‚¹ã€‚
>
> 8. **äºŒå‰æ ‘çš„å¹³è¡¡æ€§**ï¼š
>
> - å¦‚æœä¸€ä¸ªäºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼å¤§äº1ï¼Œé‚£ä¹ˆè¿™ä¸ªäºŒå‰æ ‘å°±æ˜¯**ä¸å¹³è¡¡çš„**ã€‚å¦‚æœä¸€ä¸ªäºŒå‰æ ‘åœ¨ä»»ä½•æ—¶åˆ»éƒ½æ»¡è¶³å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡1ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯**å¹³è¡¡äºŒå‰æ ‘**ã€‚
>
> è¿™äº›æ€§è´¨æ˜¯ç†è§£äºŒå‰æ ‘ç»“æ„çš„åŸºç¡€ï¼Œæœ‰åŠ©äºè®¾è®¡å’Œä¼˜åŒ–åŸºäºäºŒå‰æ ‘çš„ç®—æ³•ï¼Œæ¯”å¦‚äºŒå‰æŸ¥æ‰¾æ ‘ã€å¹³è¡¡æ ‘ç­‰ã€‚



#### ç¬”è¯•é€‰æ‹©@20240618

Q. å®šä¹‰ä¸€æ£µæ²¡æœ‰1åº¦ç»“ç‚¹çš„äºŒå‰æ ‘ä¸ºæ»¡äºŒå‰æ ‘ã€‚å¯¹äºä¸€æ£µåŒ…å«kä¸ªç»“ç‚¹çš„æ»¡äºŒå‰æ ‘ï¼Œå…¶å¶å­ç»“ç‚¹çš„ä¸ªæ•°ä¸ºï¼ˆ <mark>C</mark>  ï¼‰ã€‚
A.   âŒŠk/2âŒ‹   B. âŒŠk/2âŒ‹-1  C.âŒŠk/2âŒ‹+1   D.ä»¥ä¸Šä¸‰ä¸ªéƒ½æœ‰å¯èƒ½



#### ç¬”è¯•é€‰æ‹©@20230620

Q. å®šä¹‰äºŒå‰æ ‘ä¸­ä¸€ä¸ªç»“ç‚¹çš„åº¦æ•°ä¸ºå…¶å­ç»“ç‚¹çš„ä¸ªæ•°ã€‚ç°æœ‰ä¸€æ£µç»“ç‚¹æ€»æ•°ä¸º 101 çš„äºŒå‰æ ‘ï¼Œå…¶ä¸­åº¦æ•°ä¸º 1 çš„ç»“ç‚¹æ•°æœ‰ 30 ä¸ªï¼Œåˆ™åº¦æ•°ä¸º 0 ç»“ç‚¹æœ‰ _ _ _ _ ä¸ªã€‚

> æ¨å¯¼è¿‡ç¨‹
>
> 1. æ ¹æ®æ€»ç»“ç‚¹æ•°å…¬å¼ï¼š
>    $N = N_0 + N_1 + N_2$
>    å°†å·²çŸ¥å€¼ä»£å…¥ï¼š
>    $101 = N_0 + 30 + N_2$
>    åŒ–ç®€å¾—ï¼š
>    $$
>    N_0 + N_2 = 71 \tag{1}
>    $$
>
> 2. æ ¹æ®æ€»åˆ†æ”¯æ•°å…¬å¼ï¼š
>    $N_1 + 2N_2 = N - 1$
>    å°†å·²çŸ¥å€¼ä»£å…¥ï¼š
>    $30 + 2N_2 = 101 - 1$
>    åŒ–ç®€å¾—ï¼š
>    $$
>    2N_2 = 70 \quad \Rightarrow \quad N_2 = 35 \tag{2}
>    $$
>
> 3. å°† $ N_2 = 35 $ ä»£å…¥ (1) å¼ï¼š
>    $N_0 + 35 = 71$
>    åŒ–ç®€å¾—ï¼š
>    $N_0 = 36$
>
> <mark>36</mark>



#### ç¬”è¯•é€‰æ‹©@20230620

Q. å®šä¹‰å®Œå…¨äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹æ‰€åœ¨å±‚ä¸ºç¬¬ä¸€å±‚ã€‚å¦‚æœä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘çš„ç¬¬å…­å±‚æœ‰ 23 ä¸ªå¶ç»“ç‚¹ï¼Œåˆ™å®ƒçš„æ€»ç»“ç‚¹æ•°å¯èƒ½ä¸º _ _ _ _ ï¼ˆè¯·å¡«å†™æ‰€æœ‰ 3 ä¸ªå¯èƒ½çš„ç»“ç‚¹æ•°ï¼Œå†™å¯¹ 1 ä¸ªå¾— 1 åˆ†ï¼Œ2 ä¸ªå¾— 1.5 åˆ†ï¼Œå†™ é”™ 1 ä¸ªä¸å¾—åˆ†ï¼‰ã€‚

> 54ï¼Œæ˜¯ 1+2+4+8+16+23= 54
>
> åœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚ï¼Œå…¶ä»–æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½æ˜¯æ»¡çš„ã€‚åœ¨æœ€åº•å±‚ï¼Œä»å·¦å¾€å³å¡«å……èŠ‚ç‚¹ã€‚
>
> å¯ä»¥æ˜¯ç¬¬å…­å±‚æ˜¯æ»¡çš„ã€‚ä½†æ˜¯å¶èŠ‚ç‚¹åªæœ‰23ä¸ªï¼Œè¿˜æœ‰9ä¸ªç»“ç‚¹æ˜¯éå¶ç»“ç‚¹ã€‚è¿™æ ·ç¬¬ä¸ƒå±‚è¦ä¹ˆæ˜¯17ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ˜¯18ä¸ªã€‚(1+2+4+8+16+32) + 17 æˆ– 18 = 80ï¼Œæˆ– 81
>
> <mark>54,80,81</mark>



## 4 äºŒå‰æ ‘çš„åº”ç”¨

### 4.1 è§£ææ ‘/æŠ½è±¡è¯­æ³•æ ‘AST

ç°åœ¨æ¥çœ‹çœ‹å¦‚ä½•ç”¨æ ‘è§£å†³ä¸€äº›å®é™…é—®é¢˜ã€‚æœ¬èŠ‚ä»‹ç»è§£ææ ‘ï¼Œå¯ä»¥ç”¨å®ƒæ¥è¡¨ç¤ºç°å®ä¸–ç•Œä¸­åƒå¥å­ï¼ˆå¦‚å›¾1æ‰€ç¤ºï¼‰æˆ–æ•°å­¦è¡¨è¾¾å¼è¿™æ ·çš„æ„é€ ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311914368.png" alt="image-20240131191318107" style="zoom: 25%;" />

<center>å›¾1 ä¸€ä¸ªç®€å•å¥å­çš„è§£ææ ‘</center>



å›¾1å±•ç¤ºäº†ä¸€ä¸ªç®€å•å¥å­çš„å±‚æ¬¡ç»“æ„ã€‚ç”¨æ ‘çŠ¶ç»“æ„è¡¨ç¤ºå¥å­å¯ä»¥ä½¿ç”¨å­æ ‘å¤„ç†å¥å­çš„ç‹¬ç«‹éƒ¨åˆ†ã€‚

ä¹Ÿå¯ä»¥å°†` ( ( 7 + 3) * ( 5 - 2 ) )` è¿™æ ·çš„æ•°å­¦è¡¨è¾¾å¼è¡¨ç¤ºæˆè§£ææ ‘ï¼Œå¦‚å›¾2æ‰€ç¤ºã€‚è¿™æ˜¯å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ï¼Œä¹˜æ³•çš„ä¼˜å…ˆçº§é«˜äºåŠ æ³•å’Œå‡æ³•ï¼Œä½†å› ä¸ºæœ‰æ‹¬å·ï¼Œæ‰€ä»¥åœ¨åšä¹˜æ³•å‰å¿…é¡»å…ˆåšæ‹¬å·å†…çš„åŠ æ³•å’Œå‡æ³•ã€‚<mark>æ ‘çš„å±‚æ¬¡æ€§æœ‰åŠ©äºç†è§£æ•´ä¸ªè¡¨è¾¾å¼çš„è®¡ç®—æ¬¡åºã€‚åœ¨è®¡ç®—é¡¶å±‚çš„ä¹˜æ³•å‰ï¼Œå¿…é¡»å…ˆè®¡ç®—å­æ ‘ä¸­çš„åŠ æ³•å’Œå‡æ³•ã€‚</mark>åŠ æ³•ï¼ˆå·¦å­æ ‘ï¼‰çš„ç»“æœæ˜¯`10`ï¼Œå‡æ³•ï¼ˆå³å­æ ‘ï¼‰çš„ç»“æœæ˜¯`3`ã€‚åˆ©ç”¨æ ‘çš„å±‚æ¬¡ç»“æ„ï¼Œåœ¨è®¡ç®—å®Œå­æ ‘çš„è¡¨è¾¾å¼åï¼Œåªéœ€ç”¨ä¸€ä¸ªèŠ‚ç‚¹ä»£æ›¿æ•´æ£µå­æ ‘å³å¯ã€‚åº”ç”¨è¿™ä¸ªæ›¿æ¢è¿‡ç¨‹åï¼Œä¾¿å¾—åˆ°å¦‚å›¾3æ‰€ç¤ºçš„ç®€åŒ–æ ‘ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311918463.png" alt="image-20240131191832905" style="zoom:25%;" />

<center>å›¾2 `( ( 7 + 3) * ( 5 - 2 ) )`çš„è§£ææ ‘</center>



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311919250.png" alt="image-20240131191907102" style="zoom: 33%;" />

<center>å›¾3 `( ( 7 + 3 ) * ( 5 - 2 ) )`çš„ç®€åŒ–è§£ææ ‘</center>

æœ¬èŠ‚çš„å‰©ä½™éƒ¨åˆ†å°†ä»”ç»†è€ƒå¯Ÿè§£ææ ‘ï¼Œé‡ç‚¹å¦‚ä¸‹ï¼š
	â å¦‚ä½•æ ¹æ®å®Œå…¨æ‹¬å·è¡¨è¾¾å¼æ„å»ºè§£ææ ‘ï¼›
	â å¦‚ä½•è®¡ç®—è§£ææ ‘ä¸­çš„è¡¨è¾¾å¼ï¼›
	â å¦‚ä½•å°†è§£ææ ‘è¿˜åŸæˆæœ€åˆçš„æ•°å­¦è¡¨è¾¾å¼ã€‚



**Q: æƒ³ç¡®è®¤ä¸‹æ ¹æ®å®Œå…¨æ‹¬å·è¡¨è¾¾å¼æ„å»ºè§£æå¼æ˜¯å¦æœ‰ä¸€ä¸ªç®—æ³•åç§°ï¼Ÿ**

> gptè¯´ï¼š
>
> å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ï¼Œé€šå¸¸ç§°ä¸ºâ€œå®Œå…¨åœ†æ‹¬å·è¡¨è¾¾å¼â€æˆ–â€œå®Œå…¨æ‹¬å·åŒ–è¡¨è¾¾å¼â€ï¼Œæ˜¯æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï¼Œç”¨äºæ˜ç¡®æ— è¯¯åœ°è¡¨ç¤ºå¸¦æœ‰æ‹¬å·çš„ç®—æœ¯è¡¨è¾¾å¼æˆ–å…¶ä»–ä»»ä½•éœ€è¦æ“ä½œç¬¦ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼ã€‚è¿™ç§è¡¨è¾¾å¼å½¢å¼æ¶ˆé™¤äº†æ“ä½œç¬¦ä¼˜å…ˆè§„åˆ™çš„æ­§ä¹‰ï¼Œå› ä¸ºæ‰€æœ‰çš„æ“ä½œéƒ½æ˜ç¡®åœ°é€šè¿‡æ‹¬å·æ¥æŒ‡ç¤ºå…¶é¡ºåºã€‚
>
> æ„å»ºè§£ææ ‘ï¼ˆæˆ–æŠ½è±¡è¯­æ³•æ ‘ï¼ŒAbstract Syntax Treeï¼ŒASTï¼‰çš„è¿‡ç¨‹ï¼Œä»ç»™å®šçš„å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ä¸­æå–ç»“æ„ä¿¡æ¯ï¼Œå¹¶åˆ›å»ºç›¸åº”çš„æ ‘å½¢ç»“æ„ï¼Œè¿™åœ¨è®¡ç®—æœºç§‘å­¦ä¸­é€šå¸¸æ˜¯è¯­æ³•åˆ†æï¼ˆParsingï¼‰çš„ä¸€éƒ¨åˆ†ã€‚é’ˆå¯¹æ­¤è¿‡ç¨‹çš„ç®—æ³•æ²¡æœ‰ç‰¹å®šçš„é€šç”¨åç§°ï¼Œä½†å®ƒæ˜¯ç¼–è¯‘å™¨å’Œè§£é‡Šå™¨ä¸­ä½¿ç”¨çš„è¯­æ³•åˆ†ææˆ–è§£æç®—æ³•çš„ä¸€éƒ¨åˆ†ã€‚
>
> æ ‘å½¢ç»“æ„èƒ½å¤Ÿä½“ç°æ“ä½œç¬¦å’Œæ“ä½œæ•°ä¹‹é—´çš„å±‚çº§å…³ç³»ï¼Œè€Œè¡¨è¾¾å¼çš„è§£æè¿‡ç¨‹é€šå¸¸éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š
>
> 1. **è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰**ï¼šæ­¤æ­¥éª¤ä¸­ï¼Œè¾“å…¥çš„å­—ç¬¦åºåˆ—ï¼ˆä»£ç ã€è¡¨è¾¾å¼ç­‰ï¼‰è¢«è½¬æ¢æˆä¸€ç³»åˆ—æ ‡è®°ï¼ˆtokensï¼‰ï¼Œä¾‹å¦‚æ•°å­—ã€æ“ä½œç¬¦ã€æ‹¬å·ç­‰ã€‚
>
> 2. **è¯­æ³•åˆ†æï¼ˆSyntactic Analysisï¼‰**ï¼šåœ¨è¯¥é˜¶æ®µï¼Œæ ‡è®°åºåˆ—æ ¹æ®è¯­æ³•è§„åˆ™è¢«ç»„ç»‡æˆè§£ææ ‘ã€‚è¯­æ³•åˆ†æå™¨ä¼šä½¿ç”¨è¯¸å¦‚é€’å½’ä¸‹é™ã€LL è§£æã€LR è§£æç­‰ç®—æ³•æ¥æ„é€ æ ‘ã€‚
>
> 3. **è¯­ä¹‰åˆ†æï¼ˆSemantic Analysisï¼‰**ï¼šæ„å»ºçš„è§£ææ ‘å¯èƒ½ä¼šè¿›ä¸€æ­¥ç»è¿‡è¯­ä¹‰æ£€æŸ¥ï¼Œä»¥ç¡®ä¿è¡¨è¾¾å¼çš„æ„ä¹‰æ˜¯åˆç†çš„ï¼Œæ¯”å¦‚ç±»å‹æ£€æŸ¥ç­‰ã€‚
>
> å¯¹äºæ„å»ºè§£ææ ‘çš„å…·ä½“ç®—æ³•ï¼Œæ²¡æœ‰ä¸€ä¸ªç»Ÿä¸€çš„åç§°æ¥æè¿°è¿™ä¸ªè¿‡ç¨‹ï¼Œå› ä¸ºå®ƒå¯èƒ½ä¼šæ¶‰åŠä¸åŒçš„è§£æç­–ç•¥å’ŒæŠ€æœ¯ã€‚åœ¨ç¼–è¯‘å™¨è®¾è®¡ä¸­ï¼Œå¸¸è§çš„è§£æç®—æ³•æœ‰LLè§£æå™¨ã€LRè§£æå™¨ã€é€’å½’ä¸‹é™è§£æå™¨ç­‰ã€‚è¿™äº›ç®—æ³•éƒ½å¯ä»¥ç”¨æ¥ä»å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ä¸­æ„å»ºå‡ºè§£ææ ‘ã€‚ã€‚

æ„å»ºè§£ææ ‘çš„ç¬¬ä¸€æ­¥æ˜¯å°†è¡¨è¾¾å¼å­—ç¬¦ä¸²æ‹†åˆ†æˆæ ‡è®°åˆ—è¡¨ã€‚éœ€è¦è€ƒè™‘4ç§æ ‡è®°ï¼š<mark>å·¦æ‹¬å·ã€å³æ‹¬å·ã€è¿ç®—ç¬¦å’Œæ“ä½œæ•°</mark>ã€‚å·¦æ‹¬å·ä»£è¡¨æ–°è¡¨è¾¾å¼çš„èµ·ç‚¹ï¼Œæ‰€ä»¥åº”è¯¥åˆ›å»ºä¸€æ£µå¯¹åº”è¯¥è¡¨è¾¾å¼çš„æ–°æ ‘ã€‚åä¹‹ï¼Œé‡åˆ°å³æ‹¬å·åˆ™æ„å‘³ç€åˆ°è¾¾è¯¥è¡¨è¾¾å¼çš„ç»ˆç‚¹ã€‚æ“ä½œæ•°æ—¢æ˜¯å¶å­èŠ‚ç‚¹ï¼Œä¹Ÿæ˜¯å…¶è¿ç®—ç¬¦çš„å­èŠ‚ç‚¹ã€‚æ­¤å¤–ï¼Œæ¯ä¸ªè¿ç®—ç¬¦éƒ½æœ‰å·¦å³å­èŠ‚ç‚¹ã€‚

æœ‰äº†ä¸Šè¿°ä¿¡æ¯ï¼Œä¾¿å¯ä»¥å®šä¹‰ä»¥ä¸‹<mark>4æ¡è§„åˆ™</mark>ï¼š

(1) å¦‚æœå½“å‰æ ‡è®°æ˜¯(ï¼Œå°±ä¸ºå½“å‰èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ï¼Œå¹¶ä¸‹æ²‰è‡³è¯¥å­èŠ‚ç‚¹ï¼›
(2) å¦‚æœå½“å‰æ ‡è®°åœ¨åˆ—è¡¨`['+', '-', '/', 'ï¼Š']`ä¸­ï¼Œå°±å°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸ºå½“å‰æ ‡è®°å¯¹åº”çš„è¿ç®—ç¬¦ï¼›ä¸ºå½“å‰èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå³å­èŠ‚ç‚¹ï¼Œå¹¶ä¸‹æ²‰è‡³è¯¥å­èŠ‚ç‚¹ï¼›
(3) å¦‚æœå½“å‰æ ‡è®°æ˜¯æ•°å­—ï¼Œå°±å°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸ºè¿™ä¸ªæ•°å¹¶è¿”å›è‡³çˆ¶èŠ‚ç‚¹ï¼›
(4) å¦‚æœå½“å‰æ ‡è®°æ˜¯)ï¼Œå°±è·³åˆ°å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

ç¼–å†™Pythonä»£ç å‰ï¼Œæˆ‘ä»¬å…ˆé€šè¿‡ä¸€ä¸ªä¾‹å­æ¥ç†è§£ä¸Šè¿°è§„åˆ™ã€‚å°†è¡¨è¾¾å¼`(3 + (4 âˆ— 5))`æ‹†åˆ†æˆæ ‡è®°åˆ—è¡¨`['(', '3', '+', '(', '4', 'ï¼Š', '5', ')', ')']`ã€‚èµ·åˆï¼Œè§£ææ ‘åªæœ‰ä¸€ä¸ªç©ºçš„æ ¹èŠ‚ç‚¹ï¼Œéšç€å¯¹æ¯ä¸ªæ ‡è®°çš„å¤„ç†ï¼Œè§£ææ ‘çš„ç»“æ„å’Œå†…å®¹é€æ¸å……å®ï¼Œå¦‚å›¾6æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311922845.png" alt="image-20240131192244859" style="zoom: 33%;" />

<center>å›¾4 å°†`(3 + (4 âˆ— 5))`ä¸€æ­¥æ­¥åœ°æ„å»ºè§£ææ ‘</center>

ä»¥å›¾4ä¸ºä¾‹ï¼Œæˆ‘ä»¬æ¥ä¸€æ­¥æ­¥åœ°æ„å»ºè§£ææ ‘ã€‚

(a) åˆ›å»ºä¸€æ£µç©ºæ ‘ã€‚
(b) è¯»å…¥ç¬¬ä¸€ä¸ªæ ‡è®°(ã€‚æ ¹æ®è§„åˆ™1ï¼Œä¸ºæ ¹èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ã€‚
(c) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°3ã€‚æ ¹æ®è§„åˆ™3ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º3ï¼Œå¹¶å›åˆ°çˆ¶èŠ‚ç‚¹ã€‚
(d) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°+ã€‚æ ¹æ®è§„åˆ™2ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º+ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚æ–°èŠ‚ç‚¹æˆä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(e) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°(ã€‚æ ¹æ®è§„åˆ™1ï¼Œä¸ºå½“å‰èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(f) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°4ã€‚æ ¹æ®è§„åˆ™3ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º4ï¼Œå¹¶å›åˆ°çˆ¶èŠ‚ç‚¹ã€‚
(g) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°ï¼Šã€‚æ ¹æ®è§„åˆ™2ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸ºï¼Šï¼Œå¹¶æ·»åŠ ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚æ–°èŠ‚ç‚¹æˆä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(h) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°5ã€‚æ ¹æ®è§„åˆ™3ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º5ï¼Œå¹¶å›åˆ°çˆ¶èŠ‚ç‚¹ã€‚
(i) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°)ã€‚æ ¹æ®è§„åˆ™4ï¼Œå°†ï¼Šçš„çˆ¶èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(j) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°)ã€‚æ ¹æ®è§„åˆ™4ï¼Œå°†+çš„çˆ¶èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚å› ä¸º+æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥å·¥ä½œå®Œæˆã€‚

æœ¬ä¾‹è¡¨æ˜ï¼Œåœ¨æ„å»ºè§£ææ ‘çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è¿½è¸ªå½“å‰èŠ‚ç‚¹åŠå…¶çˆ¶èŠ‚ç‚¹ã€‚å¯ä»¥é€šè¿‡`getLeftChild`ä¸`getRightChild`è·å–å­èŠ‚ç‚¹ï¼Œä½†å¦‚ä½•è¿½è¸ªçˆ¶èŠ‚ç‚¹å‘¢ï¼Ÿä¸€ä¸ªç®€å•çš„åŠæ³•å°±æ˜¯åœ¨éå†è¿™æ£µæ ‘æ—¶ä½¿ç”¨æ ˆè®°å½•çˆ¶èŠ‚ç‚¹ã€‚æ¯å½“è¦ä¸‹æ²‰è‡³å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ—¶ï¼Œå…ˆå°†å½“å‰èŠ‚ç‚¹å‹åˆ°æ ˆä¸­ã€‚å½“è¦è¿”å›åˆ°å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ—¶ï¼Œå°±å°†çˆ¶èŠ‚ç‚¹ä»æ ˆä¸­å¼¹å‡ºæ¥ã€‚

åˆ©ç”¨å‰é¢æè¿°çš„è§„åˆ™ä»¥åŠ`Stack`å’Œ`BinaryTree`ï¼Œå°±å¯ä»¥ç¼–å†™åˆ›å»ºè§£ææ ‘çš„Pythonå‡½æ•°ã€‚

#### 4.1.1 å®ç°ï¼šè§£ææ ‘æ„å»ºå™¨



```python
class Stack(object):
    def __init__(self):
        self.items = []
        self.stack_size = 0

    def isEmpty(self):
        return self.stack_size == 0

    def push(self, new_item):
        self.items.append(new_item)
        self.stack_size += 1

    def pop(self):
        self.stack_size -= 1
        return self.items.pop()

    def peek(self):
        return self.items[self.stack_size - 1]

    def size(self):
        return self.stack_size


class BinaryTree:
    def __init__(self, rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None

    def insertLeft(self, newNode):
        if self.leftChild == None:
            self.leftChild = BinaryTree(newNode)
        else:  # å·²ç»å­˜åœ¨å·¦å­èŠ‚ç‚¹ã€‚æ­¤æ—¶ï¼Œæ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å°†å·²æœ‰çš„å·¦å­èŠ‚ç‚¹é™ä¸€å±‚ã€‚
            t = BinaryTree(newNode)
            t.leftChild = self.leftChild
            self.leftChild = t

    def insertRight(self, newNode):
        if self.rightChild == None:
            self.rightChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.rightChild = self.rightChild
            self.rightChild = t

    def getRightChild(self):
        return self.rightChild

    def getLeftChild(self):
        return self.leftChild

    def setRootVal(self, obj):
        self.key = obj

    def getRootVal(self):
        return self.key

    def traversal(self, method="preorder"):
        if method == "preorder":
            print(self.key, end=" ")
        if self.leftChild != None:
            self.leftChild.traversal(method)
        if method == "inorder":
            print(self.key, end=" ")
        if self.rightChild != None:
            self.rightChild.traversal(method)
        if method == "postorder":
            print(self.key, end=" ")


def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree

    for i in fplist:
        if i == '(':
            currentTree.insertLeft('')
            pStack.push(currentTree)
            currentTree = currentTree.getLeftChild()
        elif i not in '+-*/)':
            currentTree.setRootVal(int(i))
            parent = pStack.pop()
            currentTree = parent
        elif i in '+-*/':
            currentTree.setRootVal(i)
            currentTree.insertRight('')
            pStack.push(currentTree)
            currentTree = currentTree.getRightChild()
        elif i == ')':
            currentTree = pStack.pop()
        else:
            raise ValueError("Unknown Operator: " + i)
    return eTree


exp = "( ( 7 + 3 ) * ( 5 - 2 ) )"
pt = buildParseTree(exp)
for mode in ["preorder", "postorder", "inorder"]:
    pt.traversal(mode)
    print()

"""
* + 7 3 - 5 2 
7 3 + 5 2 - * 
7 + 3 * 5 - 2 
"""

# ä»£ç æ¸…å•6-10
import operator

def evaluate(parseTree):
    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}

    leftC = parseTree.getLeftChild()
    rightC = parseTree.getRightChild()

    if leftC and rightC:
        fn = opers[parseTree.getRootVal()]
        return fn(evaluate(leftC),evaluate(rightC))
    else:
        return parseTree.getRootVal()

print(evaluate(pt))
# 30

#ä»£ç æ¸…å•6-14 ååºæ±‚å€¼
def postordereval(tree):
    opers = {'+':operator.add, '-':operator.sub,
             '*':operator.mul, '/':operator.truediv}
    res1 = None
    res2 = None
    if tree:
        res1 = postordereval(tree.getLeftChild())
        res2 = postordereval(tree.getRightChild())
        if res1 and res2:
            return opers[tree.getRootVal()](res1,res2)
        else:
            return tree.getRootVal()

print(postordereval(pt))
# 30

#ä»£ç æ¸…å•6-16 ä¸­åºè¿˜åŸå®Œå…¨æ‹¬å·è¡¨è¾¾å¼
def printexp(tree):
    sVal = ""
    if tree:
        sVal = '(' + printexp(tree.getLeftChild())
        sVal = sVal + str(tree.getRootVal())
        sVal = sVal + printexp(tree.getRightChild()) + ')'
    return sVal

print(printexp(pt))
# (((7)+3)*((5)-2))
```



åœ¨ä»£ç æ¸…å•ä¸­ï¼Œç¬¬79ã€83ã€87å’Œ92è¡Œçš„`if`è¯­å¥ä½“ç°äº†æ„å»ºè§£ææ ‘çš„4æ¡è§„åˆ™ï¼Œå…¶ä¸­æ¯æ¡è¯­å¥éƒ½é€šè¿‡è°ƒç”¨`BinaryTree`å’Œ`Stack`çš„æ–¹æ³•å®ç°äº†å‰é¢æè¿°çš„è§„åˆ™ã€‚è¿™ä¸ªå‡½æ•°ä¸­å”¯ä¸€çš„é”™è¯¯æ£€æŸ¥åœ¨`else`ä»å¥ä¸­ï¼Œå¦‚æœé‡åˆ°ä¸€ä¸ªä¸èƒ½è¯†åˆ«çš„æ ‡è®°ï¼Œå°±æŠ›å‡ºä¸€ä¸ª`ValueError`å¼‚å¸¸ã€‚

æœ‰äº†ä¸€æ£µè§£ææ ‘ä¹‹åï¼Œæˆ‘ä»¬èƒ½å¯¹å®ƒåšäº›ä»€ä¹ˆå‘¢ï¼Ÿä½œä¸ºç¬¬ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå‡½æ•°<mark>è®¡ç®—è§£ææ ‘</mark>ï¼Œå¹¶è¿”å›è®¡ç®—ç»“æœã€‚è¦å†™è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨æ ‘çš„å±‚æ¬¡æ€§ã€‚<u>é’ˆå¯¹å›¾2ä¸­çš„è§£ææ ‘ï¼Œå¯ä»¥ç”¨å›¾3ä¸­çš„ç®€åŒ–è§£ææ ‘æ›¿æ¢ã€‚ç”±æ­¤å¯è§ï¼Œå¯ä»¥å†™ä¸€ä¸ªç®—æ³•ï¼Œé€šè¿‡é€’å½’è®¡ç®—æ¯æ£µå­æ ‘å¾—åˆ°æ•´æ£µè§£ææ ‘çš„ç»“æœã€‚</u>

> å› ä¸ºä¸¤ä¸ªå›¾è·ç¦»ç›®å‰æ–‡å­—å¤ªè¿œï¼Œå¤åˆ¶ç²˜è´´

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311918463.png" alt="image-20240131191832905" style="zoom:25%;" />

<center>å›¾2 `( ( 7 + 3 ) * ( 5 - 2 ) )`çš„è§£ææ ‘</center>



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311919250.png" alt="image-20240131191907102" style="zoom: 33%;" />

<center>å›¾3 `( ( 7 + 3 ) * ( 5 - 2 ) )`çš„ç®€åŒ–è§£ææ ‘</center>

å’Œä¹‹å‰ç¼–å†™é€’å½’å‡½æ•°ä¸€æ ·ï¼Œ<mark>è®¾è®¡é€’å½’è®¡ç®—å‡½æ•°è¦ä»ç¡®å®šåŸºæœ¬æƒ…å†µå¼€å§‹</mark>ã€‚å°±é’ˆå¯¹æ ‘è¿›è¡Œæ“ä½œçš„é€’å½’ç®—æ³•è€Œè¨€ï¼Œä¸€ä¸ªå¾ˆè‡ªç„¶çš„åŸºæœ¬æƒ…å†µå°±æ˜¯æ£€æŸ¥å¶å­èŠ‚ç‚¹ã€‚è§£ææ ‘çš„å¶å­èŠ‚ç‚¹å¿…å®šæ˜¯æ“ä½œæ•°ã€‚ç”±äºåƒæ•´æ•°å’Œæµ®ç‚¹æ•°è¿™æ ·çš„æ•°å€¼å¯¹è±¡ä¸éœ€è¦è¿›ä¸€æ­¥ç¿»è¯‘ï¼Œå› æ­¤evaluateå‡½æ•°å¯ä»¥ç›´æ¥è¿”å›å¶å­èŠ‚ç‚¹çš„å€¼ã€‚ä¸ºäº†å‘**åŸºæœ¬æƒ…å†µ**é è¿‘ï¼Œç®—æ³•å°†æ‰§è¡Œé€’å½’æ­¥éª¤ï¼Œå³å¯¹å½“å‰èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹è°ƒç”¨evaluateå‡½æ•°ã€‚<mark>é€’å½’è°ƒç”¨å¯ä»¥æœ‰æ•ˆåœ°æ²¿ç€å„æ¡è¾¹å¾€å¶å­èŠ‚ç‚¹é è¿‘ã€‚</mark>

è‹¥è¦ç»“åˆä¸¤ä¸ªé€’å½’è°ƒç”¨çš„ç»“æœï¼Œåªéœ€å°†çˆ¶èŠ‚ç‚¹ä¸­å­˜å‚¨çš„è¿ç®—ç¬¦åº”ç”¨äºå­èŠ‚ç‚¹çš„è®¡ç®—ç»“æœå³å¯ã€‚ä»å›¾3ä¸­å¯çŸ¥ï¼Œæ ¹èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹çš„è®¡ç®—ç»“æœå°±æ˜¯å®ƒä»¬è‡ªèº«ï¼Œå³`10`å’Œ`3`ã€‚åº”ç”¨ä¹˜å·ï¼Œå¾—åˆ°æœ€åçš„ç»“æœ30ã€‚

é€’å½’å‡½æ•°evaluateçš„å®ç°å¦‚ä»£ç æ¸…å•æ‰€ç¤ºã€‚é¦–å…ˆï¼Œè·å–æŒ‡å‘å½“å‰èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹çš„å¼•ç”¨ã€‚<mark>å¦‚æœå·¦å³å­èŠ‚ç‚¹çš„å€¼éƒ½æ˜¯Noneï¼Œå°±è¯´æ˜å½“å‰èŠ‚ç‚¹ç¡®å®æ˜¯å¶å­èŠ‚ç‚¹ã€‚</mark>ç¬¬9è¡Œæ‰§è¡Œè¿™é¡¹æ£€æŸ¥ã€‚å¦‚æœå½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œåˆ™æŸ¥çœ‹å½“å‰èŠ‚ç‚¹ä¸­å­˜å‚¨çš„è¿ç®—ç¬¦ï¼Œå¹¶å°†å…¶åº”ç”¨äºå·¦å³å­èŠ‚ç‚¹çš„é€’å½’è®¡ç®—ç»“æœã€‚



#### 4.1.2 å®ç°ï¼šè®¡ç®—äºŒå‰è§£ææ ‘çš„é€’å½’å‡½æ•°

ä»£ç æ¸…å•6-10ã€‚

```python
import operator

def evaluate(parseTree):
    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}

    leftC = parseTree.getLeftChild()
    rightC = parseTree.getRightChild()

    if leftC and rightC:
        fn = opers[parseTree.getRootVal()]
        return fn(evaluate(leftC),evaluate(rightC)) #å…ˆè®¡ç®—å·¦å­æ ‘ï¼Œå†è®¡ç®—å³å­æ ‘ï¼Œæœ€åé€šè¿‡æ ¹èŠ‚ç‚¹è¿ç®—ç¬¦çš„å‡½æ•°è°ƒç”¨å°†ä¸¤ä¸ªç»“æœç»“åˆèµ·æ¥ã€‚
    else:
        return parseTree.getRootVal()
```



æˆ‘ä»¬ä½¿ç”¨å…·æœ‰é”®+ã€-ã€ï¼Šå’Œ/çš„å­—å…¸å®ç°ã€‚å­—å…¸ä¸­å­˜å‚¨çš„å€¼æ˜¯`operator`æ¨¡å—çš„å‡½æ•°ã€‚è¯¥æ¨¡å—æä¾›äº†å¸¸ç”¨è¿ç®—ç¬¦çš„å‡½æ•°ç‰ˆæœ¬ã€‚<mark>åœ¨å­—å…¸ä¸­æŸ¥è¯¢è¿ç®—ç¬¦æ—¶ï¼Œå¯¹åº”çš„å‡½æ•°å¯¹è±¡è¢«å–å‡º</mark>ã€‚æ—¢ç„¶å–å‡ºçš„å¯¹è±¡æ˜¯å‡½æ•°ï¼Œå°±å¯ä»¥ç”¨æ™®é€šçš„æ–¹å¼`function(param1, param2)`è°ƒç”¨ã€‚å› æ­¤ï¼Œ`opers\['+'](2, 2)`ç­‰ä»·äº`operator.add(2, 2)`ã€‚

æœ€åï¼Œè®©æˆ‘ä»¬é€šè¿‡å›¾4ä¸­çš„è§£ææ ‘æ„å»ºè¿‡ç¨‹æ¥ç†è§£evaluateå‡½æ•°ã€‚ç¬¬ä¸€æ¬¡è°ƒç”¨evaluateå‡½æ•°æ—¶ï¼Œå°†æ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä½œä¸ºå‚æ•°parseTreeä¼ å…¥ã€‚ç„¶åï¼Œè·å–æŒ‡å‘å·¦å³å­èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦å­˜åœ¨ã€‚<mark>ç¬¬11è¡Œè¿›è¡Œé€’å½’è°ƒç”¨ã€‚</mark>ä»æŸ¥è¯¢æ ¹èŠ‚ç‚¹çš„è¿ç®—ç¬¦å¼€å§‹ï¼Œè¯¥è¿ç®—ç¬¦æ˜¯+ï¼Œå¯¹åº”operator.addå‡½æ•°ï¼Œè¦ä¼ å…¥ä¸¤ä¸ªå‚æ•°ã€‚å’Œæ™®é€šçš„Pythonå‡½æ•°è°ƒç”¨ä¸€æ ·ï¼ŒPythonåšçš„ç¬¬ä¸€ä»¶äº‹æ˜¯è®¡ç®—å…¥å‚çš„å€¼ã€‚æœ¬ä¾‹ä¸­ï¼Œä¸¤ä¸ªå…¥å‚éƒ½æ˜¯å¯¹evaluateå‡½æ•°çš„é€’å½’è°ƒç”¨ã€‚ç”±äºå…¥å‚çš„è®¡ç®—é¡ºåºæ˜¯ä»å·¦åˆ°å³ï¼Œå› æ­¤ç¬¬ä¸€æ¬¡é€’å½’è°ƒç”¨æ˜¯åœ¨å·¦è¾¹ã€‚å¯¹å·¦å­æ ‘é€’å½’è°ƒç”¨evaluateå‡½æ•°ï¼Œå‘ç°èŠ‚ç‚¹æ²¡æœ‰å·¦å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹ã€‚å¤„äºå¶å­èŠ‚ç‚¹æ—¶ï¼Œåªéœ€è¿”å›å¶å­èŠ‚ç‚¹çš„å€¼ä½œä¸ºè®¡ç®—ç»“æœå³å¯ã€‚æœ¬ä¾‹ä¸­ï¼Œè¿”å›æ•´æ•°3ã€‚

è‡³æ­¤ï¼Œå·²ç»ä¸ºé¡¶å±‚çš„`operator.add`è°ƒç”¨è®¡ç®—å‡ºä¸€ä¸ªå‚æ•°çš„å€¼äº†ï¼Œä½†è¿˜æ²¡å®Œã€‚ç»§ç»­ä»å·¦åˆ°å³çš„å‚æ•°è®¡ç®—è¿‡ç¨‹ï¼Œç°åœ¨è¿›è¡Œä¸€ä¸ªé€’å½’è°ƒç”¨ï¼Œè®¡ç®—æ ¹èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ã€‚å‘ç°è¯¥èŠ‚ç‚¹ä¸ä»…æœ‰å·¦å­èŠ‚ç‚¹ï¼Œè¿˜æœ‰å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ£€æŸ¥èŠ‚ç‚¹å­˜å‚¨çš„è¿ç®—ç¬¦â€”â€”æ˜¯ï¼Šï¼Œå°†å·¦å³å­èŠ‚ç‚¹ä½œä¸ºå‚æ•°è°ƒç”¨å‡½æ•°ã€‚è¿™æ—¶å¯ä»¥çœ‹åˆ°ï¼Œä¸¤ä¸ªè°ƒç”¨éƒ½å·²åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—ç»“æœåˆ†åˆ«æ˜¯4å’Œ5ã€‚ç®—å‡ºå‚æ•°ä¹‹åï¼Œè¿”å›operator.mul(4, 5)çš„ç»“æœã€‚è‡³æ­¤ï¼Œå·²ç»ç®—å‡ºäº†é¡¶å±‚è¿ç®—ç¬¦ï¼ˆ+ï¼‰çš„æ“ä½œæ•°ï¼Œå‰©ä¸‹çš„å·¥ä½œå°±æ˜¯å®Œæˆå¯¹operator.add(3, 20)çš„è°ƒç”¨ã€‚å› æ­¤ï¼Œè¡¨è¾¾å¼(3 + (4 âˆ— 5))çš„è®¡ç®—ç»“æœå°±æ˜¯23ã€‚

#### 4.1.3 ç¼–ç¨‹é¢˜ç›®

##### ç»ƒä¹ M25140: æ ¹æ®ååºè¡¨è¾¾å¼å»ºç«‹é˜Ÿåˆ—è¡¨è¾¾å¼

http://cs101.openjudge.cn/practice/25140/

ååºç®—æœ¯è¡¨è¾¾å¼å¯ä»¥é€šè¿‡æ ˆæ¥è®¡ç®—å…¶å€¼ï¼Œåšæ³•å°±æ˜¯ä»å·¦åˆ°å³æ‰«æè¡¨è¾¾å¼ï¼Œç¢°åˆ°æ“ä½œæ•°å°±å…¥æ ˆï¼Œç¢°åˆ°è¿ç®—ç¬¦ï¼Œå°±å–å‡ºæ ˆé¡¶çš„2ä¸ªæ“ä½œæ•°åšè¿ç®—(å…ˆå‡ºæ ˆçš„æ˜¯ç¬¬äºŒä¸ªæ“ä½œæ•°ï¼Œåå‡ºæ ˆçš„æ˜¯ç¬¬ä¸€ä¸ª)ï¼Œå¹¶å°†è¿ç®—ç»“æœå‹å…¥æ ˆä¸­ã€‚æœ€åæ ˆé‡Œåªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå°±æ˜¯è¡¨è¾¾å¼çš„å€¼ã€‚

æœ‰ä¸€ç§ç®—æœ¯è¡¨è¾¾å¼ä¸å¦¨å«åšâ€œé˜Ÿåˆ—è¡¨è¾¾å¼â€ï¼Œå®ƒçš„æ±‚å€¼è¿‡ç¨‹å’Œååºè¡¨è¾¾å¼å¾ˆåƒï¼Œåªæ˜¯å°†æ ˆæ¢æˆäº†é˜Ÿåˆ—ï¼šä»å·¦åˆ°å³æ‰«æè¡¨è¾¾å¼ï¼Œç¢°åˆ°æ“ä½œæ•°å°±å…¥é˜Ÿåˆ—ï¼Œç¢°åˆ°è¿ç®—ç¬¦ï¼Œå°±å–å‡ºé˜Ÿå¤´2ä¸ªæ“ä½œæ•°åšè¿ç®—ï¼ˆå…ˆå‡ºé˜Ÿçš„æ˜¯ç¬¬2ä¸ªæ“ä½œæ•°ï¼Œåå‡ºé˜Ÿçš„æ˜¯ç¬¬1ä¸ªï¼‰ï¼Œå¹¶å°†è¿ç®—ç»“æœåŠ å…¥é˜Ÿåˆ—ã€‚æœ€åé˜Ÿåˆ—é‡Œåªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå°±æ˜¯è¡¨è¾¾å¼çš„å€¼ã€‚

ç»™å®šä¸€ä¸ªååºè¡¨è¾¾å¼ï¼Œè¯·è½¬æ¢æˆç­‰ä»·çš„é˜Ÿåˆ—è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼Œ`3 4 + 6 5 * -`çš„ç­‰ä»·é˜Ÿåˆ—è¡¨è¾¾å¼å°±æ˜¯`5 6 4 3 * + -` ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ­£æ•´æ•° n (n<100)ã€‚æ¥ä¸‹æ¥æ˜¯nè¡Œï¼Œæ¯è¡Œä¸€ä¸ªç”±å­—æ¯æ„æˆçš„å­—ç¬¦ä¸²ï¼Œé•¿åº¦ä¸è¶…è¿‡100,è¡¨ç¤ºä¸€ä¸ªååºè¡¨è¾¾å¼ï¼Œå…¶ä¸­å°å†™å­—æ¯æ˜¯æ“ä½œæ•°ï¼Œå¤§å†™å­—æ¯æ˜¯è¿ç®—ç¬¦ã€‚è¿ç®—ç¬¦éƒ½æ˜¯éœ€è¦2ä¸ªæ“ä½œæ•°çš„ã€‚

**è¾“å‡º**

å¯¹æ¯ä¸ªååºè¡¨è¾¾å¼ï¼Œè¾“å‡ºå…¶ç­‰ä»·çš„é˜Ÿåˆ—è¡¨è¾¾å¼ã€‚

æ ·ä¾‹è¾“å…¥

```
2
xyPzwIM
abcABdefgCDEF
```

æ ·ä¾‹è¾“å‡º

```
wzyxIPM
gfCecbDdAaEBF
```

æç¤º

<mark>å»ºç«‹èµ·è¡¨è¾¾å¼æ ‘ï¼ŒæŒ‰å±‚æ¬¡éå†è¡¨è¾¾å¼æ ‘çš„ç»“æœå‰åé¢ å€’å°±å¾—åˆ°é˜Ÿåˆ—è¡¨è¾¾å¼</mark>

æ¥æºï¼šGuo Wei modified from Ulm Local 2007



The problem is asking to convert a postfix expression to an equivalent queue expression. The queue expression is obtained by reversing the level order traversal of the expression tree built from the postfix expression.  

Here is a step-by-step plan:  
1.Create a TreeNode class to represent each node in the tree.
2.Create a function build_tree that takes the postfix expression as input and returns the root of the constructed tree.
	Use a stack to store the nodes.
	Iterate over the characters in the postfix expression.
	If the character is an operand, create a new node and push it onto the stack.
	If the character is an operator, pop two nodes from the stack, make them the children of a new node, and push the new node onto the stack.
3.Create a function level_order_traversal that takes the root of the tree as input and returns the level order traversal of the tree.
	Use a queue `traversal` to store the nodes to be visited.
	While the queue is not empty, dequeue a node, visit it, and enqueue its children.
4.For each postfix expression, construct the tree, perform the level order traversal, reverse the result, and output it.

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_tree(postfix):
    stack = []
    for char in postfix:
        node = TreeNode(char)
        if char.isupper():
            node.right = stack.pop()
            node.left = stack.pop()
        stack.append(node)
    return stack[0]

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

n = int(input().strip())
for _ in range(n):
    postfix = input().strip()
    root = build_tree(postfix)
    queue_expression = level_order_traversal(root)[::-1]
    print(''.join(queue_expression))
```



### 4.2 ğŸŒ²çš„éå†åŠåº”ç”¨

æˆ‘ä»¬å·²ç»äº†è§£äº†æ ‘çš„åŸºæœ¬åŠŸèƒ½ï¼Œç°åœ¨æ˜¯æ—¶å€™çœ‹çœ‹ä¸€äº›é™„åŠ çš„ä½¿ç”¨æ¨¡å¼äº†ã€‚è¿™äº›ä½¿ç”¨æ¨¡å¼å¯ä»¥æŒ‰èŠ‚ç‚¹çš„è®¿é—®æ–¹å¼åˆ†ä¸º3ç§ã€‚æˆ‘ä»¬å°†å¯¹æ‰€æœ‰èŠ‚ç‚¹çš„è®¿é—®ç§°ä¸ºâ€œéå†â€ï¼Œå…±æœ‰3ç§éå†æ–¹å¼ï¼Œåˆ†åˆ«ä¸ºå‰åºéå†ã€ä¸­åºéå†å’Œååºéå†ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å…ˆä»”ç»†åœ°å®šä¹‰è¿™3ç§éå†æ–¹å¼ï¼Œç„¶åé€šè¿‡ä¸€äº›ä¾‹å­çœ‹çœ‹å®ƒä»¬çš„ç”¨æ³•ã€‚

> **å‰åºéå†**
> åœ¨å‰åºéå†ä¸­ï¼Œå…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’åœ°å‰åºéå†å·¦å­æ ‘ï¼Œæœ€åé€’å½’åœ°å‰åºéå†å³å­æ ‘ã€‚
>
> **ä¸­åºéå†**
> åœ¨ä¸­åºéå†ä¸­ï¼Œå…ˆé€’å½’åœ°ä¸­åºéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åé€’å½’åœ°ä¸­åºéå†å³å­æ ‘ã€‚
>
> **ååºéå†**
> åœ¨ååºéå†ä¸­ï¼Œå…ˆé€’å½’åœ°ååºéå†å·¦å­æ ‘ï¼Œç„¶åé€’å½’åœ°ååºéå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚

è®©æˆ‘ä»¬é€šè¿‡å‡ ä¸ªä¾‹å­æ¥ç†è§£è¿™3ç§éå†æ–¹å¼ã€‚é¦–å…ˆçœ‹çœ‹å‰åºéå†ã€‚<mark>å°†ä¸€æœ¬ä¹¦çš„å†…å®¹ç»“æ„è¡¨ç¤ºä¸ºä¸€æ£µæ ‘</mark>ï¼Œæ•´æœ¬ä¹¦æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸€ç« æ˜¯æ ¹èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œæ¯ä¸€ç« ä¸­çš„æ¯ä¸€èŠ‚æ˜¯è¿™ç« çš„å­èŠ‚ç‚¹ï¼Œæ¯å°èŠ‚åˆæ˜¯è¿™èŠ‚çš„å­èŠ‚ç‚¹ï¼Œä¾æ­¤ç±»æ¨ã€‚å›¾8 å±•ç¤ºäº†ä¸€æœ¬ä¹¦çš„æ ‘çŠ¶ç»“æ„ï¼Œå®ƒåŒ…å«ä¸¤ç« ã€‚æ³¨æ„ï¼Œ<mark>éå†ç®—æ³•å¯¹æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°æ²¡æœ‰è¦æ±‚</mark>ï¼Œä½†æœ¬ä¾‹åªé’ˆå¯¹äºŒå‰æ ‘ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/booktree.png" alt="image" style="zoom:67%;" />

<center>å›¾8 ä¸€æœ¬ä¹¦çš„æ ‘çŠ¶ç»“æ„</center>

<mark>å‡è®¾æˆ‘ä»¬ä»å‰å¾€åé˜…è¯»è¿™æœ¬ä¹¦ï¼Œé‚£ä¹ˆé˜…è¯»é¡ºåºå°±ç¬¦åˆå‰åºéå†çš„æ¬¡åº</mark>ã€‚ä»æ ¹èŠ‚ç‚¹â€œä¹¦â€å¼€å§‹ï¼Œéµå¾ªå‰åºéå†æŒ‡ä»¤ï¼Œå¯¹å·¦å­èŠ‚ç‚¹â€œç¬¬1ç« â€é€’å½’è°ƒç”¨preorderå‡½æ•°ã€‚ç„¶åï¼Œå¯¹â€œç¬¬1ç« â€çš„å·¦å­èŠ‚ç‚¹é€’å½’è°ƒç”¨preorderå‡½æ•°ï¼Œå¾—åˆ°èŠ‚ç‚¹â€œ1.1èŠ‚â€ã€‚ç”±äºè¯¥èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œå› æ­¤ä¸å¿…å†è¿›è¡Œé€’å½’è°ƒç”¨ã€‚æ²¿ç€æ ‘å›åˆ°èŠ‚ç‚¹â€œç¬¬1ç« â€ï¼Œæ¥ä¸‹æ¥è®¿é—®å®ƒçš„å³å­èŠ‚ç‚¹ï¼Œå³â€œ1.2èŠ‚â€ã€‚å’Œå‰é¢ä¸€æ ·ï¼Œå…ˆè®¿é—®å·¦å­èŠ‚ç‚¹â€œ1.2.1èŠ‚â€ï¼Œç„¶åè®¿é—®å³å­èŠ‚ç‚¹â€œ1.2.2èŠ‚â€ã€‚è®¿é—®å®Œâ€œ1.2èŠ‚â€ä¹‹åï¼Œå›åˆ°â€œç¬¬1ç« â€ã€‚æ¥ä¸‹æ¥ï¼Œå›åˆ°æ ¹èŠ‚ç‚¹ï¼Œä»¥åŒæ ·çš„æ–¹å¼è®¿é—®èŠ‚ç‚¹â€œç¬¬2ç« â€ã€‚

<mark>éå†æ ‘çš„ä»£ç æ ¼å¤–ç®€æ´ï¼Œè¿™ä¸»è¦æ˜¯å› ä¸ºéå†æ˜¯é€’å½’çš„ã€‚</mark>

ä½ å¯èƒ½ä¼šæƒ³ï¼Œå‰åºéå†ç®—æ³•çš„æœ€ä½³å®ç°æ–¹å¼æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ˜¯ä¸€ä¸ªå°†æ ‘ç”¨ä½œæ•°æ®ç»“æ„çš„å‡½æ•°ï¼Œè¿˜æ˜¯æ ‘æœ¬èº«çš„ä¸€ä¸ªæ–¹æ³•ï¼Ÿä»£ç æ¸…å•6-11ç»™å‡ºäº†å‰åºéå†ç®—æ³•çš„å¤–éƒ¨å‡½æ•°ç‰ˆæœ¬ï¼Œè¯¥å‡½æ•°å°†äºŒå‰æ ‘ä½œä¸ºå‚æ•°ï¼Œå…¶ä»£ç å°¤ä¸ºç®€æ´ï¼Œè¿™æ˜¯å› ä¸ºç®—æ³•çš„åŸºæœ¬æƒ…å†µä»…ä»…æ˜¯æ£€æŸ¥æ ‘æ˜¯å¦å­˜åœ¨ã€‚å¦‚æœå‚æ•°treeæ˜¯Noneï¼Œå‡½æ•°ç›´æ¥è¿”å›ã€‚

ä»£ç æ¸…å•6-11 å°†å‰åºéå†ç®—æ³•å®ç°ä¸ºå¤–éƒ¨å‡½æ•°

```python
def preorder(tree):
    if tree:
        print(tree.getRootVal())
        preorder(tree.getLeftChild())
        preorder(tree.getRightChild())
```



ä¹Ÿå¯ä»¥å°†preorderå®ç°ä¸ºBinaryTreeç±»çš„æ–¹æ³•ï¼Œå¦‚ä»£ç æ¸…å•6-12æ‰€ç¤ºã€‚è¯·ç•™æ„å°†ä»£ç ä»å¤–éƒ¨ç§»åˆ°å†…éƒ¨åæœ‰ä½•å˜åŒ–ã€‚é€šå¸¸æ¥è¯´ï¼Œä¸ä»…éœ€è¦ç”¨selfä»£æ›¿treeï¼Œè¿˜éœ€è¦ä¿®æ”¹åŸºæœ¬æƒ…å†µã€‚<mark>å†…éƒ¨æ–¹æ³•å¿…é¡»åœ¨é€’å½’è°ƒç”¨preorderå‰ï¼Œæ£€æŸ¥å·¦å³å­èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ã€‚</mark>

ä»£ç æ¸…å•6-12 å°†å‰åºéå†ç®—æ³•å®ç°ä¸ºBinaryTreeç±»çš„æ–¹æ³•

```python
def preorder(self):
    print(self.key)
    if self.leftChild:
        self.leftChild.preorder()
    if self.rightChild:
        self.rightChild.preorder()
```



å“ªç§å®ç°æ–¹å¼æ›´å¥½å‘¢ï¼Ÿåœ¨æœ¬ä¾‹ä¸­ï¼Œå°†preorderå®ç°ä¸ºå¤–éƒ¨å‡½æ•°å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚åŸå› åœ¨äºï¼Œå¾ˆå°‘ä¼šä»…æ‰§è¡Œéå†æ“ä½œï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿˜è¦é€šè¿‡åŸºæœ¬çš„éå†æ¨¡å¼å®ç°åˆ«çš„ç›®æ ‡ã€‚åœ¨ä¸‹ä¸€ä¸ªä¾‹å­ä¸­ï¼Œå°±ä¼šé€šè¿‡ååºéå†æ¥è®¡ç®—è§£ææ ‘ã€‚æ‰€ä»¥ï¼Œåœ¨æ­¤é‡‡ç”¨å¤–éƒ¨å‡½æ•°ç‰ˆæœ¬ã€‚

åœ¨ä»£ç æ¸…å•6-13ä¸­ï¼Œååºéå†å‡½æ•°postorderä¸å‰åºéå†å‡½æ•°preorderå‡ ä¹ç›¸åŒï¼Œåªä¸è¿‡å¯¹printçš„è°ƒç”¨è¢«ç§»åˆ°äº†å‡½æ•°çš„æœ«å°¾ã€‚

ä»£ç æ¸…å•6-13 ååºéå†å‡½æ•°

```python
def postorder(tree):
    if tree != None:
        postorder(tree.getLeftChild())
        postorder(tree.getRightChild())
        print(tree.getRootVal())
```



æˆ‘ä»¬å·²ç»è§è¯†è¿‡<mark>ååºéå†çš„ä¸€ä¸ªå¸¸è§ç”¨é€”ï¼Œé‚£å°±æ˜¯è®¡ç®—è§£ææ ‘</mark>ã€‚<mark>å›é¡¾ä»£ç æ¸…å•6-10ï¼Œæ‰€åšçš„å°±æ˜¯å…ˆè®¡ç®—å·¦å­æ ‘ï¼Œå†è®¡ç®—å³å­æ ‘ï¼Œæœ€åé€šè¿‡æ ¹èŠ‚ç‚¹è¿ç®—ç¬¦çš„å‡½æ•°è°ƒç”¨å°†ä¸¤ä¸ªç»“æœç»“åˆèµ·æ¥ã€‚</mark>å‡è®¾äºŒå‰æ ‘åªå­˜å‚¨ä¸€ä¸ªè¡¨è¾¾å¼çš„æ•°æ®ã€‚è®©æˆ‘ä»¬æ¥é‡å†™è®¡ç®—å‡½æ•°ï¼Œä½¿ä¹‹æ›´æ¥è¿‘äºä»£ç æ¸…å•6-13ä¸­çš„ååºéå†å‡½æ•°ã€‚

#### 4.2.1 ååºæ±‚å€¼

ä»£ç æ¸…å•6-14 

```python
def postordereval(tree):
    opers = {'+':operator.add, '-':operator.sub, 
             '*':operator.mul, '/':operator.truediv}
    res1 = None
    res2 = None
    if tree:
        res1 = postordereval(tree.getLeftChild())
        res2 = postordereval(tree.getRightChild())
        if res1 and res2:
            return opers[tree.getRootVal()](res1,res2)
        else:
            return tree.getRootVal()
```

æ³¨æ„ï¼Œä»£ç æ¸…å•6-14ä¸ä»£ç æ¸…å•6-13åœ¨å½¢å¼ä¸Šå¾ˆç›¸ä¼¼ï¼Œåªä¸è¿‡æ±‚å€¼å‡½æ•°æœ€åä¸æ˜¯æ‰“å°èŠ‚ç‚¹ï¼Œè€Œæ˜¯è¿”å›èŠ‚ç‚¹ã€‚è¿™æ ·ä¸€æ¥ï¼Œå°±å¯ä»¥ä¿å­˜ä»ç¬¬7è¡Œå’Œç¬¬8è¡Œçš„é€’å½’è°ƒç”¨è¿”å›çš„å€¼ï¼Œç„¶ååœ¨ç¬¬10è¡Œä½¿ç”¨è¿™äº›å€¼å’Œè¿ç®—ç¬¦è¿›è¡Œè®¡ç®—ã€‚

æœ€åæ¥äº†è§£<mark>ä¸­åºéå†</mark>ã€‚ä¸­åºéå†çš„è®¿é—®é¡ºåºæ˜¯å·¦å­æ ‘ã€æ ¹èŠ‚ç‚¹ã€å³å­æ ‘ã€‚ä»£ç æ¸…å•6-15ç»™å‡ºäº†ä¸­åºéå†å‡½æ•°çš„ä»£ç ã€‚æ³¨æ„ï¼Œ3ä¸ªéå†å‡½æ•°çš„åŒºåˆ«ä»…åœ¨äºprintè¯­å¥ä¸é€’å½’è°ƒç”¨è¯­å¥çš„ç›¸å¯¹ä½ç½®ã€‚

ä»£ç æ¸…å•6-15 ä¸­åºéå†å‡½æ•°

```python
def inorder(tree):
    if tree != None:
        inorder(tree.getLeftChild())
        print(tree.getRootVal())
        inorder(tree.getRightChild())
```

<mark>é€šè¿‡ä¸­åºéå†è§£ææ ‘ï¼Œå¯ä»¥è¿˜åŸä¸å¸¦æ‹¬å·çš„è¡¨è¾¾å¼ã€‚</mark>æ¥ä¸‹æ¥ä¿®æ”¹ä¸­åºéå†ç®—æ³•ï¼Œä»¥å¾—åˆ°å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ã€‚å”¯ä¸€è¦åšçš„ä¿®æ”¹æ˜¯ï¼šåœ¨é€’å½’è°ƒç”¨å·¦å­æ ‘å‰æ‰“å°ä¸€ä¸ªå·¦æ‹¬å·ï¼Œåœ¨é€’å½’è°ƒç”¨å³å­æ ‘åæ‰“å°ä¸€ä¸ªå³æ‹¬å·ã€‚ä»£ç æ¸…å•6-16æ˜¯ä¿®æ”¹åçš„å‡½æ•°ã€‚

#### 4.2.2 ä¸­åºè¿˜åŸå®Œå…¨æ‹¬å·è¡¨è¾¾å¼

ä»£ç æ¸…å•6-16 

```python
def printexp(tree):
    sVal = ""
    if tree:
        sVal = '(' + printexp(tree.getLeftChild())
        sVal = sVal + str(tree.getRootVal())
        sVal = sVal + printexp(tree.getRightChild()) + ')'
    return sVal

print(printexp(pt))
# (((7)+3)*((5)-2))
```



æ³¨æ„ï¼Œprintexpå‡½æ•°ç»™æ¯ä¸ªæ•°å­—éƒ½åŠ ä¸Šäº†æ‹¬å·ã€‚å°½ç®¡ä¸èƒ½ç®—é”™è¯¯ï¼Œä½†è¿™äº›æ‹¬å·æ˜¾ç„¶æ˜¯å¤šä½™çš„ã€‚è¯·ä¿®æ”¹printexpå‡½æ•°ï¼Œç§»é™¤è¿™äº›æ‹¬å·ã€‚



#### 4.2.3 ç¼–ç¨‹é¢˜ç›®



##### ç»ƒä¹ LC105.ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `preorder` å’Œ `inorder` ï¼Œå…¶ä¸­ `preorder` æ˜¯äºŒå‰æ ‘çš„**å…ˆåºéå†**ï¼Œ `inorder` æ˜¯åŒä¸€æ£µæ ‘çš„**ä¸­åºéå†**ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1:**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:67%;" />

```
è¾“å…¥: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
è¾“å‡º: [3,9,20,null,null,15,7]
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: preorder = [-1], inorder = [-1]
è¾“å‡º: [-1]
```

 

**æç¤º:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` å’Œ `inorder` å‡ **æ— é‡å¤** å…ƒç´ 
- `inorder` å‡å‡ºç°åœ¨ `preorder`
- `preorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—
- `inorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—



```python
from typing import List, Optional
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None

        # The first element in preorder is the root
        root_val = preorder[0]
        root = TreeNode(root_val)

        # Find the index of the root in inorder
        root_index = inorder.index(root_val)

        # Recursively build the left and right subtrees
        root.left = self.buildTree(preorder[1:1 + root_index], inorder[:root_index])
        root.right = self.buildTree(preorder[1 + root_index:], inorder[root_index + 1:])

        return root

if __name__ == '__main__':
    solution = Solution()
    preorder = [3, 9, 20, 15, 7]
    inorder = [9, 3, 15, 20, 7]
    root = solution.buildTree(preorder, inorder)
    # The output tree is [3, 9, 20, None, None, 15, 7]

```



<mark>ä»¥ä¸‹æ˜¯ä¸LC105ç±»ä¼¼çš„3ä¸ªé¢˜ç›®</mark>

###### 1ï¼‰ç»ƒä¹ M24750: æ ¹æ®äºŒå‰æ ‘ä¸­ååºåºåˆ—å»ºæ ‘

http://cs101.openjudge.cn/practice/24750/

å‡è®¾äºŒå‰æ ‘çš„èŠ‚ç‚¹é‡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å­—æ¯éƒ½ä¸åŒã€‚

ç»™å®šäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—å’Œååºéå†åºåˆ—ï¼ˆé•¿åº¦å‡ä¸è¶…è¿‡26ï¼‰ï¼Œè¯·è¾“å‡ºè¯¥äºŒå‰æ ‘çš„å‰åºéå†åºåˆ—ã€‚

**è¾“å…¥**

2è¡Œï¼Œå‡ä¸ºå¤§å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€æ£µäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—ä¸ååºéå†æ’åˆ—ã€‚

**è¾“å‡º**

è¡¨ç¤ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—ã€‚

æ ·ä¾‹è¾“å…¥

```
BADC
BDCA
```

æ ·ä¾‹è¾“å‡º

```
ABCD
```

æ¥æº

Lou Yuke



```python
"""
ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ç„¶åï¼Œåœ¨ä¸­åºéå†åºåˆ—ä¸­ï¼Œæ ¹èŠ‚ç‚¹å°†å·¦å³å­æ ‘åˆ†å¼€ã€‚
å¯ä»¥é€šè¿‡è¿™ç§æ–¹æ³•æ‰¾åˆ°å·¦å³å­æ ‘çš„ä¸­åºéå†åºåˆ—ã€‚ç„¶åï¼Œä½¿ç”¨é€’å½’åœ°å¤„ç†å·¦å³å­æ ‘æ¥æ„å»ºæ•´ä¸ªæ ‘ã€‚
"""

def build_tree(inorder, postorder):
    if not inorder or not postorder:
        return []

    root_val = postorder[-1]
    root_index = inorder.index(root_val)

    left_inorder = inorder[:root_index]
    right_inorder = inorder[root_index + 1:]

    left_postorder = postorder[:len(left_inorder)]
    right_postorder = postorder[len(left_inorder):-1]

    root = [root_val]
    root.extend(build_tree(left_inorder, left_postorder))
    root.extend(build_tree(right_inorder, right_postorder))

    return root


def main():
    inorder = input().strip()
    postorder = input().strip()
    preorder = build_tree(inorder, postorder)
    print(''.join(preorder))


if __name__ == "__main__":
    main()

```



```python
"""
å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ã€‚åœ¨è¿™ä¸ªé€’å½’å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å°†ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºå½“å‰çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶ååœ¨ä¸­åºéå†åºåˆ—ä¸­æ‰¾åˆ°è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼Œ
è¿™ä¸ªä½ç½®å°†ä¸­åºéå†åºåˆ—åˆ†ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘ã€‚
"""
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def buildTree(inorder, postorder):
    if not inorder or not postorder:
        return None

    # ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯å½“å‰çš„æ ¹èŠ‚ç‚¹
    root_val = postorder.pop()
    root = TreeNode(root_val)

    # åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®
    root_index = inorder.index(root_val)

    # æ„å»ºå³å­æ ‘å’Œå·¦å­æ ‘
    root.right = buildTree(inorder[root_index + 1:], postorder)
    root.left = buildTree(inorder[:root_index], postorder)

    return root


def preorderTraversal(root):
    result = []
    if root:
        result.append(root.val)
        result.extend(preorderTraversal(root.left))
        result.extend(preorderTraversal(root.right))
    return result


# è¯»å–è¾“å…¥
inorder = input().strip()
postorder = input().strip()

# æ„å»ºæ ‘
root = buildTree(list(inorder), list(postorder))

# è¾“å‡ºå‰åºéå†åºåˆ—
print(''.join(preorderTraversal(root)))
```







###### 2ï¼‰ç»ƒä¹ M22158: æ ¹æ®äºŒå‰æ ‘å‰ä¸­åºåºåˆ—å»ºæ ‘

http://cs101.openjudge.cn/practice/22158/

å‡è®¾äºŒå‰æ ‘çš„èŠ‚ç‚¹é‡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å­—æ¯éƒ½ä¸åŒã€‚

ç»™å®šäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—å’Œä¸­åºéå†åºåˆ—(é•¿åº¦å‡ä¸è¶…è¿‡26)ï¼Œè¯·è¾“å‡ºè¯¥äºŒå‰æ ‘çš„ååºéå†åºåˆ—

**è¾“å…¥**

å¤šç»„æ•°æ®
æ¯ç»„æ•°æ®2è¡Œï¼Œç¬¬ä¸€è¡Œæ˜¯å‰åºéå†åºåˆ—ï¼Œç¬¬äºŒè¡Œæ˜¯ä¸­åºéå†åºåˆ—

**è¾“å‡º**

å¯¹æ¯ç»„åºåˆ—å»ºæ ‘ï¼Œè¾“å‡ºè¯¥æ ‘çš„ååºéå†åºåˆ—

æ ·ä¾‹è¾“å…¥

```
DURPA
RUDPA
XTCNB
CTBNX
```

æ ·ä¾‹è¾“å‡º

```
RUAPD
CBNTX
```

æ¥æºï¼šéƒ­ç‚œ



The problem is asking to construct a binary tree from given preorder and inorder traversal sequences, and then output the postorder traversal sequence of the constructed tree.  

Here is a step-by-step plan:  
1.Create a TreeNode class to represent each node in the tree.
2.Create a function build_tree that takes the preorder and inorder sequences as input and returns the root of the constructed tree.
	The first character of the preorder sequence is the root of the tree.
	Find the position of the root in the inorder sequence.
	Recursively construct the left subtree using the left part of the inorder sequence and the corresponding part of the preorder sequence.
	Recursively construct the right subtree using the right part of the inorder sequence and the corresponding part of the preorder sequence.
3.Create a function postorder_traversal that takes the root of the tree as input and returns the postorder traversal sequence of the tree.
4.For each pair of preorder and inorder sequences, construct the tree and output the postorder traversal sequence.
Here is the Python code that implements this plan:

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_tree(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_value = preorder[0]
    root = TreeNode(root_value)
    root_index_inorder = inorder.index(root_value)
    root.left = build_tree(preorder[1:1+root_index_inorder], inorder[:root_index_inorder])
    root.right = build_tree(preorder[1+root_index_inorder:], inorder[root_index_inorder+1:])
    return root

def postorder_traversal(root):
    if root is None:
        return ''
    return postorder_traversal(root.left) + postorder_traversal(root.right) + root.value

while True:
    try:
        preorder = input().strip()
        inorder = input().strip()
        root = build_tree(preorder, inorder)
        print(postorder_traversal(root))
    except EOFError:
        break
```



###### 3ï¼‰ç»ƒä¹ M25145: çŒœäºŒå‰æ ‘ï¼ˆæŒ‰å±‚æ¬¡éå†ï¼‰

http://cs101.openjudge.cn/practice/25145/

ä¸€æ£µäºŒå‰æ ‘ï¼Œç»“ç‚¹éƒ½æ˜¯å¤§å†™è‹±æ–‡å­—æ¯ï¼Œä¸”ä¸é‡å¤ã€‚

ç»™å‡ºå®ƒçš„ä¸­åºéå†åºåˆ—å’Œååºéå†åºåˆ—ï¼Œæ±‚å…¶æŒ‰å±‚æ¬¡éå†çš„åºåˆ—ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°n, n <=30ï¼Œè¡¨ç¤ºæœ‰næ£µäºŒå‰æ ‘
æ¥ä¸‹æ¥æ¯ä¸¤è¡Œä»£è¡¨ä¸€æ£µäºŒå‰æ ‘ï¼Œç¬¬ä¸€è¡Œæ˜¯å…¶ä¸­åºéå†åºåˆ—ï¼Œç¬¬äºŒè¡Œæ˜¯ååºéå†åºåˆ—

**è¾“å‡º**

å¯¹æ¯æ£µäºŒå‰æ ‘è¾“å‡ºå…¶æŒ‰å±‚æ¬¡éå†åºåˆ—

æ ·ä¾‹è¾“å…¥

```
2
LZGD
LGDZ
BKTVQP
TPQVKB
```

æ ·ä¾‹è¾“å‡º

```
ZLDG
BKVTQP
```

æ¥æº: Guo Wei



```python
from collections import deque

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def build_tree(inorder, postorder):
    if inorder:
        root = Node(postorder.pop())
        root_index = inorder.index(root.data)
        root.right = build_tree(inorder[root_index+1:], postorder)
        root.left = build_tree(inorder[:root_index], postorder)
        return root

def level_order_traversal(root):
    if root is None:
        return []
    result = []
    queue = deque([root])
    while queue:
        node = queue.popleft()
        result.append(node.data)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return result

n = int(input())
for _ in range(n):
    inorder = list(input().strip())
    postorder = list(input().strip())
    root = build_tree(inorder, postorder)
    print(''.join(level_order_traversal(root)))
```



##### ç»ƒä¹ T20576: printExpï¼ˆé€†æ³¢å…°è¡¨è¾¾å¼å»ºæ ‘ï¼‰

http://cs101.openjudge.cn/practice/20576/

è¾“å‡ºä¸­ç¼€è¡¨è¾¾å¼ï¼ˆå»é™¤ä¸å¿…è¦çš„æ‹¬å·ï¼‰

**è¾“å…¥**

ä¸€ä¸ªå­—ä¸²

**è¾“å‡º**

ä¸€ä¸ªå­—ä¸²

æ ·ä¾‹è¾“å…¥

```
( not ( True or False ) ) and ( False or True and True )
```

æ ·ä¾‹è¾“å‡º

```
not ( True or False ) and ( False or True and True )
```



<mark>è¿™ä¸‰ä¸ªæ“ä½œç¬¦ï¼š`not`ï¼šä¼˜å…ˆçº§æœ€é«˜ï¼Œ`and`ï¼šå…¶æ¬¡ï¼Œ`or`ï¼šä¼˜å…ˆçº§æœ€ä½ã€‚</mark>

```python
class BinaryTree:
    def __init__(self, root, left=None, right=None):
        self.root = root
        self.leftChild = left
        self.rightChild = right

    def getrightchild(self):
        return self.rightChild

    def getleftchild(self):
        return self.leftChild

    def getroot(self):
        return self.root

def postorder(string):    #ä¸­ç¼€æ”¹åç¼€ Shunting yard algorightm
    opStack = []
    postList = []
    inList = string.split()
    prec = { '(': 0, 'or': 1,'and': 2,'not': 3}

    for word in inList:
        if word == '(':
            opStack.append(word)
        elif word == ')':
            topWord = opStack.pop()
            while topWord != '(':
                postList.append(topWord)
                topWord = opStack.pop()
        elif word == 'True' or word == 'False':
            postList.append(word)
        else:
            while opStack and prec[word] <= prec[opStack[-1]]:
                postList.append(opStack.pop())
            opStack.append(word)
    while opStack:
        postList.append(opStack.pop())
    return postList

def buildParseTree(infix):       #ä»¥åç¼€è¡¨è¾¾å¼ä¸ºåŸºç¡€å»ºæ ‘
    postList = postorder(infix)
    stack = []
    for word in postList:
        if word == 'not':
            newTree = BinaryTree(word)
            newTree.leftChild = stack.pop()
            stack.append(newTree)
        elif word == 'True' or word == 'False':
            stack.append(BinaryTree(word))
        else:
            right = stack.pop()
            left = stack.pop()
            newTree = BinaryTree(word)
            newTree.leftChild = left
            newTree.rightChild = right
            stack.append(newTree)
    currentTree = stack[-1]
    return currentTree

def printTree(parsetree: BinaryTree):
    if parsetree.getroot() == 'or':
        return printTree(parsetree.getleftchild()) + ['or'] + printTree(parsetree.getrightchild())
    elif parsetree.getroot() == 'not':
        return ['not'] + (
            ['('] + printTree(parsetree.getleftchild()) + [')']
            if parsetree.leftChild.getroot() not in ['True', 'False']
            else printTree(parsetree.getleftchild())
        )
    elif parsetree.getroot() == 'and':
        leftpart = (
            ['('] + printTree(parsetree.getleftchild()) + [')']
            if parsetree.leftChild.getroot() == 'or'
            else printTree(parsetree.getleftchild())
        )
        rightpart = (
            ['('] + printTree(parsetree.getrightchild()) + [')']
            if parsetree.rightChild.getroot() == 'or'
            else printTree(parsetree.getrightchild())
        )
        return leftpart + ['and'] + rightpart
    else:
        return [str(parsetree.getroot())]

def main():
    infix = input()
    Tree = buildParseTree(infix)
    print(' '.join(printTree(Tree)))

main()
```



`printTree`å‡½æ•°æ˜¯ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ª`BinaryTree`å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œç„¶åæ ¹æ®æ ‘çš„ç»“æ„å’ŒèŠ‚ç‚¹çš„å€¼ç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ã€‚

å‡½æ•°çš„å·¥ä½œæ–¹å¼å¦‚ä¸‹ï¼š

1. é¦–å…ˆï¼Œæ£€æŸ¥æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ã€‚æ ¹æ®å€¼çš„ä¸åŒï¼Œå‡½æ•°ä¼šæ‰§è¡Œä¸åŒçš„æ“ä½œã€‚

2. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"or"ï¼Œå‡½æ•°ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«æ¥å¤„ç†å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œç„¶åå°†ç»“æœåˆå¹¶ï¼Œå¹¶åœ¨ä¸¤ä¸ªç»“æœä¹‹é—´æ’å…¥"or"ã€‚

3. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"not"ï¼Œå‡½æ•°ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«æ¥å¤„ç†å·¦å­æ ‘ã€‚<mark>å¦‚æœå·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ä¸æ˜¯"True"æˆ–"False"ï¼Œåˆ™ä¼šåœ¨å·¦å­æ ‘çš„ç»“æœå‘¨å›´æ·»åŠ æ‹¬å·ã€‚</mark>

4. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"and"ï¼Œå‡½æ•°ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«æ¥å¤„ç†å·¦å­æ ‘å’Œå³å­æ ‘ã€‚<mark>å¦‚æœå·¦å­æ ‘æˆ–å³å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ä¸º"or"ï¼Œåˆ™ä¼šåœ¨ç›¸åº”å­æ ‘çš„ç»“æœå‘¨å›´æ·»åŠ æ‹¬å·ã€‚</mark>

5. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"True"æˆ–"False"ï¼Œå‡½æ•°ä¼šç›´æ¥è¿”å›ä¸€ä¸ªåŒ…å«è¯¥å€¼çš„åˆ—è¡¨ã€‚

6. æœ€åï¼Œå‡½æ•°ä¼šå°†ç”Ÿæˆçš„å­—ç¬¦ä¸²åˆ—è¡¨åˆå¹¶ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›ã€‚

> `printTree` å‡½æ•°çš„ç¡®æ˜¯è¿™ä¸ªç¨‹åºçš„å…³é”®éƒ¨åˆ†ï¼Œå®ƒè´Ÿè´£**æŠŠè¡¨è¾¾å¼æ ‘é‡æ–°è½¬æˆä¸­ç¼€è¡¨è¾¾å¼**ï¼Œè€Œä¸”åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­è¦**å»æ‰ä¸å¿…è¦çš„æ‹¬å·ï¼Œåªä¿ç•™å¿…è¦çš„æ‹¬å·**ï¼Œä»¥ä¿è¯è¡¨è¾¾å¼çš„ä¼˜å…ˆçº§æ­£ç¡®ã€‚
>
> æˆ‘ä»¬æ¥**ä¸€è¡Œè¡Œåˆ†æè¿™ä¸ªå‡½æ•°**ï¼Œå¹¶ä¸”ç»“åˆä¼˜å…ˆçº§è§„åˆ™æ¥è¯¦ç»†è§£é‡Šã€‚
>
> ---
>
> âœ… èƒŒæ™¯çŸ¥è¯†ï¼ˆéå¸¸é‡è¦ï¼‰
>
> æˆ‘ä»¬æœ‰ 3 ä¸ªæ“ä½œç¬¦ï¼š
>
> - `not`ï¼šä¼˜å…ˆçº§æœ€é«˜ï¼ˆ3ï¼‰
> - `and`ï¼šä¸­é—´ï¼ˆ2ï¼‰
> - `or`ï¼šæœ€ä½ï¼ˆ1ï¼‰
>
> æ‰€ä»¥å½“æˆ‘ä»¬é‡å»ºä¸­ç¼€è¡¨è¾¾å¼æ—¶ï¼Œå¦‚æœä½ä¼˜å…ˆçº§çš„æ“ä½œè¢«åµŒå¥—åœ¨é«˜ä¼˜å…ˆçº§çš„æ“ä½œé‡Œé¢ï¼Œé‚£å°±**éœ€è¦åŠ æ‹¬å·**æ¥ä¿æŒåŸæ¥çš„ä¼˜å…ˆé¡ºåºã€‚
>
> ---
>
> ğŸ’¡ å‡½æ•°ç­¾å
>
> ```python
> def printTree(parsetree: BinaryTree):
> ```
>
> è¿™æ˜¯ä¸€ä¸ªé€’å½’å‡½æ•°ã€‚æ¯æ¬¡è°ƒç”¨ä¼šå¤„ç†ä¸€ä¸ªå­æ ‘ï¼Œè¿”å›ä¸€ä¸ª**å­—ç¬¦ä¸²åˆ—è¡¨**ï¼ˆæœ€åç”¨ `' '.join()` ç»„åˆæˆç»“æœï¼‰ã€‚
>
> ---
>
> ğŸ§© æƒ…å†µ 1ï¼šå½“å‰èŠ‚ç‚¹æ˜¯ `or`
>
> ```python
> if parsetree.getroot() == 'or':
>     return printTree(parsetree.getleftchild()) + ['or'] + printTree(parsetree.getrightchild())
> ```
>
> - `or` æ˜¯æœ€ä½ä¼˜å…ˆçº§ï¼Œæ‰€ä»¥å®ƒ**æ°¸è¿œä¸ä¼šè¢«å…¶ä»–æ“ä½œåŒ…è£¹ä½**ï¼ˆä¸éœ€è¦åŠ æ‹¬å·ï¼‰
> - å·¦å³å­æ ‘åˆ†åˆ«å¤„ç†å°±å¥½ï¼Œä¸­é—´åŠ ä¸Š `'or'`
>
> ---
>
> ğŸ§© æƒ…å†µ 2ï¼šå½“å‰èŠ‚ç‚¹æ˜¯ `not`
>
> ```python
> elif parsetree.getroot() == 'not':
>     return ['not'] + (
>         ['('] + printTree(parsetree.getleftchild()) + [')']
>         if parsetree.leftChild.getroot() not in ['True', 'False']
>         else printTree(parsetree.getleftchild())
>     )
> ```
>
> - `not` æ˜¯å•ç›®æ“ä½œç¬¦ï¼ˆåªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼‰
>
> - å¦‚æœå®ƒçš„å­èŠ‚ç‚¹æ˜¯ `'True'` æˆ– `'False'`ï¼Œå°±ç›´æ¥å†™ï¼š
>
>   ```
>   not True
>   ```
>
> - ä½†å¦‚æœå­èŠ‚ç‚¹æ˜¯åƒ `True or False` è¿™æ ·çš„è¡¨è¾¾å¼ï¼Œéœ€è¦åŠ æ‹¬å·åŒ…ä½å®ƒï¼š
>
>   ```
>   not (True or False)
>   ```
>
> ğŸ‘‰ è¿™æ˜¯ä¸ºäº†é˜²æ­¢è¡¨è¾¾å¼ä¼˜å…ˆçº§å‡ºé”™ï¼
>
> ---
>
> ğŸ§© æƒ…å†µ 3ï¼šå½“å‰èŠ‚ç‚¹æ˜¯ `and`
>
> ```python
> elif parsetree.getroot() == 'and':
>     leftpart = (
>         ['('] + printTree(parsetree.getleftchild()) + [')']
>         if parsetree.leftChild.getroot() == 'or'
>         else printTree(parsetree.getleftchild())
>     )
>     rightpart = (
>         ['('] + printTree(parsetree.getrightchild()) + [')']
>         if parsetree.rightChild.getroot() == 'or'
>         else printTree(parsetree.getrightchild())
>     )
>     return leftpart + ['and'] + rightpart
> ```
>
> - `and` çš„ä¼˜å…ˆçº§é«˜äº `or`
>
> - å¦‚æœå®ƒçš„æŸä¸ªå­èŠ‚ç‚¹æ˜¯ `or`ï¼Œå°±å¿…é¡»åŠ æ‹¬å·ï¼š
>
>   ```
>   (A or B) and C
>   ```
>
> å¦åˆ™è¡¨è¾¾å¼ä¼˜å…ˆçº§å°±ä¼šé”™äº†ï¼
>
> **ä¾‹å­ï¼š**
>
> - æ­£ç¡®çš„ï¼š`(True or False) and True`
> - é”™è¯¯çš„ï¼š`True or False and True`ï¼ˆè¿™ä¸ªæ„æ€ä¸ä¸€æ ·ï¼‰
>
> ---
>
> ğŸ§© æƒ…å†µ 4ï¼šå¶å­èŠ‚ç‚¹ï¼ˆTrue æˆ– Falseï¼‰
>
> ```python
> else:
>     return [str(parsetree.getroot())]
> ```
>
> è¿™ä¸ªå°±æ˜¯é€’å½’åˆ°åº•äº†ï¼Œè¿”å›å¸ƒå°”å€¼ï¼ˆå­—ç¬¦ä¸²å½¢å¼ï¼‰
>
> ---
>
> ğŸ” æ€»ç»“ï¼šå¦‚ä½•åˆ¤æ–­åŠ ä¸åŠ æ‹¬å·ï¼Ÿ
>
> - `or` æœ€ä½ä¼˜å…ˆçº§ï¼Œä»ä¸åŠ æ‹¬å·ã€‚
> - `and` å¦‚æœæ“ä½œçš„æ˜¯ `or`ï¼Œè¦åŠ æ‹¬å·ã€‚
> - `not` å¦‚æœæ“ä½œçš„æ˜¯å¤æ‚è¡¨è¾¾å¼ï¼ˆä¸æ˜¯å¸ƒå°”å¸¸é‡ï¼‰ï¼Œè¦åŠ æ‹¬å·ã€‚
>
> ---
>
> âœ¨ä¸¾ä¸ªå®Œæ•´ä¾‹å­
>
> è¾“å…¥ï¼š
>
> ```plaintext
> ( not ( True or False ) ) and ( False or True and True )
> ```
>
> è¾“å‡ºï¼š
>
> ```plaintext
> not ( True or False ) and ( False or True and True )
> ```
>
> è¯´æ˜ï¼š
>
> - `not` æ“ä½œ `True or False` â†’ åŠ æ‹¬å· âœ…
> - `and` çš„å·¦å³ï¼š
>   - å·¦æ˜¯ `not (...)`ï¼šä¸éœ€è¦é¢å¤–æ‹¬å·
>   - å³æ˜¯ `False or True and True`ï¼ŒæŒ‰ä¼˜å…ˆçº§å°±æ˜¯ `False or (True and True)`ï¼Œä¸éœ€è¦é¢å¤–æ‹¬å·





### 4.3 éœå¤«æ›¼ç¼–ç Huffman code

> 2013-book-Data Structures And Algorithms In Python

åœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œè€ƒè™‘ä¸€ä¸ªé‡è¦çš„æ–‡æœ¬å¤„ç†ä»»åŠ¡ï¼šæ–‡æœ¬å‹ç¼©ã€‚åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªåœ¨æŸäº›å­—æ¯è¡¨ï¼ˆå¦‚ASCIIå­—ç¬¦é›†ï¼‰ä¸Šå®šä¹‰çš„å­—ç¬¦ä¸²Xï¼Œå¹¶å¸Œæœ›å°†å…¶é«˜æ•ˆåœ°ç¼–ç ä¸ºä¸€ä¸ªè¾ƒå°çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²Yï¼ˆä»…ä½¿ç”¨0å’Œ1å­—ç¬¦ï¼‰ã€‚æ–‡æœ¬å‹ç¼©åœ¨ä»»ä½•å¸Œæœ›å‡å°‘æ•°å­—é€šä¿¡å¸¦å®½çš„æƒ…å†µä¸‹éƒ½éå¸¸æœ‰ç”¨ï¼Œä»¥ä¾¿<mark>æœ€å°åŒ–ä¼ è¾“æ–‡æœ¬æ‰€éœ€çš„æ—¶é—´</mark>ã€‚åŒæ ·ï¼Œæ–‡æœ¬å‹ç¼©å¯¹äºæ›´é«˜æ•ˆåœ°å­˜å‚¨å¤§å‹æ–‡æ¡£ä¹Ÿå¾ˆæœ‰ç”¨ï¼Œä»è€Œ<mark>å…è®¸å›ºå®šå®¹é‡çš„å­˜å‚¨è®¾å¤‡åŒ…å«å°½å¯èƒ½å¤šçš„æ–‡æ¡£</mark>ã€‚

> In this section, we consider an important text-processing task, text compression. In this problem, we are given a string X defined over some alphabet, such as the ASCII  character sets, and we want to efficiently encode X into a small binary string Y (using only the characters 0 and 1). Text compression is useful in any situation where we wish to reduce bandwidth for digital communications, soas to minimize the time needed to transmit our text. Likewise, text compression is useful for storing large documents more efficiently, so as to allow a fixed-capacity storage device to contain as many documents as possible.

æœ¬èŠ‚æ¢è®¨çš„æ–‡æœ¬å‹ç¼©æ–¹æ³•æ˜¯**Huffman code**ã€‚åƒASCIIè¿™æ ·çš„æ ‡å‡†ç¼–ç æ–¹æ¡ˆä½¿ç”¨å›ºå®šé•¿åº¦çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²æ¥ç¼–ç å­—ç¬¦ï¼ˆåœ¨ä¼ ç»Ÿçš„æˆ–æ‰©å±•çš„ASCIIç³»ç»Ÿä¸­åˆ†åˆ«ä¸º7ä½æˆ–8ä½ï¼‰ã€‚Huffman codeé€šè¿‡<mark>ä½¿ç”¨è¾ƒçŸ­çš„ç å­—code-word å­—ç¬¦ä¸²ç¼–ç é«˜é¢‘å­—ç¬¦å’Œè¾ƒé•¿çš„ç å­—å­—ç¬¦ä¸²ç¼–ç ä½é¢‘å­—ç¬¦æ¥èŠ‚çœç©ºé—´ã€‚</mark>æ­¤å¤–ï¼ŒHuffman codeä½¿ç”¨ä¸“é—¨é’ˆå¯¹ç»™å®šå­—æ¯è¡¨ä¸Šçš„ä»»ä½•å­—ç¬¦ä¸²Xä¼˜åŒ–çš„å¯å˜é•¿åº¦ç¼–ç variable-length encodingã€‚è¿™ç§ä¼˜åŒ–åŸºäºå­—ç¬¦**é¢‘ç‡**çš„ä½¿ç”¨ï¼Œå¯¹äºæ¯ä¸ªå­—ç¬¦cï¼Œæœ‰ä¸€ä¸ªcåœ¨å­—ç¬¦ä¸²Xä¸­å‡ºç°æ¬¡æ•°çš„è®¡æ•°f(c)ã€‚

> The method for text compression explored in this section is the **Huffman code**. Standard encoding schemes, such as ASCII, use fixed-length binary strings to encode characters (with 7 or 8 bits in the traditional or extended ASCII systems, respectively). The Huffman code saves space over a fixed-length encoding by using short code-word strings to encode high-frequency characters and long code-word strings to encode low-frequency characters. Furthermore, the Huffman code uses a variable-length encoding specifically optimized for a given string X over any alphabet. The optimization is based on the use of character **frequencies**, where we have, for each character c, a count f(c) of the number of times c appears in the string X.

ä¸ºäº†ç¼–ç å­—ç¬¦ä¸²Xï¼Œå°†Xä¸­çš„æ¯ä¸ªå­—ç¬¦è½¬æ¢ä¸ºå¯å˜é•¿åº¦çš„ç å­—ï¼Œå¹¶æŒ‰é¡ºåºè¿æ¥æ‰€æœ‰è¿™äº›ç å­—ä»¥ç”ŸæˆXçš„ç¼–ç Yã€‚ä¸ºäº†é¿å…æ­§ä¹‰ï¼Œ<mark>åœ¨ç¼–ç ä¸­æ²¡æœ‰ä»»ä½•ç å­—æ˜¯å¦ä¸€ä¸ªç å­—çš„å‰ç¼€ã€‚è¿™æ ·çš„ç¼–ç è¢«ç§°ä¸º**å‰ç¼€ç¼–ç prefix code**ï¼Œå®ƒç®€åŒ–äº†å°†Yè§£ç å›Xçš„è¿‡ç¨‹</mark>ã€‚ï¼ˆå‚è§å›¾13.9ã€‚ï¼‰å³ä½¿æœ‰è¿™ä¸ªé™åˆ¶ï¼Œä½¿ç”¨å¯å˜é•¿åº¦å‰ç¼€ç æ‰€èƒ½è¾¾åˆ°çš„èŠ‚çœä¹Ÿæ˜¯éå¸¸æ˜¾è‘—çš„ï¼Œç‰¹åˆ«æ˜¯å¦‚æœå­—ç¬¦é¢‘ç‡å­˜åœ¨è¾ƒå¤§çš„å·®å¼‚æ—¶ï¼ˆå‡ ä¹æ¯ç§ä¹¦é¢è¯­è¨€çš„è‡ªç„¶è¯­è¨€æ–‡æœ¬éƒ½æ˜¯è¿™ç§æƒ…å†µï¼‰ã€‚

> To encode the string X, we convert each character in X to a variable-length code-word, and we concatenate all these code-words in order to produce the encoding Y for X. In order to avoid ambiguities, we insist that no code-word in our encoding be a prefix of another code-word in our encoding. Such a code is called a **prefix code**, and it simplifies the decoding of Y to retrieve X. (See Figure 13.9.) Even with this restriction, the savings produced by a variable-length prefix code can be significant, particularly if there is a wide variance in character frequencies (as is the case for natural language text in almost every written language).

ç”¨äºä¸ºXç”Ÿæˆæœ€ä¼˜å¯å˜é•¿åº¦å‰ç¼€ç çš„ Huffmanâ€™s algorithm åŸºäºæ„é€ è¡¨ç¤ºè¯¥ä»£ç çš„äºŒå‰æ ‘Tã€‚Tä¸­çš„æ¯æ¡è¾¹ä»£è¡¨ç å­—ä¸­çš„ä¸€ä½ï¼Œåˆ°å·¦å­©å­çš„è¾¹ä»£è¡¨â€œ0â€ï¼Œåˆ°å³å­©å­çš„è¾¹ä»£è¡¨â€œ1â€ã€‚æ¯ä¸ªå¶å­vä¸ç‰¹å®šå­—ç¬¦å…³è”ï¼Œè¯¥å­—ç¬¦çš„ç å­—ç”±ä»Tçš„æ ¹åˆ°vè·¯å¾„ä¸Šçš„è¾¹æ‰€å…³è”çš„æ¯”ç‰¹åºåˆ—å®šä¹‰ã€‚ï¼ˆå‚è§å›¾13.9ã€‚ï¼‰æ¯ä¸ªå¶å­véƒ½æœ‰ä¸€ä¸ªé¢‘ç‡f(v)ï¼Œå³ä¸vå…³è”çš„å­—ç¬¦åœ¨Xä¸­çš„é¢‘ç‡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬<mark>ç»™Tä¸­çš„æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹vèµ‹äºˆä¸€ä¸ªé¢‘ç‡f(v)ï¼Œå®ƒæ˜¯ä»¥vä¸ºæ ¹çš„å­æ ‘ä¸­æ‰€æœ‰å¶å­çš„é¢‘ç‡ä¹‹å’Œã€‚</mark>

> Huffmanâ€™s algorithm for producing an optimal variable-length prefix code for X is based on the construction of a binary tree T that represents the code. Each edge in T represents a bit in a code-word, with an edge to a left child representing a â€œ0â€ and an edge to a right child representing a â€œ1.â€ Each leaf v is associated with a specific character, and the code-word for that character is defined by the sequence of bits associated with the edges in the path from the root of T to v. (See Figure 13.9.) Each leaf v has a frequency, f(v), which is simply the frequency in X of the character associated with v. In addition, we give each internal node v in T a frequency, f(v), that is the sum of the frequencies of all the leaves in the subtree rooted at v.

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240309111247017.png" alt="image-20240309111247017" style="zoom: 50%;" />



å›¾13.9ï¼šè¾“å…¥å­—ç¬¦ä¸²X = "a fast runner need never be afraid of the dark" çš„ä¸€ä¸ªHuffman codeç¤ºä¾‹è¯´æ˜ï¼š(a) Xä¸­æ¯ä¸ªå­—ç¬¦çš„é¢‘ç‡ï¼›(b) å­—ç¬¦ä¸²Xçš„éœå¤«æ›¼æ ‘Tã€‚å­—ç¬¦cçš„ç¼–ç æ˜¯é€šè¿‡ä»Tçš„æ ¹èŠ‚ç‚¹è¿½è¸ªåˆ°å­˜å‚¨cçš„å¶å­èŠ‚ç‚¹çš„è·¯å¾„è·å¾—çš„ï¼Œå…¶ä¸­å·¦å­©å­è¾¹ç”¨0è¡¨ç¤ºï¼Œå³å­©å­è¾¹ç”¨1è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦â€œrâ€çš„ç¼–ç æ˜¯011ï¼Œè€Œå­—ç¬¦â€œhâ€çš„ç¼–ç æ˜¯10111ã€‚

> Figure 13.9: An illustration of an example Huffman code for the input string X = "a fast runner need never be afraid of the dark": (a) frequency of each character of X; (b) Huffman tree T for string X. The code for a character c is obtained by tracing the path from the root of T to the leaf where c is stored, and associating a left child with 0 and a right child with 1. For example, the code for â€œrâ€ is 011, and the code for â€œhâ€ is 10111.



#### 4.3.1 The Huffman Coding Algorithm

éœå¤«æ›¼ç¼–ç ç®—æ³•ä»å­—ç¬¦ä¸²Xä¸­æ¯ä¸ªç‹¬ç‰¹çš„dä¸ªå­—ç¬¦å¼€å§‹ï¼Œæ¯ä¸ªå­—ç¬¦éƒ½æ˜¯å•èŠ‚ç‚¹äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ç®—æ³•ä»¥ä¸€ç³»åˆ—çš„è½®æ¬¡è¿›è¡Œã€‚åœ¨æ¯ä¸€è½®ä¸­ï¼Œç®—æ³•å°†å…·æœ‰æœ€å°é¢‘ç‡çš„ä¸¤æ£µäºŒå‰æ ‘åˆå¹¶ä¸ºä¸€æ£µäºŒå‰æ ‘ã€‚æ­¤è¿‡ç¨‹é‡å¤è¿›è¡Œï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€æ£µæ ‘ä¸ºæ­¢ã€‚

éœå¤«æ›¼ç®—æ³•ä¸­**while**å¾ªç¯çš„æ¯æ¬¡è¿­ä»£å¯ä»¥ä½¿ç”¨å †è¡¨ç¤ºçš„ä¼˜å…ˆé˜Ÿåˆ—åœ¨O(logd)æ—¶é—´å†…å®ç°ã€‚æ­¤å¤–ï¼Œæ¯æ¬¡è¿­ä»£ä»Qä¸­å–å‡ºä¸¤ä¸ªèŠ‚ç‚¹å¹¶æ·»åŠ ä¸€ä¸ªæ–°èŠ‚ç‚¹è¿›å»ï¼Œè¿™ä¸ªè¿‡ç¨‹å°†åœ¨Qä¸­ä»…å‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¹‹å‰é‡å¤d âˆ’ 1æ¬¡ã€‚å› æ­¤ï¼Œè¯¥ç®—æ³•çš„è¿è¡Œæ—¶é—´ä¸ºO(n+ d logd)ã€‚è™½ç„¶åœ¨æ­¤æˆ‘ä»¬æ— æ³•å®Œæ•´åœ°è¯æ˜è¯¥ç®—æ³•çš„æ­£ç¡®æ€§ï¼Œä½†å…¶ç›´è§‰æ¥æºäºä¸€ä¸ªç®€å•çš„æƒ³æ³•â€”â€”ä»»ä½•æœ€ä¼˜ç¼–ç éƒ½å¯ä»¥è½¬æ¢æˆä¸€ä¸ªæœ€ä¼˜ç¼–ç ï¼Œåœ¨è¿™ä¸ªç¼–ç ä¸­ï¼Œé¢‘ç‡æœ€ä½çš„ä¸¤ä¸ªå­—ç¬¦aå’Œbçš„ç å­—åªåœ¨æœ€åä¸€ä¸ªæ¯”ç‰¹ä½ä¸Šæœ‰æ‰€ä¸åŒã€‚å¯¹äºç”¨å­—ç¬¦cæ›¿æ¢aå’Œbåçš„å­—ç¬¦ä¸²é‡å¤è¿™ä¸€è®ºè¯ï¼Œå¾—åˆ°å¦‚ä¸‹ç»“è®ºï¼š

**å‘½é¢˜**ï¼šéœå¤«æ›¼ç®—æ³•åœ¨$O(n+d logd)$æ—¶é—´å†…ä¸ºé•¿åº¦ä¸ºnä¸”åŒ…å«dä¸ªä¸åŒå­—ç¬¦çš„å­—ç¬¦ä¸²æ„é€ äº†ä¸€ä¸ªæœ€ä¼˜å‰ç¼€ç ã€‚

> The Huffman coding algorithm begins with each of the d distinct characters of the string X to encode being the root node of a single-node binary tree. The algorithm proceeds in a series of rounds. In each round, the algorithm takes the two binary
> trees with the smallest frequencies and merges them into a single binary tree. It repeats this process until only one tree is left. 
>
> Each iteration of the **while** loop in Huffmanâ€™s algorithm can be implemented in O(logd) time using a priority queue represented with a heap. In addition, each iteration takes two nodes out of Q and adds one in, a process that will be repeated d âˆ’ 1 times before exactly one node is left in Q. Thus, this algorithm runs in O(n+ d logd) time. Although a full justification of this algorithmâ€™s correctness is beyond our scope here, we note that its intuition comes from a simple ideaâ€”any
> optimal code can be converted into an optimal code in which the code-words for the two lowest-frequency characters, a and b, differ only in their last bit. Repeating the argument for a string with a and b replaced by a character c, gives the following:
>
> **Proposition** : Huffmanâ€™s algorithm constructs an optimal prefix code for a string of length n with d distinct characters in $O(n+d logd)$â€‹ time.



#### 4.3.2 The Greedy Method

éœå¤«æ›¼ç®—æ³•ç”¨äºæ„å»ºæœ€ä¼˜ç¼–ç æ˜¯è¢«ç§°ä¸º<mark>**è´ªå¿ƒæ³•**çš„ä¸€ç§ç®—æ³•è®¾è®¡æ¨¡å¼çš„åº”ç”¨ç¤ºä¾‹ã€‚è¿™ç§è®¾è®¡æ¨¡å¼è¢«åº”ç”¨äºä¼˜åŒ–é—®é¢˜ï¼Œå…¶ä¸­æˆ‘ä»¬è¯•å›¾åœ¨æ„å»ºæŸç§ç»“æ„çš„åŒæ—¶æœ€å°åŒ–æˆ–æœ€å¤§åŒ–è¯¥ç»“æ„çš„æŸäº›å±æ€§ã€‚</mark>

è´ªå¿ƒæ³•æ¨¡å¼çš„é€šç”¨å…¬å¼å‡ ä¹ä¸è›®åŠ›æ³•ä¸€æ ·ç®€å•ã€‚ä¸ºäº†ä½¿ç”¨è´ªå¿ƒæ³•è§£å†³ç»™å®šçš„ä¼˜åŒ–é—®é¢˜ï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ç³»åˆ—é€‰æ‹©æ¥æ¨è¿›ã€‚è¿™ä¸ªåºåˆ—ä»æŸä¸ªæ˜“äºç†è§£çš„åˆå§‹æ¡ä»¶å¼€å§‹ï¼Œå¹¶è®¡ç®—è¯¥åˆå§‹æ¡ä»¶çš„æˆæœ¬ã€‚ç„¶åï¼Œè¯¥æ¨¡å¼è¦æ±‚æˆ‘ä»¬é€šè¿‡è¯†åˆ«å½“å‰æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©ä¸­èƒ½å¤Ÿå¸¦æ¥æœ€ä½³æˆæœ¬æ”¹è¿›çš„å†³ç­–ï¼Œè¿­ä»£åœ°åšå‡ºé¢å¤–çš„é€‰æ‹©ã€‚è¿™ç§æ–¹æ³•å¹¶ä¸æ€»æ˜¯èƒ½å¯¼è‡´æœ€ä¼˜è§£ã€‚

ä½†ç¡®å®æœ‰ä¸€äº›é—®é¢˜æ˜¯é€‚ç”¨çš„ï¼Œè¿™ç±»é—®é¢˜è¢«ç§°ä¸ºå…·æœ‰**è´ªå¿ƒé€‰æ‹©æ€§è´¨**ã€‚è¿™ç§æ€§è´¨æ˜¯æŒ‡ï¼Œå¯ä»¥é€šè¿‡ä¸€ç³»åˆ—å±€éƒ¨æœ€ä¼˜é€‰æ‹©ï¼ˆå³æ¯æ¬¡é€‰æ‹©éƒ½æ˜¯åœ¨å½“æ—¶å¯ç”¨çš„å¯èƒ½æ€§ä¸­å½“å‰æœ€ä¼˜çš„ï¼‰ä»ä¸€ä¸ªå®šä¹‰æ˜ç¡®çš„åˆå§‹æ¡ä»¶å‡ºå‘ï¼Œè¾¾åˆ°å…¨å±€æœ€ä¼˜æ¡ä»¶ã€‚<mark>è®¡ç®—æœ€ä¼˜å¯å˜é•¿åº¦å‰ç¼€ç¼–ç çš„é—®é¢˜æ­£æ˜¯å…·æœ‰è´ªå¿ƒé€‰æ‹©æ€§è´¨çš„ä¸€ä¸ªä¾‹å­ã€‚</mark>

> Huffmanâ€™s algorithm for building an optimal encoding is an example application of an algorithmic design pattern called the greedy method. This design pattern is applied to optimization problems, where we are trying to construct some structure
> while minimizing or maximizing some property of that structure. 
>
> The general formula for the greedy method pattern is almost as simple as that for the brute-force method. In order to solve a given optimization problem using the greedy method, we proceed by a sequence of choices. The sequence starts from some well-understood starting condition, and computes the cost for that initial condition. The pattern then asks that we iteratively make additional choices by identifying the decision that achieves the best cost improvement from all of the choices that are currently possible. This approach does not always lead to an optimal solution.
>
> But there are several problems that it does work for, and such problems are said to possess the **greedy-choice** property. This is the property that a global optimal condition can be reached by a series of locally optimal choices (that is, choices that are each the current best from among the possibilities available at the time), starting from a well-defined starting condition. The problem of computing an optimal variable-length prefix code is just one example of a problem that possesses the greedy-choice property.
>



#### 4.3.3 å“ˆå¤«æ›¼ç¼–ç å®ç°

è¦æ„å»ºä¸€ä¸ªæœ€ä¼˜çš„å“ˆå¤«æ›¼ç¼–ç æ ‘ï¼Œé¦–å…ˆéœ€è¦å¯¹ç»™å®šçš„å­—ç¬¦åŠå…¶æƒå€¼è¿›è¡Œæ’åºã€‚ç„¶åï¼Œé€šè¿‡é‡å¤åˆå¹¶æƒå€¼æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆæˆ–å­æ ‘ï¼‰ï¼Œç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹éƒ½åˆå¹¶ä¸ºä¸€æ£µæ ‘ä¸ºæ­¢ã€‚

ä¸‹é¢æ˜¯ç”¨ Python å®ç°çš„ä»£ç ï¼š

```python
import heapq

class Node:
    def __init__(self, weight, char=None):
        self.weight = weight
        self.char = char
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def huffman_encoding(char_freq):
    heap = [Node(freq, char) for char, freq in char_freq.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(left.weight + right.weight, min(left.char, right.char))
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)

    return heap[0]

def external_path_length(node, depth=0):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        return depth * node.weight
    return (external_path_length(node.left, depth + 1) +
            external_path_length(node.right, depth + 1))

def main():
    char_freq = {'a': 3, 'b': 4, 'c': 5, 'd': 6, 'e': 8, 'f': 9, 'g': 11, 'h': 12}
    huffman_tree = huffman_encoding(char_freq)
    external_length = external_path_length(huffman_tree)
    print("The weighted external path length of the Huffman tree is:", external_length)

if __name__ == "__main__":
    main()

# Output:
# The weighted external path length of the Huffman tree is: 169
```

è¿™æ®µä»£ç é¦–å…ˆå®šä¹‰äº†ä¸€ä¸ª `Node` ç±»æ¥è¡¨ç¤ºå“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹ã€‚ç„¶åï¼Œä½¿ç”¨æœ€å°å †æ¥æ„å»ºå“ˆå¤«æ›¼æ ‘ï¼Œæ¯æ¬¡ä»å †ä¸­å–å‡ºä¸¤ä¸ªé¢‘ç‡æœ€å°çš„èŠ‚ç‚¹è¿›è¡Œåˆå¹¶ï¼Œç›´åˆ°å †ä¸­åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³å“ˆå¤«æ›¼æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚æ¥ç€ï¼Œä½¿ç”¨é€’å½’æ–¹æ³•è®¡ç®—å“ˆå¤«æ›¼æ ‘çš„<mark>å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ï¼ˆweighted external path lengthï¼‰</mark>ã€‚æœ€åï¼Œè¾“å‡ºè®¡ç®—å¾—åˆ°çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ã€‚

ä½ å¯ä»¥è¿è¡Œè¿™æ®µä»£ç æ¥å¾—åˆ°è¯¥æœ€ä¼˜äºŒå‰ç¼–ç æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ã€‚



#### 4.3.4 ç¼–ç¨‹é¢˜ç›®

##### ç¤ºä¾‹04080:Huffmanç¼–ç æ ‘

greedy, http://cs101.openjudge.cn/practice/04080/

æ„é€ ä¸€ä¸ªå…·æœ‰nä¸ªå¤–éƒ¨èŠ‚ç‚¹çš„æ‰©å……äºŒå‰æ ‘ï¼Œæ¯ä¸ªå¤–éƒ¨èŠ‚ç‚¹Kiæœ‰ä¸€ä¸ªWiå¯¹åº”ï¼Œä½œä¸ºè¯¥å¤–éƒ¨èŠ‚ç‚¹çš„æƒã€‚ä½¿å¾—è¿™ä¸ªæ‰©å……äºŒå‰æ ‘çš„å¶èŠ‚ç‚¹å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦æ€»å’Œæœ€å°ï¼š

â€‹                   Min( W1 * L1 + W2 * L2 + W3 * L3 + â€¦ + Wn * Ln)

Wi:æ¯ä¸ªèŠ‚ç‚¹çš„æƒå€¼ã€‚

Li:æ ¹èŠ‚ç‚¹åˆ°ç¬¬iä¸ªå¤–éƒ¨å¶å­èŠ‚ç‚¹çš„è·ç¦»ã€‚

ç¼–ç¨‹è®¡ç®—æœ€å°å¤–éƒ¨è·¯å¾„é•¿åº¦æ€»å’Œã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œå¤–éƒ¨èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚ç¬¬äºŒè¡Œè¾“å…¥nä¸ªæ•´æ•°ï¼Œä»£è¡¨å„ä¸ªå¤–éƒ¨èŠ‚ç‚¹çš„æƒå€¼ã€‚
2<=N<=100

**è¾“å‡º**

è¾“å‡ºæœ€å°å¤–éƒ¨è·¯å¾„é•¿åº¦æ€»å’Œã€‚

æ ·ä¾‹è¾“å…¥

```
4
1 1 3 5
```

æ ·ä¾‹è¾“å‡º

```
17
```





è¿™ä¸ªé—®é¢˜å…¶å®æ˜¯ä¸€ä¸ªç»å…¸çš„ **æœ€ä¼˜äºŒå‰æ ‘** æ„é€ é—®é¢˜ï¼Œä¹Ÿå«åš **éœå¤«æ›¼ç¼–ç ï¼ˆHuffman Codingï¼‰**ã€‚æˆ‘ä»¬è¦æ„é€ ä¸€æ£µ **æ‰©å……äºŒå‰æ ‘**ï¼ˆå³æ¯ä¸ªéå¶å­èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼‰ï¼Œä½¿å¾—æ‰€æœ‰ **å¶å­èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦å’Œæœ€å°**ã€‚

---

âœ… æ€è·¯ç®€è¿°ï¼ˆéœå¤«æ›¼ç®—æ³•ï¼‰ï¼š

æˆ‘ä»¬é€šè¿‡ä»¥ä¸‹è´ªå¿ƒç­–ç•¥æ„é€ ä¸€æ£µæœ€ä¼˜äºŒå‰æ ‘ï¼š

1. å°†æ‰€æœ‰æƒå€¼ä½œä¸ºåˆå§‹èŠ‚ç‚¹ï¼Œæ”¾å…¥ä¸€ä¸ªæœ€å°å †ä¸­ã€‚
2. é‡å¤æ‰§è¡Œä»¥ä¸‹æ“ä½œç›´åˆ°åªå‰©ä¸€ä¸ªèŠ‚ç‚¹ï¼š
   - ä»å †ä¸­å–å‡ºä¸¤ä¸ªæœ€å°æƒå€¼èŠ‚ç‚¹ `a` å’Œ `b`
   - åˆå¹¶ä¸ºä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼Œæƒå€¼ä¸º `a + b`
   - æŠŠè¿™ä¸ªæ–°èŠ‚ç‚¹çš„æƒå€¼åŠ å…¥å †
   - è¿™æ¬¡åˆå¹¶ä¼šäº§ç”Ÿä¸€ä¸ªä»£ä»·ï¼š`a + b`ï¼Œå°†å…¶åŠ å…¥æ€»è·¯å¾„ä»£ä»·ä¸­
3. æœ€ç»ˆç´¯åŠ çš„åˆå¹¶ä»£ä»·å³ä¸º **æœ€å°å¤–éƒ¨å¸¦æƒè·¯å¾„é•¿åº¦æ€»å’Œ**ã€‚

---

âœ… ç¤ºä¾‹è§£é‡Š

è¾“å…¥ï¼š
```
4
1 1 3 5
```

æ„é€ è¿‡ç¨‹ï¼š
- 1 + 1 â†’ æ–°èŠ‚ç‚¹æƒå€¼ 2ï¼Œæ€»æˆæœ¬ += 2
- 2 + 3 â†’ æ–°èŠ‚ç‚¹æƒå€¼ 5ï¼Œæ€»æˆæœ¬ += 5
- 5 + 5 â†’ æ–°èŠ‚ç‚¹æƒå€¼ 10ï¼Œæ€»æˆæœ¬ += 10
- æœ€ç»ˆæˆæœ¬ = 2 + 5 + 10 = **17**

---

âœ… Python å®ç°

```python
import heapq

def min_weighted_path_length(n, weights):
    heapq.heapify(weights)
    total = 0
    while len(weights) > 1:
        a = heapq.heappop(weights)
        b = heapq.heappop(weights)
        combined = a + b
        total += combined
        heapq.heappush(weights, combined)
    return total

# è¯»å–è¾“å…¥
n = int(input())
weights = list(map(int, input().split()))
print(min_weighted_path_length(n, weights))
```





##### ç»ƒä¹ T22161: å“ˆå¤«æ›¼ç¼–ç æ ‘

greedy, http://cs101.openjudge.cn/practice/22161/

æ ¹æ®å­—ç¬¦ä½¿ç”¨é¢‘ç‡(æƒå€¼)ç”Ÿæˆä¸€æ£µå”¯ä¸€çš„å“ˆå¤«æ›¼ç¼–ç æ ‘ã€‚ç”Ÿæˆæ ‘æ—¶éœ€è¦éµå¾ªä»¥ä¸‹è§„åˆ™ä»¥ç¡®ä¿å”¯ä¸€æ€§ï¼š

é€‰å–æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹åˆå¹¶æ—¶ï¼ŒèŠ‚ç‚¹æ¯”å¤§å°çš„è§„åˆ™æ˜¯:

1) æƒå€¼å°çš„èŠ‚ç‚¹ç®—å°ã€‚æƒå€¼ç›¸åŒçš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå­—ç¬¦é›†é‡Œæœ€å°å­—ç¬¦å°çš„ï¼Œç®—å°ã€‚

ä¾‹å¦‚ ï¼ˆ{'c','k'},12) å’Œ ({'b','z'},12)ï¼Œåè€…å°ã€‚

2) åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå°çš„èŠ‚ç‚¹å¿…é¡»ä½œä¸ºå·¦å­èŠ‚ç‚¹
3) è¿æ¥å·¦å­èŠ‚ç‚¹çš„è¾¹ä»£è¡¨0,è¿æ¥å³å­èŠ‚ç‚¹çš„è¾¹ä»£è¡¨1

ç„¶åå¯¹è¾“å…¥çš„ä¸²è¿›è¡Œç¼–ç æˆ–è§£ç 

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°nï¼Œè¡¨ç¤ºå­—ç¬¦é›†æœ‰nä¸ªå­—ç¬¦ã€‚
æ¥ä¸‹æ¥nè¡Œï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªå­—ç¬¦åŠå…¶ä½¿ç”¨é¢‘ç‡ï¼ˆæƒé‡ï¼‰ã€‚å­—ç¬¦éƒ½æ˜¯è‹±æ–‡å­—æ¯ã€‚
å†æ¥ä¸‹æ¥æ˜¯è‹¥å¹²è¡Œï¼Œæœ‰çš„æ˜¯å­—æ¯ä¸²ï¼Œæœ‰çš„æ˜¯01ç¼–ç ä¸²ã€‚

**è¾“å‡º**

å¯¹è¾“å…¥ä¸­çš„å­—æ¯ä¸²ï¼Œè¾“å‡ºè¯¥å­—ç¬¦ä¸²çš„ç¼–ç 
å¯¹è¾“å…¥ä¸­çš„01ä¸²,å°†å…¶è§£ç ï¼Œè¾“å‡ºåŸå§‹å­—ç¬¦ä¸²

æ ·ä¾‹è¾“å…¥

```
3
g 4
d 8
c 10
dc
110
```

æ ·ä¾‹è¾“å‡º

```
110
dc
```

æç¤º: æ•°æ®è§„æ¨¡å¾ˆå°ï¼Œä¸ç”¨åœ¨ä¹æ•ˆç‡

æ¥æº: éƒ­ç‚œ



å»ºæ ‘ï¼šä¸»è¦åˆ©ç”¨æœ€å°å †ï¼Œæ¯æ¬¡å–å‡ºweightæœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œweightç›¸åŠ ååˆ›å»ºèŠ‚ç‚¹ï¼Œè¿æ¥å·¦å³å­©å­ï¼Œå†å…¥å †ï¼Œç›´è‡³å †ä¸­åªå‰©ä¸€ä¸ªèŠ‚ç‚¹.

ç¼–ç ï¼šè·Ÿè¸ªæ¯ä¸€æ­¥èµ°çš„æ˜¯å·¦è¿˜æ˜¯å³ï¼Œç”¨0å’Œ1è¡¨ç¤ºï¼Œç›´è‡³é‡åˆ°æœ‰charå€¼çš„èŠ‚ç‚¹ï¼Œè¯´æ˜åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œå°†01å­—ä¸²æ·»åŠ è¿›å­—å…¸.

è§£ç ï¼šæ ¹æ®01å­—ä¸²å†³å®šèµ°å·¦è¿˜æ˜¯å³ï¼Œç›´è‡³é‡åˆ°æœ‰charå€¼çš„èŠ‚ç‚¹ï¼Œå°†charå€¼å–å‡º.

```python
import heapq

class Node:
    def __init__(self, weight, char=None):
        self.weight = weight
        self.char = char
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def build_huffman_tree(characters):
    heap = []
    for char, weight in characters.items():
        heapq.heappush(heap, Node(weight, char))

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        #merged = Node(left.weight + right.weight) #note: åˆå¹¶åï¼Œchar å­—æ®µé»˜è®¤å€¼æ˜¯ç©º
        merged = Node(left.weight + right.weight, min(left.char, right.char))
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)

    return heap[0]

def encode_huffman_tree(root):
    codes = {}

    def traverse(node, code):
        #if node.char:
        if node.left is None and node.right is None:
            codes[node.char] = code
        else:
            traverse(node.left, code + '0')
            traverse(node.right, code + '1')

    traverse(root, '')
    return codes

def huffman_encoding(codes, string):
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root, encoded_string):
    decoded = ''
    node = root
    for bit in encoded_string:
        if bit == '0':
            node = node.left
        else:
            node = node.right

        #if node.char:
        if node.left is None and node.right is None:
            decoded += node.char
            node = root
    return decoded

# è¯»å–è¾“å…¥
n = int(input())
characters = {}
for _ in range(n):
    char, weight = input().split()
    characters[char] = int(weight)

#string = input().strip()
#encoded_string = input().strip()

# æ„å»ºå“ˆå¤«æ›¼ç¼–ç æ ‘
huffman_tree = build_huffman_tree(characters)

# ç¼–ç å’Œè§£ç 
codes = encode_huffman_tree(huffman_tree)

strings = []
while True:
    try:
        line = input()
        strings.append(line)

    except EOFError:
        break

results = []
#print(strings)
for string in strings:
    if string[0] in ('0','1'):
        results.append(huffman_decoding(huffman_tree, string))
    else:
        results.append(huffman_encoding(codes, string))

for result in results:
    print(result)
```







#### 4.3.5 ç¬”è¯•é€‰æ‹©@20220621

**Q:** ç”¨ Huffman ç®—æ³•æ„é€ ä¸€ä¸ªæœ€ä¼˜äºŒå‰ç¼–ç æ ‘ï¼Œå¾…ç¼–ç çš„å­—ç¬¦æƒå€¼åˆ†åˆ«ä¸º{3ï¼Œ4ï¼Œ5ï¼Œ6ï¼Œ8ï¼Œ9ï¼Œ11ï¼Œ12}ï¼Œè¯·é—®è¯¥æœ€ä¼˜äºŒå‰ç¼–ç æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ä¸ºï¼ˆ B ï¼‰ã€‚ï¼ˆè¡¥å……è¯´æ˜ï¼š<mark>æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦å®šä¹‰ä¸ºæ ‘ä¸­æ‰€æœ‰å¶å­ç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¹‹å’Œï¼›å…¶ä¸­ï¼Œç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦å®šä¹‰ä¸ºè¯¥ç»“ç‚¹åˆ°æ ‘æ ¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ä¸è¯¥ç»“ç‚¹æƒå€¼çš„ä¹˜ç§¯</mark>ï¼‰
Aï¼š58	Bï¼š169	Cï¼š72	Dï¼š18



è§£é‡Šï¼šä¸ºäº†æ„é€ å“ˆå¤«æ›¼æ ‘ï¼Œæˆ‘ä»¬éµå¾ªä¸€ä¸ªé‡å¤çš„é€‰æ‹©è¿‡ç¨‹ï¼Œæ¯æ¬¡é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ­¢ã€‚æˆ‘ä»¬å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š

1. å°†ç»™å®šçš„æƒå€¼æ’åºï¼š{3, 4, 5, 6, 8, 9, 11, 12}ã€‚

2. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š3 å’Œ 4ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 7 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{5, 6, 7, 8, 9, 11, 12}ã€‚

3. å†æ¬¡é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š5 å’Œ 6ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 11 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{7, 8, 9, 11, 11, 12}ã€‚

4. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š7 å’Œ 8ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 15 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{9, 11, 11, 12, 15}ã€‚

5. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š9 å’Œ 11ï¼Œå°†å®ƒä»¬åˆå¹¶æˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 20 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{11, 12, 15, 20}ã€‚

6. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š11 å’Œ 12ï¼Œåˆå¹¶æˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 23 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{15, 20, 23}ã€‚

7. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š15 å’Œ 20ï¼Œåˆå¹¶æˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 35 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{23, 35}ã€‚

8. æœ€åï¼Œåˆå¹¶è¿™ä¸¤ä¸ªèŠ‚ç‚¹å¾—åˆ°æ ¹èŠ‚ç‚¹ï¼Œæƒå€¼ä¸º 23 + 35 = 58ã€‚

ç°åœ¨æˆ‘ä»¬å¯ä»¥è®¡ç®—å“ˆå¤«æ›¼æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰ã€‚

```
          (58)
        /      \
     (23)       (35)
     /  \       /   \
   (11)(12)  (20)    (15) 
             / \       / \
            (9)(11)   (7)(8)
                / \   / \  
               (5)(6)(3) (4)
```

ç°åœ¨è®©æˆ‘ä»¬è®¡ç®—æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ï¼š

- æƒå€¼ 3 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 3 * 4 = 12ã€‚
- æƒå€¼ 4 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 4 * 4 = 16ã€‚
- æƒå€¼ 5 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 5 * 4 = 20ã€‚
- æƒå€¼ 6 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 6 * 4 = 24ã€‚
- æƒå€¼ 9 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 3ï¼ŒWPLéƒ¨åˆ†ä¸º 9 * 3 = 27ã€‚
- æƒå€¼ 8 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 3ï¼ŒWPLéƒ¨åˆ†ä¸º 8 * 3 = 24ã€‚
- æƒå€¼ 11 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 2ï¼ŒWPLéƒ¨åˆ†ä¸º 11 * 2 = 22ã€‚
- æƒå€¼ 12 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 2ï¼ŒWPLéƒ¨åˆ†ä¸º 12 * 2 = 24ã€‚

å°†æ‰€æœ‰éƒ¨åˆ†çš„ WPL ç›¸åŠ ï¼Œæˆ‘ä»¬å¾—åˆ°æ•´æ£µå“ˆå¤«æ›¼æ ‘çš„ WPLï¼š

WPL = 12 + 16 + 20 + 24 + 27 + 24 + 22 + 24 = 169



# ä¸‰ã€BinaryHeap, BST, AVL, Disjoint Set

## 5 åˆ©ç”¨äºŒå‰å †å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—

æˆ‘ä»¬å­¦ä¹ è¿‡é˜Ÿåˆ—è¿™ä¸€å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ã€‚é˜Ÿåˆ—æœ‰ä¸€ä¸ªé‡è¦çš„å˜ä½“ï¼Œå«ä½œä¼˜å…ˆçº§é˜Ÿåˆ—ã€‚å’Œé˜Ÿåˆ—ä¸€æ ·ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ—ä»å¤´éƒ¨ç§»é™¤å…ƒç´ ï¼Œä¸è¿‡å…ƒç´ çš„é€»è¾‘é¡ºåºæ˜¯ç”±ä¼˜å…ˆçº§å†³å®šçš„ã€‚ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ åœ¨æœ€å‰ï¼Œä¼˜å…ˆçº§æœ€ä½çš„å…ƒç´ åœ¨æœ€åã€‚å› æ­¤ï¼Œå½“ä¸€ä¸ªå…ƒç´ å…¥é˜Ÿæ—¶ï¼Œå®ƒå¯èƒ½ç›´æ¥è¢«ç§»åˆ°ä¼˜å…ˆçº§é˜Ÿåˆ—çš„å¤´éƒ¨ã€‚åç»­å­¦ä¹ å›¾ç›¸å…³å†…å®¹æ—¶ä¼šçœ‹åˆ°ï¼Œ<mark>å¯¹äºä¸€äº›å›¾ç®—æ³•æ¥è¯´ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ—æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æ•°æ®ç»“æ„</mark>ã€‚

ä½ æˆ–è®¸å¯ä»¥æƒ³åˆ°ä¸€äº›ä½¿ç”¨æ’åºå‡½æ•°å’Œåˆ—è¡¨å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—çš„ç®€å•æ–¹æ³•ã€‚ä½†æ˜¯ï¼Œå°±æ—¶é—´å¤æ‚åº¦è€Œè¨€ï¼Œåˆ—è¡¨çš„æ’å…¥æ“ä½œæ˜¯ O(n) ï¼Œæ’åºæ“ä½œæ˜¯ $O(n\log n)$ ã€‚å…¶å®ï¼Œæ•ˆç‡å¯ä»¥æ›´é«˜ã€‚å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—çš„ç»å…¸æ–¹æ³•æ˜¯ä½¿ç”¨å«ä½œäºŒå‰å †çš„æ•°æ®ç»“æ„ã€‚<mark>äºŒå‰å †çš„å…¥é˜Ÿæ“ä½œå’Œå‡ºé˜Ÿæ“ä½œå‡å¯è¾¾åˆ° $O(\log n) $</mark>ã€‚

äºŒå‰å †å­¦èµ·æ¥å¾ˆæœ‰æ„æ€ï¼Œå®ƒç”»å‡ºæ¥å¾ˆåƒä¸€æ£µæ ‘ï¼Œä½†å®ç°æ—¶åªç”¨ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå†…éƒ¨è¡¨ç¤ºã€‚æˆ‘ä»¬å°†å®ç°æœ€å°å †ï¼ˆæœ€å°çš„å…ƒç´ ä¸€ç›´åœ¨é˜Ÿé¦–ï¼‰ã€‚

### 5.1 äºŒå‰å †çš„å®ç°

1. ç»“æ„æ€§

ä¸ºäº†ä½¿äºŒå‰å †èƒ½é«˜æ•ˆåœ°å·¥ä½œï¼Œæˆ‘ä»¬åˆ©ç”¨æ ‘çš„å¯¹æ•°æ€§è´¨æ¥è¡¨ç¤ºå®ƒã€‚ä¸ºäº†ä¿è¯å¯¹æ•°æ€§èƒ½ï¼Œå¿…é¡»ç»´æŒæ ‘çš„å¹³è¡¡ã€‚å¹³è¡¡çš„äºŒå‰æ ‘æ˜¯æŒ‡ï¼Œå…¶æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘å«æœ‰æ•°é‡å¤§è‡´ç›¸ç­‰çš„èŠ‚ç‚¹ã€‚åœ¨å®ç°äºŒå‰å †æ—¶ï¼Œæˆ‘ä»¬é€šè¿‡åˆ›å»ºä¸€æ£µ**å®Œå…¨äºŒå‰æ ‘complete binary tree**æ¥ç»´æŒæ ‘çš„å¹³è¡¡ã€‚<mark>åœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚ï¼Œå…¶ä»–æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½æ˜¯æ»¡çš„ã€‚</mark>åœ¨æœ€åº•å±‚ï¼Œæˆ‘ä»¬ä»å·¦å¾€å³å¡«å……èŠ‚ç‚¹ã€‚å›¾ 1 å±•ç¤ºäº†å®Œå…¨äºŒå‰æ ‘çš„ä¸€ä¸ªä¾‹å­ã€‚

![image](https://raw.githubusercontent.com/GMyhf/img/main/img/compTree.png)

<center>å›¾ 1 å®Œå…¨äºŒå‰æ ‘</center>



å®Œå…¨äºŒå‰æ ‘çš„å¦ä¸€ä¸ªæœ‰è¶£ä¹‹å¤„åœ¨äºï¼Œ<mark>å¯ä»¥ç”¨ä¸€ä¸ªåˆ—è¡¨æ¥è¡¨ç¤ºå®ƒ</mark>ï¼Œè€Œä¸éœ€è¦é‡‡ç”¨â€œåˆ—è¡¨ä¹‹åˆ—è¡¨â€æˆ–â€œèŠ‚ç‚¹ä¸å¼•ç”¨â€è¡¨ç¤ºæ³•ã€‚ç”±äºæ ‘æ˜¯å®Œå…¨çš„ï¼Œå› æ­¤å¯¹äºåœ¨åˆ—è¡¨ä¸­å¤„äºä½ç½® p çš„èŠ‚ç‚¹æ¥è¯´ï¼Œå®ƒçš„å·¦å­èŠ‚ç‚¹æ­£å¥½å¤„äºä½ç½® 2p+1ï¼›åŒç†ï¼Œå³å­èŠ‚ç‚¹å¤„äºä½ç½® 2p+2ã€‚è‹¥è¦æ‰¾åˆ°æ ‘ä¸­ä»»æ„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œåªéœ€ä½¿ç”¨ Python çš„æ•´æ•°é™¤æ³•å³å¯ã€‚ç»™å®šåˆ—è¡¨ä¸­ä½ç½® n å¤„çš„èŠ‚ç‚¹ï¼Œå…¶çˆ¶èŠ‚ç‚¹çš„ä½ç½®å°±æ˜¯ (n-1)//2ã€‚å›¾ 2 å±•ç¤ºäº†ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶ç»™å‡ºäº†åˆ—è¡¨è¡¨ç¤ºã€‚<mark>æ ‘çš„åˆ—è¡¨è¡¨ç¤º</mark>â€”â€”åŠ ä¸Šè¿™ä¸ªâ€œå®Œå…¨â€çš„ç»“æ„æ€§è´¨â€”â€”è®©æˆ‘ä»¬å¾—ä»¥é€šè¿‡ä¸€äº›ç®€å•çš„æ•°å­¦è¿ç®—éå†å®Œå…¨äºŒå‰æ ‘ã€‚æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œè¿™ä¹Ÿæœ‰åŠ©äºé«˜æ•ˆåœ°å®ç°äºŒå‰å †ã€‚

![image](https://runestone.academy/ns/books/published/pythonds3/_images/heapOrder.png)

<center>å›¾ 2 ä¸€æ£µå®Œå…¨äºŒå‰æ ‘åŠå…¶åˆ—è¡¨è¡¨ç¤º</center>



2. å †çš„æœ‰åºæ€§

æˆ‘ä»¬ç”¨æ¥å­˜å‚¨å †å…ƒç´ çš„æ–¹æ³•ä¾èµ–äºå †çš„æœ‰åºæ€§ã€‚ <mark>å †çš„æœ‰åºæ€§æ˜¯æŒ‡ï¼šå¯¹äºå †ä¸­ä»»æ„å…ƒç´  x åŠå…¶çˆ¶å…ƒç´  pï¼Œ p éƒ½ä¸å¤§äº xã€‚</mark>å›¾ 2 ä¹Ÿå±•ç¤ºå‡ºå®Œå…¨äºŒå‰æ ‘å…·å¤‡å †çš„æœ‰åºæ€§ã€‚

3. å †æ“ä½œ

é¦–å…ˆå®ç°äºŒå‰å †çš„æ„é€ æ–¹æ³•ã€‚æ—¢ç„¶ç”¨ä¸€ä¸ªåˆ—è¡¨å°±å¯ä»¥è¡¨ç¤ºæ•´ä¸ªäºŒå‰å †ï¼Œé‚£ä¹ˆæ„é€ æ–¹æ³•è¦åšçš„å°±æ˜¯åˆå§‹åŒ–è¿™ä¸ªåˆ—è¡¨ã€‚åˆ—è¡¨ heapList çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ 0ï¼Œå®ƒçš„å”¯ä¸€ç”¨é€”æ˜¯ä¸ºäº†ä½¿åç»­çš„æ–¹æ³•å¯ä»¥ä½¿ç”¨æ•´æ•°é™¤æ³•ã€‚

```python
class BinaryHeap:
    def __init__(self):
        self._heap = []
```

æ¥ä¸‹æ¥å®ç°insertæ–¹æ³•ã€‚å°†å…ƒç´ åŠ å…¥åˆ—è¡¨çš„æœ€ç®€å•ã€æœ€é«˜æ•ˆçš„æ–¹æ³•å°±æ˜¯å°†å…ƒç´ è¿½åŠ åˆ°åˆ—è¡¨çš„æœ«å°¾ã€‚è¿½åŠ æ“ä½œçš„ä¼˜ç‚¹åœ¨äºï¼Œå®ƒèƒ½ä¿è¯å®Œå…¨æ ‘çš„æ€§è´¨ï¼Œä½†ç¼ºç‚¹æ˜¯å¾ˆå¯èƒ½ä¼šç ´åå †çš„ç»“æ„æ€§è´¨ã€‚ä¸è¿‡å¯ä»¥å†™ä¸€ä¸ªæ–¹æ³•ï¼Œé€šè¿‡æ¯”è¾ƒæ–°å…ƒç´ ä¸å…¶çˆ¶å…ƒç´ æ¥é‡æ–°è·å¾—å †çš„ç»“æ„æ€§è´¨ã€‚å¦‚æœæ–°å…ƒç´ å°äºå…¶çˆ¶å…ƒç´ ï¼Œå°±å°†äºŒè€…äº¤æ¢ã€‚å›¾3å±•ç¤ºäº†å°†æ–°å…ƒç´ æ”¾åˆ°æ­£ç¡®ä½ç½®ä¸Šæ‰€éœ€çš„ä¸€ç³»åˆ—äº¤æ¢æ“ä½œã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/percUp.png" alt="image" style="zoom:67%;" />

<center>å›¾3 å°†æ–°å…ƒç´ å¾€ä¸Šç§»åˆ°æ­£ç¡®ä½ç½® Percolate the New Node up to Its Proper Position</center>

æ³¨æ„ï¼Œå°†å…ƒç´ å¾€ä¸Šç§»æ—¶ï¼Œå…¶å®æ˜¯åœ¨æ–°å…ƒç´ åŠå…¶çˆ¶å…ƒç´ ä¹‹é—´é‡å»ºå †çš„ç»“æ„æ€§è´¨ã€‚æ­¤å¤–ï¼Œä¹Ÿä¿ç•™äº†å…„å¼Ÿå…ƒç´ ä¹‹é—´çš„å †æ€§è´¨ã€‚å½“ç„¶ï¼Œå¦‚æœæ–°å…ƒç´ å¾ˆå°ï¼Œéœ€è¦ç»§ç»­å¾€ä¸Šä¸€å±‚äº¤æ¢ã€‚ä»£ç æ¸…å•2ç»™å‡ºäº†`_perc_up`æ–¹æ³•çš„ä»£ç ï¼Œè¯¥æ–¹æ³•å°†å…ƒç´ ä¸€ç›´æ²¿ç€æ ‘å‘ä¸Šç§»åŠ¨ï¼Œç›´åˆ°é‡è·å †çš„ç»“æ„æ€§è´¨ã€‚æˆ‘ä»¬ä½¿ç”¨æ•´æ•°é™¤æ³•è®¡ç®—ä»»æ„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚å°±å½“å‰èŠ‚ç‚¹è€Œè¨€ï¼Œçˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡å°±æ˜¯(å½“å‰èŠ‚ç‚¹çš„ä¸‹æ ‡-1)é™¤ä»¥2ã€‚

ä»£ç æ¸…å•2 

```python
def _perc_up(self, i):
    while (i - 1) // 2 >= 0:
        parent_idx = (i - 1) // 2
        if self._heap[i] < self._heap[parent_idx]:
            self._heap[i], self._heap[parent_idx] = (
                self._heap[parent_idx],
                self._heap[i],
            )
        i = parent_idx
```

ç°åœ¨å‡†å¤‡å¥½ç¼–å†™insertæ–¹æ³•äº†ã€‚ä»£ç æ¸…å•3ç»™å‡ºäº†è¯¥æ–¹æ³•çš„Pythonä»£ç ã€‚å…¶å®ï¼Œinsertæ–¹æ³•çš„å¤§éƒ¨åˆ†å·¥ä½œæ˜¯ç”± `_perc_upæ–¹`æ³•å®Œæˆçš„ã€‚å½“å…ƒç´ è¢«è¿½åŠ åˆ°æ ‘ä¸­ä¹‹åï¼Œ`_perc_up`æ–¹æ³•å°†å…¶ç§»åˆ°æ­£ç¡®çš„ä½ç½®ã€‚

ä»£ç æ¸…å•3

```python
def insert(self, item):
    self._heap.append(item)
    self._perc_up(len(self._heap) - 1)
```

æ­£ç¡®å®šä¹‰insertæ–¹æ³•åï¼Œå°±å¯ä»¥ç¼–å†™deleteæ–¹æ³•ã€‚æ—¢ç„¶å †çš„æœ‰åºæ€§è´¨è¦æ±‚æ ¹èŠ‚ç‚¹æ˜¯æ ‘çš„æœ€å°å…ƒç´ ï¼Œé‚£ä¹ˆæŸ¥æ‰¾æœ€å°å€¼å°±å¾ˆç®€å•ã€‚deleteæ–¹æ³•çš„éš¾ç‚¹åœ¨äºï¼Œå¦‚ä½•åœ¨ç§»é™¤æ ¹èŠ‚ç‚¹ä¹‹åé‡è·å †çš„ç»“æ„æ€§è´¨å’Œæœ‰åºæ€§ã€‚<mark>å¯ä»¥åˆ†ä¸¤æ­¥é‡å»ºå †ã€‚ç¬¬ä¸€æ­¥ï¼Œå–å‡ºåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå°†å…¶ç§»åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®ã€‚ç§»åŠ¨æœ€åä¸€ä¸ªå…ƒç´ ä¿è¯äº†å †çš„ç»“æ„æ€§è´¨ï¼Œä½†å¯èƒ½ä¼šç ´åäºŒå‰å †çš„æœ‰åºæ€§ã€‚ç¬¬äºŒæ­¥ï¼Œå°†æ–°çš„æ ¹èŠ‚ç‚¹æ²¿ç€æ ‘æ¨åˆ°æ­£ç¡®çš„ä½ç½®ï¼Œä»¥é‡è·å †çš„æœ‰åºæ€§ã€‚å›¾4å±•ç¤ºäº†å°†æ–°çš„æ ¹èŠ‚ç‚¹ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®æ‰€éœ€çš„ä¸€ç³»åˆ—äº¤æ¢æ“ä½œã€‚</mark>

> äºŒå‰å †BinHeapï¼Œæ˜æ˜¾å¯ä»¥æ’åºHeapsortï¼Œæ ‘çš„ç‰¹ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸å½’å¹¶æ’åºMergesortä¸€è‡´ã€‚å–æœ€å°å…ƒç´ åï¼Œä¸ºäº†æ¢å¤æœ‰åºæ€§ï¼Œå †é¡¶ä¸åˆ—è¡¨æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ï¼Œè¿™ç§è¿œè·ç¦»çš„äº¤æ¢ï¼Œè‡ªç„¶æ˜¯ ä¸ç¨³å®šNoStable çš„æ’åºã€‚
>
> 
>
> |    Name    |  Best   | Average |  Worst  | Memory | Stable |  Method   |                         Other notes                          |
> | :--------: | :-----: | :-----: | :-----: | :----: | :----: | :-------: | :----------------------------------------------------------: |
> |  Heapsort  | $nlogn$ | $nlogn$ | $nlogn$ |   1    |   No   | Selection |                                                              |
> | Merge sort | $nlogn$ | $nlogn$ | $nlogn$ |  *n*   |  Yes   |  Merging  | Highly parallelizable (up to *O*(log *n*) using the Three Hungarian's Algorithm) |
>
> 



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/percDown.png" alt="image" style="zoom:67%;" />



<center>å›¾4 Percolating the Root Node down the Tree</center>

ä¸ºäº†ç»´æŠ¤å †çš„é¡ºåºæ€§è´¨ï¼Œæˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯å°†æ ¹èŠ‚ç‚¹ä¸å…¶å°äºæ ¹èŠ‚ç‚¹çš„è¾ƒå°å­èŠ‚ç‚¹äº¤æ¢ã€‚åœ¨æœ€åˆçš„äº¤æ¢ä¹‹åï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé‡å¤è¿™ä¸€äº¤æ¢è¿‡ç¨‹ï¼Œæ¶‰åŠæŸä¸ªèŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°è¯¥èŠ‚ç‚¹è¢«äº¤æ¢åˆ°æ ‘ä¸­çš„æŸä¸ªä½ç½®ï¼Œåœ¨è¿™ä¸ªä½ç½®ä¸Šå®ƒå·²ç»å°äºå…¶ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚å‘ä¸‹æ¸—é€èŠ‚ç‚¹çš„ä»£ç å¯ä»¥åœ¨æ¸…å•4ä¸­çš„ `_perc_down` å’Œ `_get_min_child` æ–¹æ³•ä¸­æ‰¾åˆ°ã€‚

ä»£ç æ¸…å•4

```python
def _perc_down(self, i):
    while 2 * i + 1 < len(self._heap):
        sm_child = self._get_min_child(i)
        if self._heap[i] > self._heap[sm_child]:
            self._heap[i], self._heap[sm_child] = (
                self._heap[sm_child],
                self._heap[i],
            )
        else:
            break
        i = sm_child

def _get_min_child(self, i):
    if 2 * i + 2 > len(self._heap) - 1:
        return 2 * i + 1
    if self._heap[2 * i + 1] < self._heap[2 * i + 2]:
        return 2 * i + 1
    return 2 * i + 2
```



deleteæ–¹æ³•å¦‚ä»£ç æ¸…å•5æ‰€ç¤ºã€‚åŒæ ·ï¼Œä¸»è¦å·¥ä½œä¹Ÿç”±è¾…åŠ©å‡½æ•°å®Œæˆã€‚æœ¬ä¾‹ä¸­çš„è¾…åŠ©å‡½æ•°æ˜¯`_perc_down`ã€‚

ä»£ç æ¸…å•5

```python
def delete(self):
    self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]
    result = self._heap.pop()
    self._perc_down(0)
    return result
```



ä¸ºäº†ç»“æŸæˆ‘ä»¬å¯¹äºŒå‰å †çš„è®¨è®ºï¼Œæˆ‘ä»¬å°†æ¢è®¨ä¸€ç§ä»é”®å€¼åˆ—è¡¨æ„å»ºæ•´ä¸ªå †çš„æ–¹æ³•ã€‚ä½ å¯èƒ½é¦–å…ˆæƒ³åˆ°çš„æ–¹æ³•å¦‚ä¸‹ï¼šç»™å®šä¸€ä¸ªé”®å€¼åˆ—è¡¨ï¼Œä½ å¯ä»¥é€šè¿‡é€ä¸ªæ’å…¥æ¯ä¸ªé”®æ¥è½»æ¾æ„å»ºä¸€ä¸ªå †ã€‚ç”±äºä½ ä»ä¸€ä¸ªç©ºåˆ—è¡¨å¼€å§‹ï¼Œå®ƒæ˜¯æœ‰åºçš„ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ä»¥å¤§çº¦ $ O(\log n) $ çš„æ“ä½œä»£ä»·æ‰¾åˆ°æ’å…¥ä¸‹ä¸€ä¸ªé”®çš„æ­£ç¡®ä½ç½®ã€‚ç„¶è€Œï¼Œè¦è®°ä½ï¼Œåœ¨åˆ—è¡¨ä¸­é—´æ’å…¥ä¸€ä¸ªå…ƒç´ å¯èƒ½éœ€è¦ $ O(n) $ æ“ä½œæ¥ç§»åŠ¨åˆ—è¡¨ä¸­çš„å…¶ä½™å…ƒç´ ï¼Œä»¥ä¸ºæ–°é”®è…¾å‡ºç©ºé—´ã€‚å› æ­¤ï¼Œå°†æ‰€æœ‰é”®æ’å…¥å †ä¸­æ€»å…±éœ€è¦ $ O(n \log n) $ æ“ä½œã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä»ä¸€ä¸ªå®Œæ•´çš„åˆ—è¡¨å¼€å§‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨ $ O(n) $ æ“ä½œå†…æ„å»ºæ•´ä¸ªå †ã€‚æ¸…å•6å±•ç¤ºäº†æ„å»ºæ•´ä¸ªå †çš„ä»£ç ã€‚

> å¦‚æœä»å®Œæ•´çš„åˆ—è¡¨å¼€å§‹ï¼Œæ„å»ºæ•´ä¸ªå †åªéœ€O(n) ï¼Œhttps://oi-wiki.org/ds/binary-heap/ æœ‰è¯æ˜ã€‚
>
> æ³¨æ„åˆ°å¶èŠ‚ç‚¹æ— éœ€è°ƒæ•´ï¼Œå› æ­¤å¯ä»åºåˆ—çº¦ ![n/2](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) çš„ä½ç½®å¼€å§‹è°ƒæ•´ï¼Œå¯å‡å°‘éƒ¨åˆ†å¸¸æ•°ä½†ä¸å½±å“å¤æ‚åº¦ã€‚ä¹‹æ‰€ä»¥èƒ½ ![O(n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) å»ºå †ï¼Œæ˜¯å› ä¸ºå †æ€§è´¨å¾ˆå¼±ï¼ŒäºŒå‰å †å¹¶ä¸æ˜¯å”¯ä¸€çš„ã€‚è¦æ˜¯åƒæ’åºé‚£æ ·çš„å¼ºæ¡ä»¶å°±éš¾è¯´äº†ã€‚

ä»£ç æ¸…å•6

```python
    def heapify(self, not_a_heap):
        self._heap = not_a_heap[:]
        i = len(self._heap) // 2 - 1    # è¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹
        while i >= 0:
            self._perc_down(i)
            i = i - 1
```



å›¾5å±•ç¤ºäº†buildHeapæ–¹æ³•è¿›è¡Œçš„äº¤æ¢è¿‡ç¨‹ï¼Œå®ƒå°†å„èŠ‚ç‚¹ä»æœ€åˆçŠ¶æ€ç§»åˆ°å„è‡ªçš„æ­£ç¡®ä½ç½®ä¸Šã€‚å°½ç®¡ä»æ ‘çš„ä¸­é—´å¼€å§‹ï¼Œå‘æ ¹çš„æ–¹å‘æ“ä½œï¼Œä½†æ˜¯percDownæ–¹æ³•ä¿è¯äº†æœ€å¤§çš„èŠ‚ç‚¹æ€»æ˜¯æ²¿ç€æ ‘å‘ä¸‹ç§»åŠ¨ã€‚<u>åœ¨è¿™æ£µå®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œè¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ²¡æœ‰ä»»ä½•å­èŠ‚ç‚¹</u>ã€‚å½“i = 1æ—¶ï¼Œä»æ ‘çš„æ ¹èŠ‚ç‚¹å¾€ä¸‹ç§»ï¼Œå¯èƒ½éœ€è¦ç»è¿‡å¤šæ¬¡äº¤æ¢ã€‚å¦‚ä½ æ‰€è§ï¼Œ9å…ˆè¢«ç§»å‡ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åpercDownä¼šæ²¿ç€æ ‘æ£€æŸ¥å­èŠ‚ç‚¹ï¼Œä»¥ç¡®ä¿å°½é‡å°†å®ƒå¾€ä¸‹ç§»ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œ9çš„ç¬¬2æ¬¡äº¤æ¢å¯¹è±¡æ˜¯3ã€‚è¿™æ ·ä¸€æ¥ï¼Œ9å°±ç§»åˆ°äº†æ ‘çš„åº•å±‚ï¼Œä¸éœ€è¦å†åšäº¤æ¢äº†ã€‚æ¯”è¾ƒä¸€ç³»åˆ—äº¤æ¢æ“ä½œåçš„åˆ—è¡¨è¡¨ç¤ºå°†æœ‰åŠ©äºç†è§£ï¼Œå¦‚å›¾5æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/buildheap.png" alt="image" style="zoom:67%;" />

<center>å›¾5 æ ¹æ®åˆ—è¡¨[9, 6, 5, 2, 3]æ„å»ºå †</center>



```python
class BinaryHeap:
    def __init__(self):
        self._heap = []

    def _perc_up(self, i):
        while (i - 1) // 2 >= 0:
            parent_idx = (i - 1) // 2
            if self._heap[i] < self._heap[parent_idx]:
                self._heap[i], self._heap[parent_idx] = (
                    self._heap[parent_idx],
                    self._heap[i],
                )
            i = parent_idx

    def insert(self, item):
        self._heap.append(item)
        self._perc_up(len(self._heap) - 1)

    def _perc_down(self, i):
        while 2 * i + 1 < len(self._heap):
            sm_child = self._get_min_child(i)
            if self._heap[i] > self._heap[sm_child]:
                self._heap[i], self._heap[sm_child] = (
                    self._heap[sm_child],
                    self._heap[i],
                )
            else:
                break
            i = sm_child

    def _get_min_child(self, i):
        if 2 * i + 2 > len(self._heap) - 1:
            return 2 * i + 1
        if self._heap[2 * i + 1] < self._heap[2 * i + 2]:
            return 2 * i + 1
        return 2 * i + 2

    def delete(self):
        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]
        result = self._heap.pop()
        self._perc_down(0)
        return result

    def heapify(self, not_a_heap):
        self._heap = not_a_heap[:]
        i = len(self._heap) // 2 - 1    # è¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹
        while i >= 0:
            print(f'i = {i}, {self._heap}')
            self._perc_down(i)
            i = i - 1


bh = BinaryHeap()
bh.heapify([9, 5, 6, 2, 3])
"""
i = 1, [9, 5, 6, 2, 3]
i = 0, [9, 2, 6, 5, 3]
"""

for _ in range(len(bh._heap)):
    print(bh.delete())
"""
2
3
5
6
9
"""
```



<mark>æ„å»ºå †çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n)</mark>ï¼Œè¿™ä¹ä¸€å¬å¯èƒ½å¾ˆéš¾ç†è§£ã€‚ä¸è¿‡ï¼Œè¦ç‚¹åœ¨äºï¼Œå› å­log næ˜¯ç”±æ ‘çš„é«˜åº¦å†³å®šçš„ã€‚åœ¨heapifyçš„å¤§éƒ¨åˆ†å·¥ä½œä¸­ï¼Œæ ‘çš„é«˜åº¦ä¸è¶³log nã€‚



åˆ©ç”¨å»ºå †çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)è¿™ä¸€ç‚¹ï¼Œå¯ä»¥æ„é€ ä¸€ä¸ªä½¿ç”¨å †ä¸ºåˆ—è¡¨æ’åºçš„ç®—æ³•ï¼Œä½¿å®ƒçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n\log n)$ã€‚





### 5.2 ç¼–ç¨‹é¢˜ç›®

#### ç¤ºä¾‹M04078: å®ç°å †ç»“æ„

http://cs101.openjudge.cn/practice/04078/

å®šä¹‰ä¸€ä¸ªæ•°ç»„ï¼Œåˆå§‹åŒ–ä¸ºç©ºã€‚åœ¨æ•°ç»„ä¸Šæ‰§è¡Œä¸¤ç§æ“ä½œï¼š

1ã€å¢æ·»1ä¸ªå…ƒç´ ï¼ŒæŠŠ1ä¸ªæ–°çš„å…ƒç´ æ”¾å…¥æ•°ç»„ã€‚

2ã€è¾“å‡ºå¹¶åˆ é™¤æ•°ç»„ä¸­æœ€å°çš„æ•°ã€‚

ä½¿ç”¨å †ç»“æ„å®ç°ä¸Šè¿°åŠŸèƒ½çš„é«˜æ•ˆç®—æ³•ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œä»£è¡¨æ“ä½œçš„æ¬¡æ•°ã€‚
æ¯æ¬¡æ“ä½œé¦–å…ˆè¾“å…¥ä¸€ä¸ªæ•´æ•°typeã€‚
å½“type=1ï¼Œå¢æ·»æ“ä½œï¼Œæ¥ç€è¾“å…¥ä¸€ä¸ªæ•´æ•°uï¼Œä»£è¡¨è¦æ’å…¥çš„å…ƒç´ ã€‚
å½“type=2ï¼Œè¾“å‡ºåˆ é™¤æ“ä½œï¼Œè¾“å‡ºå¹¶åˆ é™¤æ•°ç»„ä¸­æœ€å°çš„å…ƒç´ ã€‚
1<=n<=100000ã€‚

**è¾“å‡º**

æ¯æ¬¡åˆ é™¤æ“ä½œè¾“å‡ºè¢«åˆ é™¤çš„æ•°å­—ã€‚

æ ·ä¾‹è¾“å…¥

```
4
1 5
1 1
1 7
2
```

æ ·ä¾‹è¾“å‡º

```
1
```

æç¤º

æ¯ç»„æµ‹è¯•æ•°æ®çš„å¤æ‚åº¦ä¸ºO(nlogn)çš„ç®—æ³•æ‰èƒ½é€šè¿‡æœ¬æ¬¡ï¼Œå¦åˆ™ä¼šè¿”å›TLE(è¶…æ—¶)
éœ€è¦ä½¿ç”¨æœ€å°å †ç»“æ„æ¥å®ç°æœ¬é¢˜çš„ç®—æ³•



è¿™é¢˜ç›®æœ¬æ„æ˜¯ç»ƒä¹ è‡ªå·±å†™ä¸ªBinaryHeapã€‚å½“ç„¶æœºè€ƒæ—¶å€™ï¼Œå¦‚æœé‡åˆ°è¿™æ ·é¢˜ç›®ï¼Œç›´æ¥import heapqã€‚

æ‰‹æ“æ ˆã€é˜Ÿåˆ—ã€å †ã€AVLç­‰ï¼Œè€ƒè¯•å‰éœ€è¦æ“ä¸ªéã€‚

```python
class BinaryHeap:
    def __init__(self):
        self._heap = []

    def _perc_up(self, i):
        while (i - 1) // 2 >= 0:
            parent_idx = (i - 1) // 2
            if self._heap[i] < self._heap[parent_idx]:
                self._heap[i], self._heap[parent_idx] = (
                    self._heap[parent_idx],
                    self._heap[i],
                )
            i = parent_idx

    def insert(self, item):
        self._heap.append(item)
        self._perc_up(len(self._heap) - 1)

    def _perc_down(self, i):
        while 2 * i + 1 < len(self._heap):
            sm_child = self._get_min_child(i)
            if self._heap[i] > self._heap[sm_child]:
                self._heap[i], self._heap[sm_child] = (
                    self._heap[sm_child],
                    self._heap[i],
                )
            else:
                break
            i = sm_child

    def _get_min_child(self, i):
        if 2 * i + 2 > len(self._heap) - 1:
            return 2 * i + 1
        if self._heap[2 * i + 1] < self._heap[2 * i + 2]:
            return 2 * i + 1
        return 2 * i + 2

    def delete(self):
        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]
        result = self._heap.pop()
        self._perc_down(0)
        return result

    def heapify(self, not_a_heap):
        self._heap = not_a_heap[:]
        i = len(self._heap) // 2 - 1    # è¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹
        while i >= 0:
            #print(f'i = {i}, {self._heap}')
            self._perc_down(i)
            i = i - 1



n = int(input().strip())
bh = BinaryHeap()
for _ in range(n):
    inp = input().strip()
    if inp[0] == '1':
        bh.insert(int(inp.split()[1]))
    else:
        print(bh.delete())
```



#### æ™´é—®9.7: å‘ä¸‹è°ƒæ•´æ„å»ºå¤§é¡¶å †

https://sunnywhy.com/sfbj/9/7

ç°æœ‰ä¸ªä¸åŒçš„æ­£æ•´æ•°ï¼Œå°†å®ƒä»¬æŒ‰å±‚åºç”Ÿæˆå®Œå…¨äºŒå‰æ ‘ï¼Œç„¶åä½¿ç”¨**å‘ä¸‹è°ƒæ•´**çš„æ–¹å¼æ„å»ºä¸€ä¸ªå®Œæ•´çš„å¤§é¡¶å †ã€‚æœ€åæŒ‰å±‚åºè¾“å‡ºå †ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°$n (1 \le n \le 10^3)$ï¼Œè¡¨ç¤ºæ­£æ•´æ•°çš„ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œ n ä¸ªæ•´æ•°$a_i (1 \le a_i \le 10^4) $â€‹ï¼Œè¡¨ç¤ºæ­£æ•´æ•°åºåˆ—ã€‚

**è¾“å‡º**

è¾“å‡º n ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå †çš„å±‚åºåºåˆ—ï¼Œä¸­é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥

```
6
3 2 6 5 8 7
```

è¾“å‡º

```
8 5 7 3 2 6
```

è§£é‡Š

è°ƒæ•´å‰çš„å®Œå…¨äºŒå‰æ ‘å’Œè°ƒæ•´åçš„å †å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403210116556.png" alt="å‘ä¸‹è°ƒæ•´æ„å»ºå¤§é¡¶å †.png" style="zoom:67%;" />



```python
class BinaryHeap:
    def __init__(self):
        self._heap = []

    def _perc_up(self, i):
        while (i - 1) // 2 >= 0:
            parent_idx = (i - 1) // 2
            if self._heap[i] < self._heap[parent_idx]:
                self._heap[i], self._heap[parent_idx] = (
                    self._heap[parent_idx],
                    self._heap[i],
                )
            i = parent_idx

    def insert(self, item):
        self._heap.append(item)
        self._perc_up(len(self._heap) - 1)

    def _perc_down(self, i):
        while 2 * i + 1 < len(self._heap):
            sm_child = self._get_min_child(i)
            if self._heap[i] > self._heap[sm_child]:
                self._heap[i], self._heap[sm_child] = (
                    self._heap[sm_child],
                    self._heap[i],
                )
            else:
                break
            i = sm_child

    def _get_min_child(self, i):
        if 2 * i + 2 > len(self._heap) - 1:
            return 2 * i + 1
        if self._heap[2 * i + 1] < self._heap[2 * i + 2]:
            return 2 * i + 1
        return 2 * i + 2

    def delete(self):
        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]
        result = self._heap.pop()
        self._perc_down(0)
        return result

    def heapify(self, not_a_heap):
        self._heap = not_a_heap[:]
        i = len(self._heap) // 2 - 1    # è¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹
        while i >= 0:
            #print(f'i = {i}, {self._heap}')
            self._perc_down(i)
            i = i - 1



n = int(input().strip())
heap = list(map(int, input().strip().split())) # [9, 5, 6, 2, 3]
heap = [-x for x in heap]

bh = BinaryHeap()
bh.heapify(heap)
ans = [-x for x in bh._heap]
print(*ans)
```





#### E18164: å‰ªç»³å­

greedy/huffman, http://cs101.openjudge.cn/practice/18164/

å°å¼ è¦å°†ä¸€æ ¹é•¿åº¦ä¸ºLçš„ç»³å­å‰ªæˆNæ®µã€‚å‡†å¤‡å‰ªçš„ç»³å­çš„é•¿åº¦ä¸ºL1,L2,L3...,LNï¼Œæœªå‰ªçš„ç»³å­é•¿åº¦æ°å¥½ä¸ºå‰ªåæ‰€æœ‰ç»³å­é•¿åº¦çš„å’Œã€‚ 

æ¯æ¬¡å‰ªæ–­ç»³å­æ—¶ï¼Œéœ€è¦çš„å¼€é”€æ˜¯æ­¤æ®µç»³å­çš„é•¿åº¦ã€‚

æ¯”å¦‚ï¼Œé•¿åº¦ä¸º10çš„ç»³å­è¦å‰ªæˆé•¿åº¦ä¸º2,3,5çš„ä¸‰æ®µç»³å­ã€‚é•¿åº¦ä¸º10çš„ç»³å­åˆ‡æˆ5å’Œ5çš„ä¸¤æ®µç»³å­æ—¶ï¼Œå¼€é”€ä¸º10ã€‚å†å°†5åˆ‡æˆé•¿åº¦ä¸º2å’Œ3çš„ç»³å­ï¼Œå¼€é”€ä¸º5ã€‚å› æ­¤æ€»å¼€é”€ä¸º15ã€‚


è¯·æŒ‰ç…§ç›®æ ‡è¦æ±‚å°†ç»³å­å‰ªå®Œæœ€å°çš„å¼€é”€æ—¶å¤šå°‘ã€‚

å·²çŸ¥ï¼Œ1<=N <= 20000ï¼Œ0<=Li<= 50000

**è¾“å…¥**

ç¬¬ä¸€è¡Œï¼šNï¼Œå°†ç»³å­å‰ªæˆçš„æ®µæ•°ã€‚
ç¬¬äºŒè¡Œï¼šå‡†å¤‡å‰ªæˆçš„å„æ®µç»³å­çš„é•¿åº¦ã€‚

**è¾“å‡º**

æœ€å°å¼€é”€

æ ·ä¾‹è¾“å…¥

```
3
2 3 5
```

æ ·ä¾‹è¾“å‡º

```
15
```

æ¥æºï¼šcs101-2017 æœŸæœ«æœºè€ƒå¤‡é€‰



ä¸ 05333: Fence Repair ä¸€æ ·ã€‚http://cs101.openjudge.cn/practice/05333

æ€è·¯ï¼š å‰ªç»³å­ï¼Œå®é™…ä¸Šæ˜¯ Huffmanç¼–ç /æ ‘ï¼Œhttps://zhuanlan.zhihu.com/p/42238580

```python
# OJ18164
import sys
try: fin = open('test.in','r').readline
except: fin = sys.stdin.readline

n = int(fin())
import heapq
a = list(map(int, fin().split()))
heapq.heapify(a)
ans = 0
for i in range(n-1):
    x = heapq.heappop(a)
    y = heapq.heappop(a)
    z = x + y
    heapq.heappush(a, z)
    ans += z
print(ans)
```





### 5.3 ç¬”è¯•ç®€ç­”@20210620

**Q**: ä¸‹å›¾æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘:
1)è¯·æ ¹æ®åˆå§‹å»ºå †ç®—æ³•å¯¹è¯¥å®Œå…¨äºŒå‰æ ‘å»ºå †ï¼Œè¯·ç”»å‡ºæ„å»ºçš„å°æ ¹å †(2åˆ†);

2)åŸºäº(1)ä¸­å¾—åˆ°çš„å †ï¼Œåˆ é™¤å…¶ä¸­çš„æœ€å°å…ƒç´ ï¼Œè¯·ç”¨å›¾ç»™å‡ºå †çš„è°ƒæ•´è¿‡ç¨‹(2åˆ†);

3)åŸºäº(1)ä¸­å¾—åˆ°çš„å †ï¼Œå‘å…¶ä¸­æ’å…¥å…ƒç´ 2ï¼Œè¯·ç»™å‡ºå †çš„è°ƒæ•´è¿‡ç¨‹(2åˆ†)ã€‚

æ³¨:æ¯ç§»åŠ¨ä¸€ä¸ªå…ƒç´ è§†ä¸ºä¸€ä¸ªæ‰§è¡Œæ­¥éª¤ï¼Œç”»å‡ºæ‰€æœ‰æ‰§è¡Œæ­¥éª¤ã€‚



```
          (31)
        /      \
      (8)       (53)
     /   \      /  \
   (10)  (20)  (7) (15) 
   / \    / 
 (3)(20) (1)
```





è¯´æ˜ï¼šæ ¹æ®äºŒå‰å †çš„â€œå®Œå…¨äºŒå‰æ ‘â€ç»“æ„æ€§è´¨å»ºå †ã€‚ä»å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œå‘ä¸Šéå†æ¯ä¸ªèŠ‚ç‚¹ã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œä¸‹æ²‰æ“ä½œï¼Œå°†èŠ‚ç‚¹ä¸å…¶å­èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶äº¤æ¢ä½ç½®ç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚é‡å¤æ­¥éª¤ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ã€‚



1ï¼‰åˆå§‹å»ºå †ç®—æ³•çš„æ­¥éª¤å¦‚ä¸‹ï¼š

- <mark>ä»å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹</mark>ï¼Œå‘ä¸Šéå†æ¯ä¸ªèŠ‚ç‚¹ã€‚
- å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œä¸‹æ²‰æ“ä½œï¼Œå°†èŠ‚ç‚¹ä¸å…¶å­èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶äº¤æ¢ä½ç½®ç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚
- é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ã€‚



æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹æ˜¯(20)ã€‚ï¼ˆè¯·åŒå­¦éªŒè¯æ˜¯å¦æ­£ç¡®ï¼Ÿï¼‰

```
          (31)
        /      \
      (8)       (53)
     /   \      /  \
   (10)  (1)  (7) (15) 
   / \    / 
 (3)(20) (20)
```





```
          (31)
        /      \
      (8)       (53)
     /   \      /  \
   (3)    (1)  (7) (15) 
   / \    / 
 (10)(20) (20)
```





```
          (31)
        /      \
      (8)       (7)
     /    \      /  \
   (3)    (1)  (53) (15) 
   / \     / 
 (10)(20) (20)
```



```
          (31)
        /      \
      (1)       (7)
     /    \      /  \
   (3)    (8)  (53) (15) 
   / \     / 
 (10)(20) (20)
```





```
          (1)
        /      \
      (3)       (7)
     /    \      /  \
   (10)    (8)  (53) (15) 
   / \     / 
 (31)(20) (20)
```



2ï¼‰åˆ é™¤æœ€å°å…ƒç´ çš„å †è°ƒæ•´è¿‡ç¨‹ï¼š

- é¦–å…ˆï¼Œå°†æ ¹èŠ‚ç‚¹ä¸æœ€åä¸€ä¸ªå¶å­èŠ‚ç‚¹äº¤æ¢ä½ç½®ã€‚
- ç„¶åï¼Œå°†æ ¹èŠ‚ç‚¹è¿›è¡Œä¸‹æ²‰æ“ä½œï¼Œä¸å…¶å­èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒå¹¶äº¤æ¢ä½ç½®ï¼Œç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚



åˆ é™¤æœ€å°å…ƒç´ åï¼Œå°†æœ€åä¸€ä¸ªå…ƒç´ 20 ç§»åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åè¿›è¡Œå †çš„è°ƒæ•´ã€‚

```
          (20)
        /      \
      (3)       (7)
     /    \      /  \
   (10)    (8)  (53) (15) 
   / \     
 (31)(20) 
```

ç»§ç»­è°ƒæ•´å †ï¼š

```
          (3)
        /      \
      (8)       (7)
     /    \      /  \
   (10)    (20)  (53) (15) 
   / \     
 (31)(20) 
```





3ï¼‰æ’å…¥å…ƒç´ çš„å †è°ƒæ•´è¿‡ç¨‹ï¼š

- é¦–å…ˆï¼Œå°†æ–°å…ƒç´ æ’å…¥åˆ°å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªä½ç½®ã€‚
- ç„¶åï¼Œå°†æ–°å…ƒç´ è¿›è¡Œä¸Šæµ®æ“ä½œï¼Œä¸å…¶çˆ¶èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒå¹¶äº¤æ¢ä½ç½®ï¼Œç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚



é¦–å…ˆå°†å…ƒç´ 2æ’å…¥åˆ°å †çš„æœ«å°¾ï¼Œç„¶åå‘ä¸Šè°ƒæ•´å †ã€‚

```
          (1)
        /      \
      (3)       (7)
     /    \      /  \
   (10)    (8)  (53) (15) 
   / \     /  \
 (31)(20) (20) (2)
```

ç»§ç»­è°ƒæ•´å †ï¼š

```
          (1)
        /      \
      (2)       (7)
     /    \      /  \
   (10)    (3)  (53) (15) 
   / \     /  \
 (31)(20) (20) (8)
```



## 6 å †æ’åºç®—æ³•

**å †æ’åº**ï¼šåˆ©ç”¨æœ€å¤§å †çš„æ€§è´¨ï¼Œå°†åˆ—è¡¨ä»å°åˆ°å¤§æ’åºã€‚

```python
class Node:
    def __init__(self, key):
        self.key = key

# ç¡®ä¿ä»¥ç´¢å¼• i ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘æ»¡è¶³æœ€å¤§å †çš„æ€§è´¨ï¼ˆçˆ¶èŠ‚ç‚¹çš„å€¼å¤§äºç­‰äºå­èŠ‚ç‚¹çš„å€¼ï¼‰ã€‚
def adjust_heap(lst, i, size):
    lchild = 2 * i + 1
    rchild = 2 * i + 2
    max_idx = i
    if i < size // 2:
        if lchild < size and lst[lchild].key > lst[max_idx].key:
            max_idx = lchild
        if rchild < size and lst[rchild].key > lst[max_idx].key:
            max_idx = rchild
        if max_idx != i:
            lst[max_idx], lst[i] = lst[i], lst[max_idx]
            adjust_heap(lst, max_idx, size)


def build_heap(lst):
    size = len(lst)
    for i in range(0, (size // 2))[::-1]: # ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œé€ä¸ªå‘ä¸Šè°ƒæ•´ï¼Œä½¿æ•´ä¸ªåˆ—è¡¨æˆä¸ºä¸€ä¸ªæœ€å¤§å †ã€‚
        adjust_heap(lst, i, size)


def heap_sort(lst):
    size = len(lst)
    build_heap(lst)
    for i in range(0, size)[::-1]:
        lst[0], lst[i] = lst[i], lst[0]
        adjust_heap(lst, 0, i)


def print_list(lst):
    return [node.key for node in lst]


if __name__ == "__main__":
    lst = [Node(5), Node(9), Node(3), Node(8), Node(7)]
    # æ‰“å°æ’åºå‰çš„åˆ—è¡¨
    print("Before sorting:", print_list(lst))

    # è°ƒç”¨å †æ’åº
    heap_sort(lst)

    # æ‰“å°æ’åºåçš„åˆ—è¡¨
    print("After sorting:", print_list(lst))

"""
Before sorting: [5, 9, 3, 8, 7]
After sorting: [3, 5, 7, 8, 9]
"""
```

 **æ€»ç»“**

1. **æ—¶é—´å¤æ‚åº¦**ï¼š
   - æ„å»ºå †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚
   - æ¯æ¬¡è°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡n)ï¼Œæ€»å…±éœ€è¦ n æ¬¡è°ƒæ•´ã€‚
   - å› æ­¤ï¼Œå †æ’åºçš„æ€»ä½“æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)ã€‚
2. **ç©ºé—´å¤æ‚åº¦**ï¼š
   - å †æ’åºæ˜¯åŸåœ°æ’åºç®—æ³•ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚
3. **ç¨³å®šæ€§**ï¼š
   - å †æ’åºæ˜¯ä¸€ç§**ä¸ç¨³å®šæ’åº**ï¼Œå› ä¸ºåœ¨äº¤æ¢å…ƒç´ æ—¶å¯èƒ½ä¼šæ”¹å˜ç›¸åŒå€¼å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚
4. **é€‚ç”¨åœºæ™¯**ï¼š
   - é€‚ç”¨äºéœ€è¦é«˜æ•ˆæ’åºä¸”å†…å­˜æœ‰é™çš„åœºæ™¯ï¼Œä¾‹å¦‚åµŒå…¥å¼ç³»ç»Ÿæˆ–å¤§è§„æ¨¡æ•°æ®æ’åºã€‚



## 7 äºŒå‰æœç´¢æ ‘

äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼ŒBSTï¼‰ï¼Œå®ƒæ˜¯æ˜ å°„çš„å¦ä¸€ç§å®ç°ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„ä¸æ˜¯å…ƒç´ åœ¨æ ‘ä¸­çš„ç¡®åˆ‡ä½ç½®ï¼Œè€Œæ˜¯<mark>å¦‚ä½•åˆ©ç”¨äºŒå‰æ ‘ç»“æ„æä¾›é«˜æ•ˆçš„æœç´¢ã€‚</mark>

äºŒå‰æœç´¢æ ‘ä¾èµ–äºè¿™æ ·ä¸€ä¸ªæ€§è´¨ï¼š<mark>å°äºçˆ¶èŠ‚ç‚¹çš„é”®éƒ½åœ¨å·¦å­æ ‘ä¸­ï¼Œå¤§äºçˆ¶èŠ‚ç‚¹çš„é”®åˆ™éƒ½åœ¨å³å­æ ‘ä¸­ã€‚æˆ‘ä»¬ç§°è¿™ä¸ªæ€§è´¨ä¸ºäºŒå‰æœç´¢æ€§ã€‚</mark>



### 7.1 ç¼–ç¨‹é¢˜ç›®

##### ç»ƒä¹ M22275: äºŒå‰æœç´¢æ ‘çš„éå†

http://cs101.openjudge.cn/practice/22275/

ç»™å‡ºä¸€æ£µäºŒå‰æœç´¢æ ‘çš„å‰åºéå†ï¼Œæ±‚å®ƒçš„ååºéå†

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•°nï¼ˆn<=2000ï¼‰è¡¨ç¤ºè¿™æ£µäºŒå‰æœç´¢æ ‘çš„ç»“ç‚¹ä¸ªæ•°
ç¬¬äºŒè¡Œnä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºè¿™æ£µäºŒå‰æœç´¢æ ‘çš„å‰åºéå†
ä¿è¯ç¬¬äºŒè¡Œçš„nä¸ªæ­£æ•´æ•°ä¸­ï¼Œ1~nçš„æ¯ä¸ªå€¼åˆšå¥½å‡ºç°ä¸€æ¬¡

**è¾“å‡º**

ä¸€è¡Œnä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºè¿™æ£µäºŒå‰æœç´¢æ ‘çš„ååºéå†

æ ·ä¾‹è¾“å…¥

```
5
4 2 1 3 5
```

æ ·ä¾‹è¾“å‡º

```
1 3 2 5 4
```

æç¤º

æ ‘çš„å½¢çŠ¶ä¸º
   4  
  / \ 
  2  5 
 / \  
 1  3  





```python
# ç®¡éªæ° ç”Ÿå‘½ç§‘å­¦å­¦é™¢
# ä¸­åºéå†å°±æ˜¯é¡ºåºæ’åˆ—ï¼Œè¿›è€Œé€šè¿‡ä¸Šæ¬¡ä½œä¸šçš„æ€è·¯æ ¹æ®å‰åºä¸­åºæ¨å‡ºååº
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


def build(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_val = preorder[0]
    root = Node(root_val)
    root_index = inorder.index(root_val)
    root.left = build(preorder[1:root_index + 1], inorder[:root_index])
    root.right = build(preorder[root_index + 1:], inorder[root_index + 1:])
    return root


def postorder(root):
    if not root:
        return []
    if root.left is None and root.right is None:
        return [root.val]
    result = []
    result += postorder(root.left)
    result += postorder(root.right)
    result += [root.val]
    return result


input()
preorder = list(map(int, input().split()))
inorder = sorted(preorder)
root = build(preorder, inorder)
result = postorder(root)
print(' '.join(map(str, result)))
```



```python
"""
ç‹æ˜Š å…‰åç®¡ç†å­¦é™¢ã€‚æ€è·¯ï¼š
å»ºæ ‘æ€è·¯ï¼šæ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹ï¼Œç´§è·Ÿç€æ˜¯å°äºæ ¹èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹ï¼Œåœ¨æ ¹èŠ‚ç‚¹å·¦ä¾§ï¼Œç›´è‡³é‡åˆ°å¤§äºæ ¹èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹ï¼Œ
åç»­èŠ‚ç‚¹éƒ½åœ¨æ ¹èŠ‚ç‚¹å³ä¾§ï¼ŒæŒ‰ç…§è¿™ä¸ªæ€è·¯é€’å½’å³å¯
"""
class Node():
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


def buildTree(preorder):
    if len(preorder) == 0:
        return None

    node = Node(preorder[0])

    idx = len(preorder)
    for i in range(1, len(preorder)):
        if preorder[i] > preorder[0]:
            idx = i
            break
    node.left = buildTree(preorder[1:idx])
    node.right = buildTree(preorder[idx:])

    return node


def postorder(node):
    if node is None:
        return []
    output = []
    output.extend(postorder(node.left))
    output.extend(postorder(node.right))
    output.append(str(node.val))

    return output


n = int(input())
preorder = list(map(int, input().split()))
print(' '.join(postorder(buildTree(preorder))))
```



```python
def post_order(pre_order):
    if not pre_order:
        return []
    root = pre_order[0]
    left_subtree = [x for x in pre_order if x < root]
    right_subtree = [x for x in pre_order if x > root]
    return post_order(left_subtree) + post_order(right_subtree) + [root]

n = int(input())
pre_order = list(map(int, input().split()))
print(' '.join(map(str, post_order(pre_order))))
```



##### ç»ƒä¹ M05455: äºŒå‰æœç´¢æ ‘çš„å±‚æ¬¡éå†

http://cs101.openjudge.cn/practice/05455/

äºŒå‰æœç´¢æ ‘åœ¨åŠ¨æ€æŸ¥è¡¨ä¸­æœ‰ç‰¹åˆ«çš„ç”¨å¤„ï¼Œä¸€ä¸ªæ— åºåºåˆ—å¯ä»¥é€šè¿‡æ„é€ ä¸€æ£µäºŒå‰æœç´¢æ ‘å˜æˆä¸€ä¸ªæœ‰åºåºåˆ—ï¼Œ

æ„é€ æ ‘çš„è¿‡ç¨‹å³ä¸ºå¯¹æ— åºåºåˆ—è¿›è¡Œæ’åºçš„è¿‡ç¨‹ã€‚æ¯æ¬¡æ’å…¥çš„æ–°çš„ç»“ç‚¹éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ä¸Šæ–°çš„å¶å­ç»“ç‚¹ï¼Œåœ¨è¿›è¡Œ

æ’å…¥æ“ä½œæ—¶ï¼Œä¸å¿…ç§»åŠ¨å…¶å®ƒç»“ç‚¹ï¼Œåªéœ€æ”¹åŠ¨æŸä¸ªç»“ç‚¹çš„æŒ‡é’ˆï¼Œç”±ç©ºå˜ä¸ºéç©ºå³å¯ã€‚

è¿™é‡Œï¼Œæˆ‘ä»¬æƒ³æ¢ç©¶äºŒå‰æ ‘çš„å»ºç«‹å’Œå±‚æ¬¡è¾“å‡ºã€‚

**è¾“å…¥**

åªæœ‰ä¸€è¡Œï¼ŒåŒ…å«è‹¥å¹²ä¸ªæ•°å­—ï¼Œä¸­é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚ï¼ˆæ•°å­—å¯èƒ½ä¼šæœ‰é‡å¤ï¼Œå¯¹äºé‡å¤çš„æ•°å­—ï¼Œåªè®¡å…¥ä¸€ä¸ªï¼‰

**è¾“å‡º**

è¾“å‡ºä¸€è¡Œï¼Œå¯¹è¾“å…¥æ•°å­—å»ºç«‹äºŒå‰æœç´¢æ ‘åè¿›è¡ŒæŒ‰å±‚æ¬¡å‘¨æ¸¸çš„ç»“æœã€‚

æ ·ä¾‹è¾“å…¥

```
51 45 59 86 45 4 15 76 60 20 61 77 62 30 2 37 13 82 19 74 2 79 79 97 33 90 11 7 29 14 50 1 96 59 91 39 34 6 72 7
```

æ ·ä¾‹è¾“å‡º

```
51 45 59 4 50 86 2 15 76 97 1 13 20 60 77 90 11 14 19 30 61 82 96 7 29 37 62 79 91 6 33 39 74 34 72
```

æç¤º

è¾“å…¥è¾“å‡ºçš„æœ€åéƒ½ä¸å¸¦ç©ºæ ¼å’Œå›è½¦æ¢è¡Œ



æŒ‰è¾“å…¥é¡ºåºéå†æ•°å­—ï¼Œç”¨ä¸€ä¸ª `seen` é›†åˆæ¥è·³è¿‡é‡å¤å€¼ï¼Œå¯¹äºæ¯ä¸ªæ–°å€¼ï¼Œæ’å…¥ BSTã€‚

```python
from collections import deque
import sys

# å®šä¹‰äºŒå‰æ ‘ç»“ç‚¹
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

# æ’å…¥ç»“ç‚¹åˆ° BST ä¸­
def insert(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = insert(root.left, val)
    elif val > root.val:
        root.right = insert(root.right, val)
    return root

# å±‚æ¬¡éå†
def level_order(root):
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        node = queue.popleft()
        result.append(str(node.val))
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return result

def main():
    data = sys.stdin.read().strip().split()
    seen = set()
    root = None
    for tok in data:
        num = int(tok)
        if num in seen:
            continue
        seen.add(num)
        root = insert(root, num)
    # è¾“å‡ºå±‚æ¬¡éå†ï¼Œæœ€åä¸å¸¦å¤šä½™ç©ºæ ¼æˆ–æ¢è¡Œ
    out = ' '.join(level_order(root))
    sys.stdout.write(out)

if __name__ == "__main__":
    main()

```



The problem is asking to construct a binary search tree (BST) from a sequence of numbers and then perform a level order traversal (also known as breadth-first search) on the BST.

Here is a step-by-step plan:

1. Create a TreeNode class to represent each node in the tree.
2. Create a function `insert` that takes a node and a value as input and inserts the value into the BST rooted at the node.
3. Create a function `level_order_traversal` that takes the root of the tree as input and returns the level order traversal of the tree.
   - Use a queue to store the nodes to be visited.
   - While the queue is not empty, dequeue a node, visit it, and enqueue its children.
4. Read the sequence of numbers from the input, construct the BST, perform the level order traversal, and output the result.

Here is the Python code that implements this plan:

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(node, value):
    if node is None:
        return TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    elif value > node.value:
        node.right = insert(node.right, value)
    return node

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

numbers = list(map(int, input().strip().split()))
numbers = list(dict.fromkeys(numbers))  # remove duplicates
root = None
for number in numbers:
    root = insert(root, number)
traversal = level_order_traversal(root)
print(' '.join(map(str, traversal)))
```

This code reads the sequence of numbers from the input, removes duplicates, constructs the BST, performs the level order traversal, and prints the result.



### 7.2 äºŒå‰æœç´¢æ ‘å®ç°å¿«æ’

å¿«é€Ÿæ’åºæ˜¯ä¸€ç§åŸºäºåˆ†æ²»æ³•çš„æ’åºç®—æ³•ï¼Œå®ƒé€šè¿‡é€‰æ‹©ä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†ï¼ˆpivotï¼‰ï¼Œå°†æ•°ç»„åˆ†å‰²ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œå…¶ä¸­ä¸€ä¸ªå­æ•°ç»„çš„å…ƒç´ éƒ½å°äºåŸºå‡†ï¼Œå¦ä¸€ä¸ªå­æ•°ç»„çš„å…ƒç´ éƒ½å¤§äºåŸºå‡†ã€‚ç„¶åï¼Œå¯¹ä¸¤ä¸ªå­æ•°ç»„é€’å½’åœ°åº”ç”¨ç›¸åŒçš„æ’åºè¿‡ç¨‹ï¼Œç›´åˆ°æ’åºå®Œæˆã€‚

äºŒå‰æœç´¢æ ‘æ˜¯ä¸€ç§æœ‰åºçš„äºŒå‰æ ‘ï¼Œå®ƒæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

- å·¦å­æ ‘ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å°äºæ ¹èŠ‚ç‚¹çš„å€¼ã€‚
- å³å­æ ‘ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæ ¹èŠ‚ç‚¹çš„å€¼ã€‚
- å·¦å­æ ‘å’Œå³å­æ ‘ä¹Ÿåˆ†åˆ«æ˜¯äºŒå‰æœç´¢æ ‘ã€‚

å¯ä»¥ä½¿ç”¨äºŒå‰æœç´¢æ ‘æ¥å®ç°å¿«é€Ÿæ’åºçš„è¿‡ç¨‹ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

1. é€‰æ‹©æ•°ç»„ä¸­çš„ä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†ã€‚
2. åˆ›å»ºä¸€ä¸ªç©ºçš„äºŒå‰æœç´¢æ ‘ã€‚
3. å°†æ•°ç»„ä¸­çš„å…¶ä»–å…ƒç´ é€ä¸ªæ’å…¥äºŒå‰æœç´¢æ ‘ä¸­ã€‚
4. æŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ï¼ˆå·¦å­æ ‘ã€æ ¹èŠ‚ç‚¹ã€å³å­æ ‘ï¼‰å¾—åˆ°æ’åºåçš„ç»“æœã€‚

è¿™ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n log n)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚æ¯æ¬¡æ’å…¥æ“ä½œéƒ½éœ€è¦ O(log n) çš„æ—¶é—´å¤æ‚åº¦ï¼Œæ€»å…±è¿›è¡Œ n-1 æ¬¡æ’å…¥æ“ä½œã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ<mark>äºŒå‰æœç´¢æ ‘çš„æ€§èƒ½å–å†³äºæ ‘çš„å¹³è¡¡æ€§</mark>ã€‚å¦‚æœäºŒå‰æœç´¢æ ‘å˜å¾—ä¸å¹³è¡¡ï¼Œæ€§èƒ½å¯èƒ½ä¼šä¸‹é™åˆ° $O(n^2) $çš„æ—¶é—´å¤æ‚åº¦ã€‚å› æ­¤ï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œä¸ºäº†ç¡®ä¿æ€§èƒ½ï¼Œé€šå¸¸ä¼šä½¿ç”¨å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆå¦‚çº¢é»‘æ ‘ã€AVLæ ‘ï¼‰æ¥å®ç°å¿«é€Ÿæ’åºã€‚

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def insert(root, val):
    if root is None:
        return TreeNode(val)
    if val < root.val:
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)
    return root

def inorder_traversal(root, result):
    if root:
        inorder_traversal(root.left, result)
        result.append(root.val)
        inorder_traversal(root.right, result)

def quicksort(nums):
    if not nums:
        return []
    root = TreeNode(nums[0])
    for num in nums[1:]:
        insert(root, num)
    result = []
    inorder_traversal(root, result)
    return result

# ç¤ºä¾‹è¾“å…¥
nums = [5, 2, 7, 1, 8, 3]

# ä½¿ç”¨äºŒå‰æœç´¢æ ‘å®ç°å¿«é€Ÿæ’åº
sorted_nums = quicksort(nums)

# æ‰“å°æ’åºç»“æœ
print(sorted_nums)
```



## 8 å¹³è¡¡äºŒå‰æœç´¢æ ‘

å½“äºŒå‰æœç´¢æ ‘ä¸å¹³è¡¡æ—¶ï¼Œgetå’Œputç­‰æ“ä½œçš„æ€§èƒ½å¯èƒ½é™åˆ°O(n)ã€‚æœ¬èŠ‚å°†ä»‹ç»ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æœç´¢æ ‘ï¼Œå®ƒèƒ½è‡ªåŠ¨ç»´æŒå¹³è¡¡ã€‚è¿™ç§æ ‘å«ä½œ AVLæ ‘ï¼Œä»¥å…¶å‘æ˜è€…G. M. Adelson-Velskiiå’ŒE. M. Landisçš„å§“æ°å‘½åã€‚

> AVL å¹³è¡¡æ ‘çš„å…¨ç§°æ˜¯ Adelson-Velsky and Landis å¹³è¡¡æ ‘ã€‚å®ƒæ˜¯ç”±ä¸¤ä½å‰è‹è”çš„è®¡ç®—æœºç§‘å­¦å®¶ï¼Œå³Ğ“ĞµĞ¾Ñ€Ğ³Ğ¸Ğ¹ ĞœĞ°ĞºÑĞ¸Ğ¼Ğ¾Ğ²Ğ¸Ñ‡ ĞĞ´ĞµĞ»ÑŒÑĞ¾Ğ½-Ğ’ĞµĞ»ÑŒÑĞºĞ¸Ğ¹ï¼ˆGeorgy Maximovich Adelson-Velskyï¼‰å’ŒĞ•Ğ²Ğ³ĞµĞ½Ğ¸Ğ¹ ĞœĞ¸Ñ…Ğ°Ğ¹Ğ»Ğ¾Ğ²Ğ¸Ñ‡ Ğ›Ğ°Ğ½Ğ´Ğ¸Ñï¼ˆEvgenii Mikhailovich Landisï¼‰äº1962å¹´æå‡ºçš„ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚
>
> è¿™ç§æ ‘çš„åç§°å–è‡ªè¿™ä¸¤ä½ç§‘å­¦å®¶çš„å§“æ°çš„é¦–å­—æ¯ç¼©å†™ã€‚AVL å¹³è¡¡æ ‘é€šè¿‡åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šç»´æŠ¤ä¸€ä¸ªå¹³è¡¡å› å­ï¼ˆbalance factorï¼‰æ¥å®ç°å¹³è¡¡ã€‚<mark>å¹³è¡¡å› å­æ˜¯æŒ‡èŠ‚ç‚¹çš„å·¦å­æ ‘é«˜åº¦ä¸å³å­æ ‘é«˜åº¦ä¹‹å·®çš„ç»å¯¹å€¼ã€‚</mark>é€šè¿‡ä¸æ–­è°ƒæ•´æ ‘çš„ç»“æ„ï¼ŒAVL æ ‘èƒ½å¤Ÿä¿æŒæ ‘çš„å¹³è¡¡ï¼Œä½¿å¾—åœ¨æœ€åæƒ…å†µä¸‹çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¿æŒåœ¨ O(log n)ã€‚
>
> AVL å¹³è¡¡æ ‘çš„ç‰¹ç‚¹æ˜¯åœ¨æ¯æ¬¡æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œä¼šé€šè¿‡æ—‹è½¬æ“ä½œæ¥è°ƒæ•´æ ‘çš„ç»“æ„ï¼Œä½¿å¾—å¹³è¡¡å› å­åœ¨ç‰¹å®šçš„èŒƒå›´å†…ï¼Œé€šå¸¸æ˜¯ -1ã€0ã€1ã€‚è¿™æ ·çš„å¹³è¡¡çŠ¶æ€èƒ½å¤Ÿä¿è¯æ ‘çš„é«˜åº¦å§‹ç»ˆä¿æŒåœ¨è¾ƒå°çš„èŒƒå›´å†…ï¼Œæä¾›äº†è¾ƒå¿«çš„æŸ¥æ‰¾å’Œæ›´æ–°æ“ä½œã€‚
>
> æ€»ç»“èµ·æ¥ï¼ŒAVL å¹³è¡¡æ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œé€šè¿‡è°ƒæ•´æ ‘çš„ç»“æ„æ¥ä¿æŒæ ‘çš„å¹³è¡¡æ€§ï¼Œä»¥æä¾›é«˜æ•ˆçš„æŸ¥æ‰¾å’Œæ›´æ–°æ“ä½œã€‚

AVLæ ‘å®ç°æ˜ å°„æŠ½è±¡æ•°æ®ç±»å‹çš„æ–¹å¼ä¸æ™®é€šçš„äºŒå‰æœç´¢æ ‘ä¸€æ ·ï¼Œå”¯ä¸€çš„å·®åˆ«å°±æ˜¯æ€§èƒ½ã€‚å®ç°AVLæ ‘æ—¶ï¼Œè¦è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ã€‚æˆ‘ä»¬é€šè¿‡æŸ¥çœ‹æ¯ä¸ªèŠ‚ç‚¹å·¦å³å­æ ‘çš„é«˜åº¦æ¥å®ç°è¿™ä¸€ç‚¹ã€‚æ›´æ­£å¼åœ°è¯´ï¼Œå°†å¹³è¡¡å› å­å®šä¹‰ä¸ºå·¦å³å­æ ‘çš„é«˜åº¦ä¹‹å·®ã€‚

$balance Factor = height (left SubTree) - height(right SubTree)$

æ ¹æ®ä¸Šè¿°å®šä¹‰ï¼Œå¦‚æœå¹³è¡¡å› å­å¤§äºé›¶ï¼Œç§°ä¹‹ä¸ºå·¦å€¾ï¼›å¦‚æœå¹³è¡¡å› å­å°äºé›¶ï¼Œå°±æ˜¯å³å€¾ï¼›å¦‚æœå¹³è¡¡å› å­ç­‰äºé›¶ï¼Œé‚£ä¹ˆæ ‘å°±æ˜¯å®Œå…¨å¹³è¡¡çš„ã€‚ä¸ºäº†å®ç°AVLæ ‘å¹¶åˆ©ç”¨å¹³è¡¡æ ‘çš„ä¼˜åŠ¿ï¼Œå°†å¹³è¡¡å› å­ä¸º-1ã€0å’Œ1çš„æ ‘éƒ½å®šä¹‰ä¸º**å¹³è¡¡æ ‘**ã€‚ä¸€æ—¦æŸä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­è¶…å‡ºè¿™ä¸ªèŒƒå›´ï¼Œå°±éœ€è¦é€šè¿‡ä¸€ä¸ªè¿‡ç¨‹è®©æ ‘æ¢å¤å¹³è¡¡ã€‚å›¾1å±•ç¤ºäº†ä¸€æ£µå³å€¾æ ‘åŠå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ã€‚

![../_images/unbalanced.png](https://raw.githubusercontent.com/GMyhf/img/main/img/unbalanced.png)

<center>å›¾1 å¸¦å¹³è¡¡å› å­çš„å³å€¾æ ‘</center>

### 8.1 AVLæ ‘çš„æ€§èƒ½

å…ˆçœ‹çœ‹é™å®šå¹³è¡¡å› å­å¸¦æ¥çš„ç»“æœã€‚ä¿è¯æ ‘çš„å¹³è¡¡å› å­ä¸º-1ã€0æˆ–1ï¼Œå¯ä»¥ä½¿å…³é”®æ“ä½œè·å¾—æ›´å¥½çš„å¤§ O æ€§èƒ½ã€‚é¦–å…ˆè€ƒè™‘å¹³è¡¡å› å­å¦‚ä½•æ”¹å–„æœ€åæƒ…å†µã€‚æœ‰å·¦å€¾ä¸å³å€¾è¿™ä¸¤ç§å¯èƒ½æ€§ã€‚å¦‚æœè€ƒè™‘é«˜åº¦ä¸º0ã€1ã€2å’Œ3çš„æ ‘ï¼Œå›¾2å±•ç¤ºäº†åº”ç”¨æ–°è§„åˆ™åæœ€ä¸å¹³è¡¡çš„å·¦å€¾æ ‘ã€‚

![../_images/worstAVL.png](https://raw.githubusercontent.com/GMyhf/img/main/img/worstAVL.png)

<center>å›¾2 å·¦å€¾AVLæ ‘çš„æœ€åæƒ…å†µ</center>



æŸ¥çœ‹æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ä¹‹åå¯çŸ¥ï¼Œé«˜åº¦ä¸º0æ—¶æœ‰1ä¸ªèŠ‚ç‚¹ï¼Œé«˜åº¦ä¸º1æ—¶æœ‰2ä¸ªèŠ‚ç‚¹ï¼ˆ1 + 1 = 2ï¼‰ï¼Œé«˜åº¦ä¸º2æ—¶æœ‰4ä¸ªèŠ‚ç‚¹ï¼ˆ1 + 1 + 2 = 4ï¼‰ï¼Œé«˜åº¦ä¸º3æ—¶æœ‰7ä¸ªèŠ‚ç‚¹ï¼ˆ1 + 2 + 4 = 7ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“é«˜åº¦ä¸ºhæ—¶ï¼ŒèŠ‚ç‚¹æ•°$N_h$æ˜¯ï¼š

$N_h = 1 + N_{h-1} + N_{h-2}$â€‹

ä½ æˆ–è®¸è§‰å¾—è¿™ä¸ªå…¬å¼å¾ˆçœ¼ç†Ÿï¼Œå› ä¸ºå®ƒä¸<mark>æ–æ³¢é‚£å¥‘æ•°åˆ—</mark>å¾ˆç›¸ä¼¼ã€‚



#### 8.1.1 ç¼–ç¨‹é¢˜ç›®

##### M27625: AVLæ ‘è‡³å°‘æœ‰å‡ ä¸ªç»“ç‚¹

> http://cs101.openjudge.cn/practice/27625/
>
> è¾“å…¥n (0<n<50), è¾“å‡ºä¸€ä¸ªnå±‚çš„AVLæ ‘è‡³å°‘æœ‰å¤šå°‘ä¸ªç»“ç‚¹ã€‚
>
> **è¾“å…¥**
>
> n
>
> **è¾“å‡º**
>
> ç­”æ¡ˆ
>
> æ ·ä¾‹è¾“å…¥
>
> ```
> 4
> ```
>
> æ ·ä¾‹è¾“å‡º
>
> ```
> 7
> ```
>
> æ¥æºï¼šGuo Wei
>
> 
>
> ```python
> from functools import lru_cache
> 
> @lru_cache(maxsize=None)
> def avl_min_nodes(n):
>     if n == 0:
>           return 0
>     elif n == 1:
>           return 1
>     else:
>           return avl_min_nodes(n-1) + avl_min_nodes(n-2) + 1
> 
> n = int(input())
> min_nodes = avl_min_nodes(n)
> print(min_nodes)
> ```
>
> 
>
> ```python
> def avl_min_nodes(n, memo):
>     if n == 0:
>           return 0
>     elif n == 1:
>           return 1
>     elif memo[n] != 0:  # å¦‚æœå·²ç»è®¡ç®—è¿‡ï¼Œç›´æ¥è¿”å›ä¿å­˜çš„ç»“æœ
>           return memo[n]
>     else:
>           memo[n] = avl_min_nodes(n-1, memo) + avl_min_nodes(n-2, memo) + 1
>           return memo[n]
> 
> n = int(input())
> memo = [0] * (n+1)  # åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜å·²è®¡ç®—çš„ç»“æœ
> min_nodes = avl_min_nodes(n, memo)
> print(min_nodes)
> ```





##### M27626: AVLæ ‘æœ€å¤šæœ‰å‡ å±‚

> http://cs101.openjudge.cn/practice/27626/
>
> nä¸ªç»“ç‚¹çš„AVLæ ‘æœ€å¤šæœ‰å¤šå°‘å±‚ï¼Ÿ
>
> **è¾“å…¥**
>
> æ•´æ•°n ã€‚ 0< n < 50,000,000
>
> **è¾“å‡º**
>
> AVLæ ‘æœ€å¤šæœ‰å¤šå°‘å±‚
>
> æ ·ä¾‹è¾“å…¥
>
> ```
> 20
> ```
>
> æ ·ä¾‹è¾“å‡º
>
> ```
> 6
> ```
>
> æ¥æºï¼šGuo Wei
>
> 
>
> AVLæ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦æœ€å¤šç›¸å·®1ã€‚ä¸ºäº†ç¡®å®šå…·æœ‰`n`ä¸ªèŠ‚ç‚¹çš„AVLæ ‘çš„æœ€å¤§é«˜åº¦ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªé€’å½’å…³ç³»ï¼Œè¯¥å…³ç³»æè¿°äº†ç»™å®šé«˜åº¦çš„AVLæ ‘æ‰€èƒ½åŒ…å«çš„æœ€å°‘èŠ‚ç‚¹æ•°ã€‚
>
> è®¾`N(h)`è¡¨ç¤ºé«˜åº¦ä¸º`h`çš„AVLæ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ï¼Œé‚£ä¹ˆæœ‰å¦‚ä¸‹é€’å½’å…³ç³»ï¼š
>
> ```
> N(h) = N(h-1) + N(h-2) + 1
> ```
>
> è¿™é‡Œï¼Œ`N(h-1)`æ˜¯è¾ƒé«˜å­æ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ï¼Œ`N(h-2)`æ˜¯è¾ƒçŸ®å­æ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ï¼Œ`+1`æ˜¯æ ¹èŠ‚ç‚¹è‡ªèº«ã€‚
>
> åŸºæœ¬æƒ…å†µæ˜¯ï¼š
>
> ```
> N(1) = 1  ï¼ˆå•ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼‰
> N(0) = 0  ï¼ˆç©ºæ ‘ï¼‰
> ```
>
> å¯ä»¥ä½¿ç”¨è¿™ä¸ªé€’å½’å…³ç³»æ¥è®¡ç®—ä»»ä½•é«˜åº¦çš„AVLæ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å¢é«˜åº¦ï¼Œç›´åˆ°è®¡ç®—å‡ºçš„èŠ‚ç‚¹æ•°è¶…è¿‡è¾“å…¥çš„`n`ï¼Œæ¥æ‰¾å‡ºå…·æœ‰`n`ä¸ªèŠ‚ç‚¹çš„AVLæ ‘çš„æœ€å¤§é«˜åº¦ã€‚
>
> ç”¨äºè®¡ç®—å…·æœ‰`n`ä¸ªèŠ‚ç‚¹çš„AVLæ ‘çš„æœ€å¤§é«˜åº¦ï¼š
>
> ```python
> from functools import lru_cache
> 
> @lru_cache(maxsize=None)
> def min_nodes(h):
>     if h == 0: return 0
>     if h == 1: return 1
>     return min_nodes(h-1) + min_nodes(h-2) + 1
> 
> def max_height(n):
>      h = 0
>      while min_nodes(h) <= n:
>           h += 1
>     return h - 1
> 
> n = int(input())
> print(max_height(n))
> ```



å› ä¸ºä¸æ–æ³¢é‚£å¥‘æ•°åˆ—å¾ˆç›¸ä¼¼ï¼Œå¯ä»¥æ ¹æ®å®ƒæ¨å¯¼å‡ºç”± AVL æ ‘çš„èŠ‚ç‚¹æ•°è®¡ç®—é«˜åº¦çš„å…¬å¼ã€‚åœ¨æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­ï¼Œç¬¬iä¸ªæ•°æ˜¯ï¼š

$\begin{split}F_0 = 0 \\
F_1 = 1 \\
F_i = F_{i-1} + F_{i-2}  \text{ for all } i \ge 2\end{split}$â€‹



ä¸€ä¸ªé‡è¦çš„äº‹å®æ˜¯ï¼Œéšç€æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å¢é•¿ï¼Œ$F_i/F_{i-1}$é€æ¸é€¼è¿‘é»„é‡‘åˆ†å‰²æ¯”ä¾‹$\Phi$ï¼Œ$ \Phi = \frac{1 + \sqrt{5}}{2}$ã€‚å¦‚æœä½ å¥½å¥‡è¿™ä¸ªç­‰å¼çš„æ¨å¯¼è¿‡ç¨‹ï¼Œå¯ä»¥æ‰¾ä¸€æœ¬æ•°å­¦ä¹¦çœ‹çœ‹ã€‚æˆ‘ä»¬åœ¨æ­¤ç›´æ¥ä½¿ç”¨è¿™ä¸ªç­‰å¼ï¼Œå°†$F_i$è¿‘ä¼¼ä¸º$F_i =
\Phi^i/\sqrt{5}$ã€‚

> ```python
> def fibonacci_recursive(n):
>  if n <= 1:
>      return n
>  else:
>      return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
> 
> 
> def fibonacci_iterative(n):
>  if n <= 1:
>      return n
>  else:
>      a, b = 0, 1
>      for _ in range(2, n+1):
>          a, b = b, a + b
>      return b
> 
> 
> phi = (1+5**0.5)/2
> 
> dp = [0]
> print("The ith Fibonacci number, \t With golden ratio approximation")
> for i in range(10):
>  result_recursive = fibonacci_recursive(i)
>  print(f"F{i}: {result_recursive}, ", end='')
>  print(f'{phi**i/(5**0.5)}')
> 
> """
> The ith Fibonacci number, 	 With golden ratio approximation
> F0: 0, 0.4472135954999579
> F1: 1, 0.7236067977499789
> F2: 1, 1.1708203932499368
> F3: 2, 1.8944271909999157
> F4: 3, 3.065247584249853
> F5: 5, 4.959674775249769
> F6: 8, 8.024922359499623
> F7: 13, 12.984597134749393
> F8: 21, 21.009519494249016
> F9: 34, 33.99411662899841
> """
> ```
>
> 

$\begin{split} N_0 = 1 \\
N_1 = 2 \quad F_3 = 3 \\
N_2 = 4 \quad F_4 = 5 \\
N_3 = 7 \quad F_5 = 8 
\end{split}$



ç”±æ­¤ï¼Œå¯ä»¥å°†$N_h$çš„ç­‰å¼é‡å†™ä¸ºï¼š

$N_h = F_{h+2} - 1, h \ge 1$

ç”¨é»„é‡‘åˆ†å‰²è¿‘ä¼¼æ›¿æ¢ï¼Œå¾—åˆ°ï¼š

$N_h = \frac{\Phi^{h+2}}{\sqrt{5}} - 1$

ç§»é¡¹ï¼Œä¸¤è¾¹ä»¥2ä¸ºåº•å–å¯¹æ•°ï¼Œæ±‚hï¼Œå¾—åˆ°ï¼š

$\begin{split}\log{(N_h+1)} = (h+2)\log{\Phi} - \frac{1}{2} \log{5} \\
h = \frac{\log{(N_h+1)} - 2 \log{\Phi} + \frac{1}{2} \log{5}}{\log{\Phi}} \\
h = 1.44 \log{N_h}\end{split}$â€‹â€‹â€‹â€‹

åœ¨ä»»ä½•æ—¶é—´ï¼Œ<mark>AVLæ ‘çš„é«˜åº¦éƒ½ç­‰äºèŠ‚ç‚¹æ•°å–å¯¹æ•°å†ä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°ï¼ˆ1.44ï¼‰</mark>ã€‚å¯¹äºæœç´¢AVLæ ‘æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä»¶å¥½äº‹ï¼Œå› ä¸ºæ—¶é—´å¤æ‚åº¦è¢«é™åˆ¶ä¸º$O(\log{N})$â€‹ã€‚



### 8.2 AVLæ ‘çš„å®ç°

å·²ç»è¯æ˜ï¼Œä¿æŒ AVL æ ‘çš„å¹³è¡¡ä¼šå¸¦æ¥å¾ˆå¤§çš„æ€§èƒ½ä¼˜åŠ¿ï¼Œç°åœ¨çœ‹çœ‹å¦‚ä½•å¾€æ ‘ä¸­æ’å…¥ä¸€ä¸ªé”®ã€‚æ‰€æœ‰æ–°é”®éƒ½æ˜¯ä»¥å¶å­èŠ‚ç‚¹æ’å…¥çš„ï¼Œå› ä¸ºæ–°å¶å­èŠ‚ç‚¹çš„å¹³è¡¡å› å­æ˜¯é›¶ï¼Œæ‰€ä»¥æ–°æ’èŠ‚ç‚¹æ²¡æœ‰ä»€ä¹ˆé™åˆ¶æ¡ä»¶ã€‚<mark>ä½†æ’å…¥æ–°èŠ‚ç‚¹åï¼Œå¿…é¡»æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­</mark>ã€‚æ–°çš„å¶å­èŠ‚ç‚¹å¯¹å…¶çˆ¶èŠ‚ç‚¹å¹³è¡¡å› å­çš„å½±å“å–å†³äºå®ƒæ˜¯å·¦å­èŠ‚ç‚¹è¿˜æ˜¯å³å­èŠ‚ç‚¹ã€‚å¦‚æœæ˜¯å³å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­å‡ä¸€ã€‚å¦‚æœæ˜¯å·¦å­èŠ‚ç‚¹ï¼Œåˆ™çˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­åŠ ä¸€ã€‚

å‡è®¾ç°åœ¨å·²æœ‰ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ï¼Œé‚£ä¹ˆå¯ä»¥é¢„è§åˆ°ï¼Œåœ¨å¾€å…¶ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œä¸€å®šä¼šæœ‰ç»“ç‚¹çš„å¹³è¡¡å› å­å‘ç”Ÿå˜åŒ–ï¼Œæ­¤æ—¶å¯èƒ½ä¼šæœ‰ç»“ç‚¹çš„å¹³è¡¡å› å­çš„ç»å¯¹å€¼å¤§äº 1ï¼ˆè¿™äº›å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 2 æˆ–è€… -2)ï¼Œè¿™æ ·ä»¥è¯¥ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘å°±æ˜¯å¤±è¡¡çš„ï¼Œéœ€è¦è¿›è¡Œè°ƒæ•´ã€‚æ˜¾ç„¶ï¼Œåªæœ‰åœ¨ä»æ ¹ç»“ç‚¹åˆ°è¯¥æ’å…¥ç»“ç‚¹çš„è·¯å¾„ä¸Šçš„ç»“ç‚¹æ‰å¯èƒ½å‘ç”Ÿå¹³è¡¡å› å­å˜åŒ–ï¼Œå› æ­¤åªéœ€å¯¹è¿™æ¡è·¯å¾„ä¸Šå¤±è¡¡çš„ç»“ç‚¹è¿›è¡Œè°ƒæ•´ã€‚å¯ä»¥è¯æ˜ï¼Œ<mark>åªè¦æŠŠæœ€é è¿‘æ’å…¥ç»“ç‚¹çš„å¤±è¡¡ç»“ç‚¹è°ƒæ•´åˆ°æ­£å¸¸ï¼Œè·¯å¾„ä¸Šçš„æ‰€æœ‰ç»“ç‚¹å°±éƒ½ä¼šå¹³è¡¡</mark>ã€‚

å½“å¹³è¡¡çš„äºŒå‰æ’åºæ ‘å› æ’å…¥ç»“ç‚¹è€Œ<mark>å¤±å»å¹³è¡¡æ—¶ï¼Œä»…éœ€å¯¹æœ€å°ä¸å¹³è¡¡å­æ ‘è¿›è¡Œå¹³è¡¡æ—‹è½¬å¤„ç†</mark>å³å¯ã€‚å› ä¸ºç»è¿‡æ—‹è½¬å¤„ç†ä¹‹åçš„å­æ ‘æ·±åº¦å’Œæ’å…¥ä¹‹å‰ç›¸åŒï¼Œå› è€Œä¸å½±å“æ’å…¥è·¯å¾„ä¸Šæ‰€æœ‰ç¥–å…ˆç»“ç‚¹çš„å¹³è¡¡åº¦ã€‚



> å¦‚æœéœ€è¦è¿›è¡Œå†å¹³è¡¡ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼Ÿé«˜æ•ˆçš„å†å¹³è¡¡æ˜¯è®©AVLæ ‘å‘æŒ¥ä½œç”¨åŒæ—¶ä¸æŸæ€§èƒ½çš„å…³é”®ã€‚ä¸ºäº†è®©AVLæ ‘æ¢å¤å¹³è¡¡ï¼Œéœ€è¦åœ¨æ ‘ä¸Šè¿›è¡Œä¸€æ¬¡æˆ–å¤šæ¬¡æ—‹è½¬ã€‚
>
> è¦ç†è§£ä»€ä¹ˆæ˜¯æ—‹è½¬ï¼Œæ¥çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚è€ƒè™‘å›¾3ä¸­å·¦è¾¹çš„æ ‘ã€‚è¿™æ£µæ ‘å¤±è¡¡äº†ï¼Œå¹³è¡¡å› å­æ˜¯-2ã€‚è¦è®©å®ƒæ¢å¤å¹³è¡¡ï¼Œæˆ‘ä»¬å›´ç»•ä»¥èŠ‚ç‚¹Aä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘åšä¸€æ¬¡å·¦æ—‹ã€‚
>
> ![../_images/simpleunbalanced.png](https://raw.githubusercontent.com/GMyhf/img/main/img/simpleunbalanced.png)
>
> <center>å›¾3 é€šè¿‡å·¦æ—‹è®©å¤±è¡¡çš„æ ‘æ¢å¤å¹³è¡¡</center>
>
> æœ¬è´¨ä¸Šï¼Œå·¦æ—‹åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ã€‚
>
> â å°†å³å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Bï¼‰æå‡ä¸ºå­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
> â å°†æ—§æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Aï¼‰ä½œä¸ºæ–°æ ¹èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ã€‚
> â å¦‚æœæ–°æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Bï¼‰å·²ç»æœ‰ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ï¼Œå°†å…¶ä½œä¸ºæ–°å·¦å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Aï¼‰çš„å³å­èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œ<mark>å› ä¸ºèŠ‚ç‚¹Bä¹‹å‰æ˜¯èŠ‚ç‚¹Açš„å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ­¤æ—¶èŠ‚ç‚¹Aå¿…ç„¶æ²¡æœ‰å³å­èŠ‚ç‚¹ã€‚</mark>å› æ­¤ï¼Œå¯ä»¥ä¸ºå®ƒæ·»åŠ æ–°çš„å³å­èŠ‚ç‚¹ï¼Œè€Œæ— é¡»è¿‡å¤šè€ƒè™‘ã€‚
>
> æ¥çœ‹ä¸€æ£µç¨å¾®å¤æ‚ä¸€ç‚¹çš„æ ‘ï¼Œå¹¶ç†è§£å³æ—‹è¿‡ç¨‹ã€‚å›¾4å·¦è¾¹çš„æ˜¯ä¸€æ£µå·¦å€¾çš„æ ‘ï¼Œæ ¹èŠ‚ç‚¹çš„å¹³è¡¡å› å­æ˜¯2ã€‚å³æ—‹æ­¥éª¤å¦‚ä¸‹ã€‚
>
> ![../_images/rightrotate1.png](https://raw.githubusercontent.com/GMyhf/img/main/img/rightrotate1.png)
>
> <center>å›¾4 é€šè¿‡å³æ—‹è®©å¤±è¡¡çš„æ ‘æ¢å¤å¹³è¡¡</center>
>
> â å°†å·¦å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Cï¼‰æå‡ä¸ºå­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
> â å°†æ—§æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Eï¼‰ä½œä¸ºæ–°æ ¹èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ã€‚
> â å¦‚æœæ–°æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Cï¼‰å·²ç»æœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Dï¼‰ï¼Œå°†å…¶ä½œä¸ºæ–°å³å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Eï¼‰çš„å·¦å­èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œ<mark>å› ä¸ºèŠ‚ç‚¹Cä¹‹å‰æ˜¯èŠ‚ç‚¹Eçš„å·¦å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ­¤æ—¶èŠ‚ç‚¹Eå¿…ç„¶æ²¡æœ‰å·¦å­èŠ‚ç‚¹ã€‚</mark>å› æ­¤ï¼Œå¯ä»¥ä¸ºå®ƒæ·»åŠ æ–°çš„å·¦å­èŠ‚ç‚¹ï¼Œè€Œæ— é¡»è¿‡å¤šè€ƒè™‘ã€‚



å‡è®¾æœ€é è¿‘æ’å…¥ç»“ç‚¹çš„å¤±è¡¡ç»“ç‚¹æ˜¯ Aï¼Œæ˜¾ç„¶å®ƒçš„å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 2 æˆ–è€… -2ã€‚å¾ˆå®¹æ˜“å‘ç°è¿™ä¸¤ç§æƒ…å†µå®Œå…¨å¯¹ç§°ï¼Œå› æ­¤ä¸»è¦è®¨è®ºç»“ç‚¹ A çš„å¹³è¡¡å› å­æ˜¯ 2 çš„æƒ…å½¢ã€‚

ç”±äºç»“ç‚¹ A çš„å¹³è¡¡å› å­æ˜¯ 2ï¼Œå› æ­¤å·¦å­æ ‘çš„é«˜åº¦æ¯”å³å­æ ‘å¤§ 2ï¼Œäºæ˜¯ä»¥ç»“ç‚¹ A ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘ä¸€å®šæ˜¯å›¾4çš„ä¸¤ç§å½¢æ€ LL å‹ä¸ LR å‹ä¹‹ä¸€ï¼ˆ**æ³¨æ„ï¼šLL å’Œ LR åªè¡¨ç¤ºæ ‘å‹ï¼Œä¸æ˜¯å·¦å³æ—‹çš„æ„æ€**ï¼‰ï¼Œå…¶ä¸­â˜†ã€â˜…ã€â—‡ã€â—†æ˜¯å›¾ä¸­ç›¸åº”ç»“ç‚¹çš„ AVL å­æ ‘ï¼Œç»“ç‚¹ Aã€Bã€C çš„æƒå€¼æ»¡è¶³ A > B > Cã€‚å¯ä»¥å‘ç°ï¼Œ**å½“ç»“ç‚¹ A çš„å·¦å­©å­çš„å¹³è¡¡å› å­æ˜¯ 1 æ—¶ä¸º LL å‹ï¼Œæ˜¯ -1 æ—¶ä¸º LR å‹**ã€‚é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆç»“ç‚¹ A çš„å·¦å­©å­çš„å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 1 æˆ–è€… -1 ï¼Œè€Œä¸å¯èƒ½æ˜¯ 0 å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºè¿™ç§æƒ…å†µæ— æ³•ç”±å¹³è¡¡äºŒå‰æ ‘æ’å…¥ä¸€ä¸ªç»“ç‚¹å¾—åˆ°ã€‚(ä¸ä¿¡ä¸¾ä¸ªåä¾‹ï¼Ÿ)



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403221922941.png" alt="image-20240322192203776" style="zoom:50%;" />

<center>å›¾4 æ ‘å‹ä¹‹ LL å‹ä¸ LR å‹ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



è¡¥å……è¯´æ˜ï¼Œé™¤äº†â˜†ã€â˜…ã€â—‡ã€â—†å‡ä¸ºç©ºæ ‘çš„æƒ…å†µä»¥å¤–ï¼Œå…¶ä»–ä»»ä½•æƒ…å†µå‡æ»¡è¶³åœ¨æ’å…¥å‰åº•å±‚ä¸¤æ£µå­æ ‘çš„é«˜åº¦æ¯”å¦å¤–ä¸¤æ£µå­æ ‘çš„é«˜åº¦å° 1ï¼Œä¸”æ’å…¥æ“ä½œä¸€å®šå‘ç”Ÿåœ¨åº•å±‚ä¸¤æ£µå­æ ‘ä¸Šã€‚ä¾‹å¦‚å¯¹LLå‹æ¥è¯´ï¼Œæ’å…¥å‰å­æ ‘çš„é«˜åº¦æ»¡è¶³â˜† = â˜… = â—†-1 = â—‡-1ï¼Œè€Œåœ¨â˜†æˆ–â˜…ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹åå¯¼è‡´â˜†æˆ–â˜…çš„é«˜åº¦åŠ  1ï¼Œä½¿å¾—ç»“ç‚¹Aä¸å¹³è¡¡ã€‚ï¼ˆè¾…åŠ©ç†è§£ï¼Œä¸éœ€è¦è®°ä½ï¼‰ç°åœ¨è€ƒè™‘æ€æ ·è°ƒæ•´è¿™ä¸¤ç§æ ‘å‹ï¼Œæ‰èƒ½ä½¿æ ‘å¹³è¡¡ã€‚

å…ˆè€ƒè™‘ LL å‹ï¼Œå¯ä»¥æŠŠä»¥ C ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çœ‹ä½œä¸€ä¸ªæ•´ä½“ï¼Œç„¶åä»¥ç»“ç‚¹ A ä½œä¸º root è¿›è¡Œå³æ—‹ï¼Œä¾¿å¯ä»¥è¾¾åˆ°å¹³è¡¡ï¼Œå¦‚å›¾5 æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403221936655.png" alt="image-20240322193648365" style="zoom:50%;" />



<center>å›¾5 LL å‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



ç„¶åè€ƒè™‘ LR å‹ï¼Œå¯ä»¥å…ˆå¿½ç•¥ç»“ç‚¹ Aï¼Œä»¥ç»“ç‚¹ C ä¸ºroot è¿›è¡Œå·¦æ—‹ï¼Œå°±å¯ä»¥æŠŠæƒ…å†µè½¬åŒ–ä¸º LL å‹ï¼Œç„¶åæŒ‰ä¸Šé¢ LL å‹çš„åšæ³•è¿›è¡Œä¸€æ¬¡å³æ—‹å³å¯ï¼Œå¦‚å›¾6 æ‰€ç¤ºã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403221938907.png" alt="image-20240322193842032" style="zoom:50%;" />

<center>å›¾6 LRå‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



è‡³æ­¤,ç»“ç‚¹ A çš„å¹³è¡¡å› å­æ˜¯ 2 çš„æƒ…å†µå·²ç»è®¨è®ºæ¸…æ¥š,ä¸‹é¢ç®€è¦è¯´æ˜å¹³è¡¡å› å­æ˜¯ -2 çš„æƒ…å†µï¼Œæ˜¾ç„¶ä¸¤ç§æƒ…å†µæ˜¯å®Œå…¨å¯¹ç§°çš„ã€‚
ç”±äºç»“ç‚¹ A çš„å¹³è¡¡å› å­ä¸º -2ï¼Œå› æ­¤å³å­æ ‘çš„é«˜åº¦æ¯”å·¦å­æ ‘å¤§ 2ï¼Œäºæ˜¯ä»¥ç»“ç‚¹Aä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘ä¸€å®šæ˜¯å›¾7 çš„ä¸¤ç§å½¢æ€ RR å‹ä¸ RL å‹ä¹‹ä¸€ã€‚æ³¨æ„ï¼Œç”±äºå’Œä¸Šé¢è®¨è®ºçš„ LL å‹å’Œ LR å‹å¯¹ç§°ï¼Œæ­¤å¤„ç»“ç‚¹ Aã€Bã€C çš„æƒå€¼æ»¡è¶³A < B < Cã€‚å¯ä»¥å‘ç°ï¼Œ**å½“ç»“ç‚¹ A çš„å³å­©å­çš„å¹³è¡¡å› å­æ˜¯ -1 æ—¶ä¸º RR å‹ï¼Œæ˜¯1æ—¶ä¸º RL å‹**ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240327180845393.png" alt="image-20240327180845393" style="zoom: 25%;" />

<center>å›¾7 æ ‘å‹ä¹‹ RRå‹ä¸RLå‹ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



å¯¹ RR å‹æ¥è¯´ï¼Œå¯ä»¥æŠŠä»¥ C ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çœ‹ä½œä¸€ä¸ªæ•´ä½“ï¼Œç„¶åä»¥ç»“ç‚¹ A ä½œä¸º root è¿›è¡Œå·¦æ—‹ï¼Œä¾¿å¯ä»¥è¾¾åˆ°å¹³è¡¡ï¼Œå¦‚å›¾8 æ‰€ç¤ºã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240327181005318.png" alt="image-20240327181005318" style="zoom:25%;" />

<center>å›¾8 RR å‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



å¯¹ RL å‹æ¥è¯´ï¼Œå¯ä»¥å…ˆå¿½ç•¥ç»“ç‚¹ Aï¼Œä»¥ç»“ç‚¹ C ä¸º root è¿›è¡Œå³æ—‹ï¼Œå°±å¯ä»¥æŠŠæƒ…å†µè½¬åŒ–ä¸º RR ç„¶åæŒ‰ä¸Šé¢ RR å‹çš„åšæ³•è¿›è¡Œä¸€æ¬¡å·¦æ—‹å³å¯ï¼Œå¦‚å›¾9 æ‰€ç¤ºã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240327181120393.png" alt="image-20240327181120393" style="zoom:25%;" />

<center>å›¾9 RLå‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



è‡³æ­¤ï¼Œå¯¹LL å‹ã€LR å‹ã€RR å‹ã€RLå‹çš„è°ƒæ•´æ–¹æ³•éƒ½å·²ç»è®¨è®ºæ¸…æ¥šã€‚

é€šè¿‡ç»´æŒæ ‘çš„å¹³è¡¡ï¼Œå¯ä»¥ä¿è¯getæ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(\log_2(n))$ã€‚ä½†è¿™ä¼šç»™putæ“ä½œçš„æ€§èƒ½å¸¦æ¥å¤šå¤§å½±å“å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹çœ‹putæ“ä½œã€‚å› ä¸ºæ–°èŠ‚ç‚¹ä½œä¸ºå¶å­èŠ‚ç‚¹æ’å…¥ï¼Œæ‰€ä»¥æ›´æ–°æ‰€æœ‰çˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­æœ€å¤šéœ€è¦$\log_2(n)$æ¬¡æ“ä½œâ€”â€”æ¯ä¸€å±‚ä¸€æ¬¡ã€‚å¦‚æœæ ‘å¤±è¡¡äº†ï¼Œæ¢å¤å¹³è¡¡æœ€å¤šéœ€è¦æ—‹è½¬ä¸¤æ¬¡ã€‚æ¯æ¬¡æ—‹è½¬çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(1)ï¼Œæ‰€ä»¥putæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯$O(log_2(n))$â€‹ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†ä¸€æ£µå¯ç”¨çš„AVLæ ‘ã€‚äº†è§£æ—‹è½¬çš„åŸºæœ¬åŸç†ä¹‹åï¼Œæ¥çœ‹ç¼–ç¨‹é¢˜ç›®ã€‚



#### 8.2.1 ç¼–ç¨‹é¢˜ç›®

##### æ™´é—®9.5: å¹³è¡¡äºŒå‰æ ‘çš„å»ºç«‹

https://sunnywhy.com/sfbj/9/5/359

å°† n ä¸ªäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°å…ˆåæ’å…¥åˆ°ä¸€æ£µç©ºçš„AVLæ ‘ä¸­ï¼Œæ±‚æœ€åç”Ÿæˆçš„AVLæ ‘çš„å…ˆåºåºåˆ—ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° $n (1 \le n \le 50)$ï¼Œè¡¨ç¤ºAVLæ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œ n ä¸ªæ•´æ•°$a_i (1 \le a_i \le 100)$ï¼Œè¡¨ç¤ºè¡¨ç¤ºæ’å…¥åºåˆ—ã€‚

**è¾“å‡º**

è¾“å‡º n ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå…ˆåºéå†åºåˆ—ï¼Œä¸­é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5
5 2 3 6 8
```

è¾“å‡º

```
3 2 6 5 8
```

è§£é‡Š

æ’å…¥çš„è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403210041932.png" alt="å¹³è¡¡äºŒå‰æ ‘çš„å»ºç«‹.png" style="zoom:67%;" />



To solve this problem, you can follow these steps:

1. Read the input sequence.
2. Insert the values into an AVL tree. An AVL tree is a self-balancing binary search tree, and the heights of the two child subtrees of any node differ by at most one.
3. Perform a preorder traversal of the AVL tree and print the result.

Here is the Python code that implements this plan:

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.height = 1

class AVL:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = Node(value)
        else:
            self.root = self._insert(value, self.root)

    def _insert(self, value, node):
        if not node:
            return Node(value)
        elif value < node.value:
            node.left = self._insert(value, node.left)
        else:
            node.right = self._insert(value, node.right)

        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

        balance = self._get_balance(node)

        if balance > 1:
            if value < node.left.value:	# æ ‘å½¢æ˜¯ LL
                return self._rotate_right(node)
            else:	# æ ‘å½¢æ˜¯ LR
                node.left = self._rotate_left(node.left)
                return self._rotate_right(node)

        if balance < -1:
            if value > node.right.value:	# æ ‘å½¢æ˜¯ RR
                return self._rotate_left(node)
            else:	# æ ‘å½¢æ˜¯ RL
                node.right = self._rotate_right(node.right)
                return self._rotate_left(node)

        return node

    def _get_height(self, node):
        if not node:
            return 0
        return node.height

    def _get_balance(self, node):
        if not node:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)

    def _rotate_left(self, z):
        y = z.right
        T2 = y.left
        y.left = z
        z.right = T2
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        return y

    def _rotate_right(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        x.height = 1 + max(self._get_height(x.left), self._get_height(x.right))
        return x

    def preorder(self):
        return self._preorder(self.root)

    def _preorder(self, node):
        if not node:
            return []
        return [node.value] + self._preorder(node.left) + self._preorder(node.right)

n = int(input().strip())
sequence = list(map(int, input().strip().split()))

avl = AVL()
for value in sequence:
    avl.insert(value)

print(' '.join(map(str, avl.preorder())))
```

This code reads the sequence from the input, inserts its values into an AVL tree, performs a preorder traversal of the AVL tree, and then prints the result.



#### 8.2.2 AVLæ ‘ä¸­åˆ é™¤èŠ‚ç‚¹

è¦å®ç°ä»AVLæ ‘ä¸­åˆ é™¤èŠ‚ç‚¹ï¼Œéœ€è¦æ·»åŠ ä¸€ä¸ªåˆ é™¤æ–¹æ³•ï¼Œå¹¶ç¡®ä¿åœ¨åˆ é™¤èŠ‚ç‚¹åé‡æ–°å¹³è¡¡æ ‘ã€‚

ä¸‹é¢æ˜¯AVLçš„åˆ é™¤æ–¹æ³• `_delete`ï¼š

```python
class AVL:
    # Existing code...
    
    def delete(self, value):
        self.root = self._delete(value, self.root)

    def _delete(self, value, node):
        if not node:
            return node

        if value < node.value:
            node.left = self._delete(value, node.left)
        elif value > node.value:
            node.right = self._delete(value, node.right)
        else:
            if not node.left:
                temp = node.right
                node = None
                return temp
            elif not node.right:
                temp = node.left
                node = None
                return temp

            temp = self._min_value_node(node.right)
            node.value = temp.value
            node.right = self._delete(temp.value, node.right)

        # if not node:
        #    return node

        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

        balance = self._get_balance(node)

        # Rebalance the tree
        if balance > 1:
            if self._get_balance(node.left) >= 0:
                return self._rotate_right(node)
            else:
                node.left = self._rotate_left(node.left)
                return self._rotate_right(node)

        if balance < -1:
            if self._get_balance(node.right) <= 0:
                return self._rotate_left(node)
            else:
                node.right = self._rotate_right(node.right)
                return self._rotate_left(node)

        return node

    def _min_value_node(self, node):
        current = node
        while current.left:
            current = current.left
        return current

    # Existing code...
```

è¿™æ®µä»£ç ä¸­çš„ `_delete` æ–¹æ³•ç”¨äºåˆ é™¤èŠ‚ç‚¹ã€‚å®ƒé¦–å…ˆæ£€æŸ¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œç„¶åæ ¹æ®èŠ‚ç‚¹çš„å·¦å³å­æ ‘æƒ…å†µæ‰§è¡Œç›¸åº”çš„æ“ä½œï¼Œä»¥ä¿æŒAVLæ ‘çš„å¹³è¡¡ã€‚

åœ¨ AVL æ ‘ä¸­ï¼Œåˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå½“è¢«åˆ é™¤çš„èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹æ—¶ï¼Œéœ€è¦ä¸€äº›é¢å¤–çš„æ­¥éª¤æ¥ä¿æŒæ ‘çš„å¹³è¡¡æ€§ã€‚è®©æˆ‘ä»¬è¯¦ç»†è®²è§£ `else` åˆ†æ”¯ä¸­çš„æƒ…å†µï¼š

```python
else:
    if not node.left:
        temp = node.right
        node = None
        return temp
    elif not node.right:
        temp = node.left
        node = None
        return temp

    temp = self._min_value_node(node.right)
    node.value = temp.value
    node.right = self._delete(temp.value, node.right)
```

1. å¦‚æœè¦åˆ é™¤çš„èŠ‚ç‚¹ `node` æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¿”å›å…¶å³å­èŠ‚ç‚¹ã€‚è¿™æ˜¯å› ä¸ºå³å­èŠ‚ç‚¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰å°†å æ® `node` çš„ä½ç½®ï¼Œè€Œä¸ä¼šå½±å“æ ‘çš„å¹³è¡¡æ€§ã€‚æ‰€ä»¥æˆ‘ä»¬å°† `node` è®¾ç½®ä¸º `None`ï¼Œç„¶åè¿”å›å…¶å³å­èŠ‚ç‚¹å³å¯ã€‚

2. å¦‚æœè¦åˆ é™¤çš„èŠ‚ç‚¹ `node` æ²¡æœ‰å³å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¿”å›å…¶å·¦å­èŠ‚ç‚¹ã€‚è¿™ä¸ä¸Šè¿°æƒ…å†µç±»ä¼¼ã€‚

3. å¦‚æœè¦åˆ é™¤çš„èŠ‚ç‚¹ `node` æ—¢æœ‰å·¦å­èŠ‚ç‚¹åˆæœ‰å³å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ‰¾åˆ° `node` çš„å³å­æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶å€¼æ›¿æ¢åˆ° `node` ä¸­ï¼Œç„¶ååœ¨å³å­æ ‘ä¸­åˆ é™¤è¿™ä¸ªæœ€å°å€¼èŠ‚ç‚¹ã€‚è¿™æ˜¯å› ä¸º<mark>å³å­æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹æ˜¯å¤§äºå·¦å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼ä¸”å°äºå³å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹</mark>ï¼Œå®ƒåœ¨æ›¿ä»£è¢«åˆ é™¤èŠ‚ç‚¹åèƒ½å¤Ÿä¿æŒæ ‘çš„å¹³è¡¡æ€§ã€‚

å‡½æ•° `_min_value_node` ç”¨äºæ‰¾åˆ°æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹ï¼Œå…¶å®ç°å¦‚ä¸‹ï¼š

```python
def _min_value_node(self, node):
    current = node
    while current.left:
        current = current.left
    return current
```

è¿™æ ·ï¼Œå½“æˆ‘ä»¬åˆ é™¤å¸¦æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬é€‰æ‹©å°†å³å­æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹çš„å€¼æ›¿æ¢åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹ä¸­ï¼Œç„¶åé€’å½’åœ°åœ¨å³å­æ ‘ä¸­åˆ é™¤è¿™ä¸ªæœ€å°å€¼èŠ‚ç‚¹ã€‚



### 8.3 æ˜ å°„å®ç°æ€»ç»“

ç”¨æ¥å®ç°æ˜ å°„è¿™ä¸€æŠ½è±¡æ•°æ®ç±»å‹çš„å¤šç§æ•°æ®ç»“æ„ï¼ŒåŒ…æ‹¬æœ‰åºåˆ—è¡¨ã€æ•£åˆ—è¡¨ã€äºŒå‰æœç´¢æ ‘ä»¥åŠ AVL æ ‘ã€‚è¡¨6-1æ€»ç»“äº†æ¯ä¸ªæ•°æ®ç»“æ„çš„æ€§èƒ½ã€‚

è¡¨6-1 æ˜ å°„çš„ä¸åŒå®ç°é—´çš„æ€§èƒ½å¯¹æ¯”

| operation | Sorted List    | Hash Table | Binary Search Tree | AVL Tree       |
| :-------- | :------------- | :--------- | :----------------- | :------------- |
| put       | $O(n)$         | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |
| get       | $O(\log_2{n})$ | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |
| in        | $O(\log_2{n})$ | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |
| del       | $O(n)$         | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |





## 9 å¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰

> é€šå¸¸æƒ…å†µä¸‹ï¼Œä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰å’Œå‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰æ˜¯æ¯”è¾ƒå¸¸è§çš„åšæ³•ã€‚
>
> 1. **å¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰**ï¼šåœ¨å¹¶æŸ¥é›†ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½å±äºä¸€ä¸ªé›†åˆï¼Œå¹¶ä¸”è¿™äº›é›†åˆä¹‹é—´æ˜¯ä¸ç›¸äº¤çš„ã€‚ä¸ºäº†é«˜æ•ˆåœ°å®ç°å¹¶æŸ¥é›†æ“ä½œï¼Œé€šå¸¸ä¼šä½¿ç”¨<mark>æ ‘å½¢ç»“æ„</mark>æ¥è¡¨ç¤ºé›†åˆä¹‹é—´çš„å…³ç³»ã€‚<mark>æ¯ä¸ªé›†åˆå¯ä»¥ç”¨ä¸€ä¸ªæ ‘è¡¨ç¤ºï¼Œå…¶ä¸­æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯é›†åˆçš„ä»£è¡¨å…ƒç´ </mark>ã€‚ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºè¿™ç§æ ‘å½¢ç»“æ„æ˜¯ä¸€ç§å¸¸è§çš„åšæ³•ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
>
> 2. **å‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰**ï¼šå‰ç¼€æ ‘æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨å­—ç¬¦ä¸²é›†åˆçš„æ•°æ®ç»“æ„ï¼Œé€šå¸¸ç”¨äºå¿«é€Ÿåœ°è¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…å’Œæœç´¢ã€‚åœ¨å‰ç¼€æ ‘ä¸­ï¼Œ<mark>æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²</mark>ã€‚ä¸ºäº†è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“æ„ï¼Œé€šå¸¸ä¼šä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå‰ç¼€æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€ä¸ªå­—ç¬¦ä»¥åŠæŒ‡å‘å­èŠ‚ç‚¹çš„æŒ‡é’ˆåˆ—è¡¨ã€‚
>
> ä½¿ç”¨é‚»æ¥è¡¨è¡¨ç¤ºå¹¶æŸ¥é›†å’Œå‰ç¼€æ ‘å¯ä»¥é«˜æ•ˆåœ°æ”¯æŒå„ç§æ“ä½œï¼Œå¦‚å¹¶æŸ¥é›†çš„åˆå¹¶å’ŒæŸ¥æ‰¾æ“ä½œï¼Œä»¥åŠå‰ç¼€æ ‘çš„æ’å…¥ã€æœç´¢å’Œåˆ é™¤æ“ä½œã€‚åŒæ—¶ï¼Œé‚»æ¥è¡¨ä¹Ÿèƒ½å¤Ÿæ¯”è¾ƒç›´è§‚åœ°è¡¨ç¤ºæ•°æ®ç»“æ„ä¹‹é—´çš„å…³ç³»ï¼Œä¾¿äºç†è§£å’Œå®ç°ã€‚



Disjoint Set (Union-Find Algorithm)

https://www.geeksforgeeks.org/introduction-to-disjoint-set-data-structure-or-union-find-algorithm/

**What is a Disjoint set data structure?**

> Two sets are called **disjoint sets** if they donâ€™t have any element in common, the intersection of sets is a null set.

ä¸€ç§å­˜å‚¨éé‡å æˆ–ä¸ç›¸äº¤å­é›†çš„æ•°æ®ç»“æ„è¢«ç§°ä¸º**ä¸ç›¸äº¤é›†åˆæ•°æ®ç»“æ„**ï¼ˆDisjoint Set Data Structureï¼‰ã€‚ä¸ç›¸äº¤é›†åˆæ•°æ®ç»“æ„æ”¯æŒä»¥ä¸‹æ“ä½œï¼š

- å‘ä¸ç›¸äº¤é›†åˆä¸­**æ·»åŠ æ–°é›†åˆ**ã€‚
- ä½¿ç”¨**Unionï¼ˆåˆå¹¶ï¼‰**æ“ä½œå°†ä¸ç›¸äº¤é›†åˆåˆå¹¶ä¸ºä¸€ä¸ªé›†åˆã€‚
- ä½¿ç”¨**Findï¼ˆæŸ¥æ‰¾ï¼‰**æ“ä½œæ‰¾åˆ°ä¸ç›¸äº¤é›†åˆçš„ä»£è¡¨å…ƒç´ ã€‚
- æ£€æŸ¥ä¸¤ä¸ªé›†åˆæ˜¯å¦ä¸ºä¸ç›¸äº¤ã€‚

è€ƒè™‘ä¸€ä¸ªåŒ…å«è‹¥å¹²äººçš„æƒ…æ™¯ï¼Œå¹¶éœ€è¦å¯¹ä»–ä»¬æ‰§è¡Œä»¥ä¸‹ä»»åŠ¡ï¼š

- æ·»åŠ **æ–°çš„æœ‹å‹å…³ç³»**ï¼Œå³ä¸€ä¸ªäºº `x`  æˆä¸ºå¦ä¸€ä¸ªäºº ` y ` çš„æœ‹å‹ï¼ˆå³å°†æ–°å…ƒç´ æ·»åŠ åˆ°é›†åˆä¸­ï¼‰ã€‚
- æŸ¥æ‰¾ä¸ªä½“ ` x ` æ˜¯å¦æ˜¯ä¸ªä½“ ` y ` çš„æœ‹å‹ï¼ˆç›´æ¥æˆ–é—´æ¥çš„æœ‹å‹ï¼‰ã€‚

> A data structure that stores non overlapping or disjoint subset of elements is called disjoint set data structure. The disjoint set data structure supports following operations:
>
> - Adding new sets to the disjoint set.
> - Merging disjoint sets to a single disjoint set using **Union** operation.
> - Finding representative of a disjoint set using **Find** operation.
> - Check if two sets are disjoint or not. 
>
> Consider a situation with a number of persons and the following tasks to be performed on them:
>
> - Add a **new friendship relation**, i.e. a person x becomes the friend of another person y i.e adding new element to a set.
> - Find whether individual **x is a friend of individual y** (direct or indirect friend)
>

**Examples:** 

> We are given 10 individuals say, a, b, c, d, e, f, g, h, i, j
>
> Following are relationships to be added:
> a <-> b  
> b <-> d
> c <-> f
> c <-> i
> j <-> e
> g <-> j
>
> Given queries like whether a is a friend of d or not. We basically need to create following 4 groups and maintain a quickly accessible connection among group items:
> G1 = {a, b, d}
> G2 = {c, f, i}
> G3 = {e, g, j}
> G4 = {h}



**æŸ¥æ‰¾ `x ` å’Œ ` y ` æ˜¯å¦å±äºåŒä¸€ç»„ï¼Œå³åˆ¤æ–­ ` x ` å’Œ ` y ` æ˜¯å¦ä¸ºç›´æ¥æˆ–é—´æ¥æœ‹å‹ã€‚**

æ ¹æ®ä»–ä»¬æ‰€å±çš„ç¾¤ä½“å¯¹ä¸ªä½“è¿›è¡Œåˆ’åˆ†ã€‚è¿™ç§æ–¹æ³•è¢«ç§°ä¸º**ä¸ç›¸äº¤é›†åˆå¹¶ï¼ˆDisjoint Set Unionï¼‰**ï¼Œå®ƒç»´æŠ¤äº†ä¸€ä¸ª**ä¸ç›¸äº¤é›†åˆ**çš„é›†åˆï¼Œæ¯ä¸ªé›†åˆç”±å…¶ä¸€ä¸ªæˆå‘˜è¡¨ç¤ºã€‚

**è¦å›ç­”ä¸Šè¿°é—®é¢˜ï¼Œéœ€è¦è€ƒè™‘ä¸¤ä¸ªå…³é”®ç‚¹ï¼š**

- **å¦‚ä½•ç¡®å®šé›†åˆï¼Ÿ** æœ€åˆï¼Œæ‰€æœ‰å…ƒç´ éƒ½å±äºä¸åŒçš„é›†åˆã€‚åœ¨å¤„ç†ç»™å®šçš„å…³ç³»ä¹‹åï¼Œæˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæˆå‘˜ä½œä¸º**ä»£è¡¨**ã€‚é€‰æ‹©ä»£è¡¨çš„æ–¹å¼æœ‰å¤šç§ï¼Œä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯é€‰æ‹©å…·æœ‰æœ€å¤§ç´¢å¼•çš„æˆå‘˜ã€‚
- **æ£€æŸ¥ä¸¤ä¸ªäººæ˜¯å¦åœ¨åŒä¸€ç»„ä¸­ï¼Ÿ** å¦‚æœä¸¤ä¸ªäººçš„ä»£è¡¨ç›¸åŒï¼Œåˆ™è¯´æ˜ä»–ä»¬æ˜¯æœ‹å‹ã€‚



> **Find whether x and y belong to the same group or not, i.e. to find if x and y are direct/indirect friends.**
>
> Partitioning the individuals into different sets according to the groups in which they fall. This method is known as a **Disjoint set Union** which maintains a collection of **Disjoint sets** and each set is represented by one of its members.
>
> **To answer the above question two key points to be considered are:**
>
> - **How to Resolve sets?** Initially, all elements belong to different sets. After working on the given relations, we select a member as a **representative**. There can be many ways to select a representative, a simple one is to select with the biggest index.
> - **Check if 2 persons are in the same group?** If representatives of two individuals are the same, then theyâ€™ll become friends.
>



**ä½¿ç”¨åˆ°çš„æ•°æ®ç»“æ„åŒ…æ‹¬ï¼š**

**æ•°ç»„ï¼š** ä¸€ä¸ªåä¸º**Parent[]**çš„æ•´æ•°æ•°ç»„ã€‚å¦‚æœæˆ‘ä»¬å¤„ç†çš„æ˜¯**N**é¡¹ï¼Œæ•°ç»„çš„ç¬¬iä¸ªå…ƒç´ ä»£è¡¨ç¬¬ié¡¹ã€‚æ›´å…·ä½“åœ°è¯´ï¼ŒParent[]æ•°ç»„çš„ç¬¬iä¸ªå…ƒç´ æ˜¯ç¬¬ié¡¹çš„çˆ¶èŠ‚ç‚¹ã€‚è¿™äº›å…³ç³»åˆ›å»ºäº†ä¸€ä¸ªæˆ–å¤šä¸ªè™šæ‹Ÿæ ‘ã€‚

**æ ‘ï¼š** å®ƒæ˜¯ä¸€ä¸ª**ä¸ç›¸äº¤é›†**ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä½äºåŒä¸€æ£µæ ‘ä¸­ï¼Œåˆ™å®ƒä»¬ä½äºåŒä¸€ä¸ª**ä¸ç›¸äº¤é›†**ä¸­ã€‚æ¯æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆæˆ–æœ€é¡¶éƒ¨çš„èŠ‚ç‚¹ï¼‰è¢«ç§°ä¸ºè¯¥é›†åˆçš„**ä»£è¡¨**ã€‚æ¯ä¸ªé›†åˆæ€»æ˜¯æœ‰ä¸€ä¸ªå”¯ä¸€çš„ä»£è¡¨ã€‚è¯†åˆ«ä»£è¡¨çš„ä¸€ä¸ªç®€å•è§„åˆ™æ˜¯ï¼Œå¦‚æœâ€˜iâ€™æ˜¯æŸä¸ªé›†åˆçš„ä»£è¡¨ï¼Œåˆ™**Parent[i] = i**ã€‚å¦‚æœâ€˜iâ€™ä¸æ˜¯ä»–æ‰€åœ¨é›†åˆçš„ä»£è¡¨ï¼Œåˆ™å¯ä»¥é€šè¿‡æ²¿æ ‘å‘ä¸Šéå†ç›´åˆ°æ‰¾åˆ°ä»£è¡¨ä¸ºæ­¢ã€‚

è¿™ç§ç»“æ„å…è®¸æœ‰æ•ˆåœ°æ‰§è¡Œè¯¸å¦‚åˆå¹¶é›†åˆå’ŒæŸ¥æ‰¾ä»£è¡¨ç­‰æ“ä½œï¼Œé€‚ç”¨äºéœ€è¦åŠ¨æ€ç®¡ç†åˆ†ç»„çš„é—®é¢˜ï¼Œå¦‚ç¤¾äº¤ç½‘ç»œä¸­çš„æœ‹å‹å…³ç³»è¿½è¸ªã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªäººæ˜¯å¦æ˜¯æœ‹å‹ï¼ˆç›´æ¥æˆ–é—´æ¥ï¼‰ï¼Œå³ä½¿è¿™ä¸ªå…³ç³»é“¾å¯èƒ½å¾ˆé•¿ã€‚

> **Data Structures used are:** 
>
> **Array:** An array of integers is called **Parent[]**. If we are dealing with **N** items, iâ€™th element of the array represents the iâ€™th item. More precisely, the iâ€™th element of the Parent[] array is the parent of the iâ€™th item. These relationships create one or more virtual trees.
>
> **Tree:** It is a **Disjoint set**. If two elements are in the same tree, then they are in the same **Disjoint set**. The root node (or the topmost node) of each tree is called the **representative** of the set. There is always a single **unique representative** of each set. A simple rule to identify a representative is if â€˜iâ€™ is the representative of a set, then **Parent[i] = i**. If i is not the representative of his set, then it can be found by traveling up the tree until we find the representative.



### 9.1 Operations on Disjoint Set

æ“ä½œåŒ…æ‹¬ Find å’Œ Unionã€‚

#### 9.1.1 Find

å¯ä»¥é€šè¿‡é€’å½’éå†çˆ¶èŠ‚ç‚¹æ•°ç»„æ¥å®ç°ï¼Œç›´åˆ°æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹æ˜¯å…¶è‡ªèº«çš„çˆ¶èŠ‚ç‚¹ä¸ºæ­¢ã€‚

> Can be implemented by recursively traversing the parent array until we hit a node that is the parent of itself.



```python
# Finds the representative of the set
# that i is an element of

def find(i):

	# If i is the parent of itself
	if (parent[i] == i):

		# Then i is the representative of
		# this set
		return i
	else:

		# Else if i is not the parent of
		# itself, then i is not the
		# representative of his set. So we
		# recursively call Find on its parent
		return find(parent[i])

# The code is contributed by Nidhi goel

```



**Time complexity**: This approach is inefficient and can take O(n) time in worst case.



#### 9.1.2 Union 

å®ƒæ¥å—**ä¸¤ä¸ªå…ƒç´ **ä½œä¸ºè¾“å…¥ï¼Œä½¿ç”¨**Findï¼ˆæŸ¥æ‰¾ï¼‰**æ“ä½œæ‰¾åˆ°å®ƒä»¬æ‰€åœ¨é›†åˆçš„ä»£è¡¨ï¼Œæœ€åå°†å…¶ä¸­ä¸€æ£µæ ‘ï¼ˆä»£è¡¨ä¸€ä¸ªé›†åˆï¼‰ç½®äºå¦ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä¹‹ä¸‹ã€‚

> It takes **two elements** as input and finds the representatives of their sets using the **Find** operation, and finally puts either one of the trees (representing the set) under the root node of the other tree.

```python
# Unites the set that includes i
# and the set that includes j

def union(parent, rank, i, j):
	# Find the representatives
	# (or the root nodes) for the set
	# that includes i
	irep = find(parent, i)
	
	# And do the same for the set
	# that includes j
	jrep = find(parent, j)
	
	# Make the parent of iâ€™s representative
	# be jâ€™s representative effectively
	# moving all of iâ€™s set into jâ€™s set)
	
	parent[irep] = jrep

```

**Time complexity**: This approach is inefficient and could lead to tree of length O(n) in worst case.



### 9.2 Optimizations (Union by Rank/Size and Path Compression)

æ•ˆç‡å¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºå“ªæ£µæ ‘è¢«è¿æ¥åˆ°å¦ä¸€æ£µæ ‘ä¸Šã€‚è¿™å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼å®ç°ï¼š<mark>ç¬¬ä¸€ç§æ˜¯æŒ‰ç§©åˆå¹¶ï¼ˆUnion by Rankï¼‰ï¼Œå®ƒå°†æ ‘çš„é«˜åº¦ä½œä¸ºè€ƒè™‘å› ç´ ï¼›ç¬¬äºŒç§æ˜¯æŒ‰å¤§å°åˆå¹¶ï¼ˆUnion by Sizeï¼‰ï¼Œå®ƒå°†æ ‘çš„å¤§å°ä½œä¸ºè€ƒè™‘å› ç´ æ¥å†³å®šå¦‚ä½•å°†ä¸€æ£µæ ‘è¿æ¥åˆ°å¦ä¸€æ£µæ ‘ã€‚</mark> è¿™ç§æ–¹æ³•ç»“åˆè·¯å¾„å‹ç¼©ï¼ˆPath Compressionï¼‰å¯ä»¥ä½¿æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ¥è¿‘å¸¸æ•°æ—¶é—´ã€‚

> The efficiency depends heavily on which tree get attached to the other. There are 2 ways in which it can be done. <mark>First is Union by Rank, which considers height of the tree as the factor and Second is Union by Size, which considers size of the tree as the factor while attaching one tree to the other .</mark> This method along with Path Compression gives complexity of nearly constant time.



#### 9.2.1 Path Compression

å¯¹ **Find** æ“ä½œçš„æ”¹è¿›ï¼š

å®ƒé€šè¿‡**å‹ç¼©æ ‘çš„é«˜åº¦**æ¥åŠ é€Ÿæ•°æ®ç»“æ„çš„è¿è¡Œã€‚è¿™å¯ä»¥é€šè¿‡åœ¨ **Find** æ“ä½œä¸­å¼•å…¥ä¸€ä¸ªå°å‹ç¼“å­˜æœºåˆ¶æ¥å®ç°ã€‚æ›´å¤šç»†èŠ‚å¯ä»¥æŸ¥çœ‹ä»£ç ï¼š

> Modifications to Find():
>
> It speeds up the data structure by **compressing the height** of the trees. It can be achieved by inserting a small caching mechanism into the **Find** operation. Take a look at the code for more details:
>

```python
# Finds the representative of the set that i
# is an element of.


def find(i):

	# If i is the parent of itself
	if Parent[i] == i:

		# Then i is the representative 
		return i
	else:

		# Recursively find the representative.
		result = find(Parent[i])

		# We cache the result by moving iâ€™s node 
		# directly under the representative of this
		# set
		Parent[i] = result
	
		# And then we return the result
		return result

# The code is contributed by Arushi Jindal. 

```



**Time Complexity**: O(log n) on average per call.



#### 9.2.2 Union by Rank

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„æ•´æ•°æ•°ç»„ï¼Œç§°ä¸º **rank[]**ã€‚è¯¥æ•°ç»„çš„å¤§å°ä¸çˆ¶æ•°ç»„ **Parent[]** ç›¸åŒã€‚å¦‚æœ **i** æ˜¯æŸä¸ªé›†åˆçš„ä»£è¡¨ï¼Œåˆ™ **rank[i]** è¡¨ç¤ºä»£è¡¨è¯¥é›†åˆçš„æ ‘çš„é«˜åº¦ã€‚

ç°åœ¨å›æƒ³ä¸€ä¸‹ï¼Œåœ¨ **Unionï¼ˆåˆå¹¶ï¼‰** æ“ä½œä¸­ï¼Œå°†å“ªä¸€æ£µæ ‘ç§»åˆ°å¦ä¸€æ£µæ ‘ä¸‹å¹¶ä¸é‡è¦ã€‚æˆ‘ä»¬ç°åœ¨å¸Œæœ›åšçš„æ˜¯**æœ€å°åŒ–ç»“æœæ ‘çš„é«˜åº¦**ã€‚å¦‚æœæˆ‘ä»¬æ­£åœ¨åˆå¹¶ä¸¤æ£µæ ‘ï¼ˆæˆ–é›†åˆï¼‰ï¼Œæˆ‘ä»¬ç§°å®ƒä»¬ä¸º **left** å’Œ **right**ï¼Œé‚£ä¹ˆè¿™å®Œå…¨å–å†³äº **left çš„ç§©** å’Œ **right çš„ç§©**ã€‚

- å¦‚æœ **left çš„ç§©** å°äº **right çš„ç§©**ï¼Œé‚£ä¹ˆæœ€å¥½å°† **left ç§»åˆ° right ä¸‹æ–¹**ï¼Œå› ä¸ºè¿™æ ·ä¸ä¼šæ”¹å˜ **right çš„ç§©**ï¼ˆè€Œå°† **right ç§»åˆ° left ä¸‹æ–¹** ä¼šå¢åŠ é«˜åº¦ï¼‰ã€‚åŒæ ·åœ°ï¼Œå¦‚æœ **right çš„ç§©** å°äº **left çš„ç§©**ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å°† **right ç§»åˆ° left ä¸‹æ–¹**ã€‚
- å¦‚æœä¸¤è€…çš„ç§©ç›¸ç­‰ï¼Œé‚£ä¹ˆæ— è®ºå“ªæ£µæ ‘ç§»åˆ°å¦ä¸€æ£µæ ‘ä¸‹éƒ½æ²¡æœ‰å…³ç³»ï¼Œä½†ç»“æœçš„ç§©æ€»æ˜¯æ¯”åŸæ¥çš„ç§©å¤§ 1ã€‚

> First of all, we need a new array of integers called **rank[]**. The size of this array is the same as the parent array **Parent[]**. If i is a representative of a set, **rank[i]** is the height of the tree representing the set. 
> Now recall that in the Union operation, it doesnâ€™t matter which of the two trees is moved under the other. Now what we want to do is minimize the height of the resulting tree. If we are uniting two trees (or sets), letâ€™s call them left and right, then it all depends on the **rank of left** and the **rank of right**. 
>
> - If the rank of **left** is less than the rank of **right**, then itâ€™s best to move **left under right**, because that wonâ€™t change the rank of right (while moving right under left would increase the height). In the same way, if the rank of right is less than the rank of left, then we should move right under left.
> - If the ranks are equal, it doesnâ€™t matter which tree goes under the other, but the rank of the result will always be one greater than the rank of the trees.
>



#### 9.2.3 Path compression and union by rank

Below is the complete implementation of disjoint set with path compression and union by rank.

```python
class DisjSet:
	def __init__(self, n):
		# Constructor to create and initialize sets of n items
		self.rank = [1] * n
		self.parent = [i for i in range(n)]


	# Finds set of given item x
	def find(self, x):
		
		# Finds the representative of the set that x is an element of
		if (self.parent[x] != x):
			
			# if x is not the parent of itself
			# Then x is not the representative of its set
			self.parent[x] = self.find(self.parent[x])
			
			# so we recursively call Find on its parent
			# and move i's node directly under the
			# representative of this set

		return self.parent[x]


	# Do union of two sets represented by x and y.
	def Union(self, x, y):
		
		# Find current sets of x and y
		xset = self.find(x)
		yset = self.find(y)

		# If they are already in same set
		if xset == yset:
			return

		# Put smaller ranked item under
		# bigger ranked item if ranks are different
		if self.rank[xset] < self.rank[yset]:
			self.parent[xset] = yset

		elif self.rank[xset] > self.rank[yset]:
			self.parent[yset] = xset

		# If ranks are same, then move y under x (doesn't matter
    # which one goes where) and increment rank of x's tree
		else:
			self.parent[yset] = xset
			self.rank[xset] = self.rank[xset] + 1

# Driver code
obj = DisjSet(5)
obj.Union(0, 2)
obj.Union(4, 2)
obj.Union(3, 1)
if obj.find(4) == obj.find(0):
	print('Yes')
else:
	print('No')
if obj.find(1) == obj.find(0):
	print('Yes')
else:
	print('No')


"""
Yes
No
"""
```



**Time complexity**: O(n) for creating n single item sets . The two techniques -path compression with the union by rank/size, the time complexity will reach nearly constant time. It turns out, that the final[ amortized time complexity](https://www.geeksforgeeks.org/introduction-to-amortized-analysis/) is O(Î±(n)), where Î±(n) is the inverse Ackermann function, which grows very steadily (it does not even exceed for $n<10^{600}$  approximately).

**Space complexity:** O(n) because we need to store n elements in the Disjoint Set Data Structure.



#### 9.2.4 Union by Size

åŒæ ·ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„æ•´æ•°æ•°ç»„ï¼Œç§°ä¸º **size[]**ã€‚è¯¥æ•°ç»„çš„å¤§å°ä¸çˆ¶æ•°ç»„ **Parent[]** ç›¸åŒã€‚å¦‚æœ **i** æ˜¯æŸä¸ªé›†åˆçš„ä»£è¡¨ï¼Œåˆ™ **size[i]** è¡¨ç¤ºä»£è¡¨è¯¥é›†åˆçš„æ ‘ä¸­å…ƒç´ çš„æ•°é‡ã€‚

ç°åœ¨æˆ‘ä»¬è¦åˆå¹¶ä¸¤æ£µæ ‘ï¼ˆæˆ–é›†åˆï¼‰ï¼Œæˆ‘ä»¬ç§°å®ƒä»¬ä¸º **left** å’Œ **right**ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™å®Œå…¨å–å†³äº **left çš„å¤§å°** å’Œ **right çš„å¤§å°**ï¼ˆå³æ ‘æˆ–é›†åˆä¸­çš„å…ƒç´ æ•°é‡ï¼‰ã€‚

- å¦‚æœ **left çš„å¤§å°** å°äº **right çš„å¤§å°**ï¼Œé‚£ä¹ˆæœ€å¥½å°† **left ç§»åˆ° right ä¸‹æ–¹**ï¼Œå¹¶å°† **right çš„å¤§å°** å¢åŠ  **left çš„å¤§å°**ã€‚åŒæ ·åœ°ï¼Œå¦‚æœ **right çš„å¤§å°** å°äº **left çš„å¤§å°**ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å°† **right ç§»åˆ° left ä¸‹æ–¹**ï¼Œå¹¶å°† **left çš„å¤§å°** å¢åŠ  **right çš„å¤§å°**ã€‚
- å¦‚æœä¸¤è€…çš„å¤§å°ç›¸ç­‰ï¼Œé‚£ä¹ˆæ— è®ºå“ªæ£µæ ‘ç§»åˆ°å¦ä¸€æ£µæ ‘ä¸‹éƒ½æ²¡æœ‰å…³ç³»ã€‚

> Again, we need a new array of integers called **size[]**. The size of this array is the same as the parent array **Parent[]**. If i is a representative of a set, **size[i]** is the number of the elements in the tree representing the set. 
> Now we are uniting two trees (or sets), letâ€™s call them left and right, then in this case it all depends on the **size of left** and the **size of right** tree (or set).
>
> - If the size of **left** is less than the size of **right**, then itâ€™s best to move **left under right** and increase size of right by size of left. In the same way, if the size of right is less than the size of left, then we should move right under left. and increase size of left by size of right.
> - If the sizes are equal, it doesnâ€™t matter which tree goes under the other.
>

```python
class UnionFind:
	def __init__(self, n):
		self.Parent = list(range(n))
		self.Size = [1] * n

	# Function to find the representative (or the root node) for the set that includes i
	def find(self, i):
		if self.Parent[i] != i:
			# Path compression: Make the parent of i the root of the set
			self.Parent[i] = self.find(self.Parent[i])
		return self.Parent[i]

	# Unites the set that includes i and the set that includes j by size
	def unionBySize(self, i, j):
		# Find the representatives (or the root nodes) for the set that includes i
		irep = self.find(i)

		# And do the same for the set that includes j
		jrep = self.find(j)

		# Elements are in the same set, no need to unite anything.
		if irep == jrep:
			return

		# Get the size of iâ€™s tree
		isize = self.Size[irep]

		# Get the size of jâ€™s tree
		jsize = self.Size[jrep]

		# If iâ€™s size is less than jâ€™s size
		if isize < jsize:
			# Then move i under j
			self.Parent[irep] = jrep

			# Increment j's size by i's size
			self.Size[jrep] += self.Size[irep]
		# Else if jâ€™s size is less than iâ€™s size
		else:
			# Then move j under i
			self.Parent[jrep] = irep

			# Increment i's size by j's size
			self.Size[irep] += self.Size[jrep]

# Example usage
n = 5
unionFind = UnionFind(n)

# Perform union operations
unionFind.unionBySize(0, 1)
unionFind.unionBySize(2, 3)
unionFind.unionBySize(0, 4)

# Print the representative of each element after unions
for i in range(n):
	print("Element {}: Representative = {}".format(i, unionFind.find(i)))

# This code is contributed by Susobhan Akhuli

"""
Element 0: Representative = 0
Element 1: Representative = 0
Element 2: Representative = 2
Element 3: Representative = 2
Element 4: Representative = 0
"""
```



**Time complexity**: O(log n) without Path Compression.





### 9.3 ç¼–ç¨‹é¢˜ç›®

#### æ™´é—®9.6.1 å­¦æ ¡çš„ç­çº§ä¸ªæ•°ï¼ˆ1ï¼‰

https://sunnywhy.com/sfbj/9/6/360

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œå¹¶ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ï¼Œé—®æ€»å…±æœ‰å¤šå°‘ä¸ªç­çº§ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $mã€n (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n, a \ne b)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

**è¾“å‡º**

è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­çº§ä¸ªæ•°ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 3
4 2
1 3
2 5
```

è¾“å‡º

```
2
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤å…±æœ‰ä¸¤ä¸ªç­çº§ã€‚



To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. The number of disjoint sets at the end will be the number of classes.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. For each student relationship, unite their sets using the union operation.
3. Count the number of unique parents. This will be the number of classes.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x: # å¦‚æœä¸æ˜¯æ ¹ç»“ç‚¹ï¼Œç»§ç»­å¾ªç¯
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))	# parent[i] == iï¼Œåˆ™è¯´æ˜å…ƒç´ iæ˜¯è¯¥é›†åˆçš„æ ¹ç»“ç‚¹

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

classes = set(find(x) for x in range(1, n + 1))
print(len(classes))
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, and then counts and prints the number of unique classes.





#### æ™´é—®9.6.2 å­¦æ ¡çš„ç­çº§äººæ•°ï¼ˆ2ï¼‰

https://sunnywhy.com/sfbj/9/6/361

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œå¹¶ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ï¼Œé—®æ€»å…±æœ‰å¤šå°‘ä¸ªç­çº§ï¼Œå¹¶æŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„äººæ•°ã€‚

è¾“å…¥

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $mã€n (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n, a \ne b)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

è¾“å‡º

ç¬¬ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­çº§ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œè‹¥å¹²ä¸ªæ•´æ•°ï¼ŒæŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„äººæ•°ã€‚æ•´æ•°ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 3
4 2
1 3
2 5
```

è¾“å‡º

```
2
3 2
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤å…±æœ‰ä¸¤ä¸ªç­çº§ï¼Œäººæ•°åˆ†åˆ«æ˜¯`3`å’Œ`2`ã€‚





To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. The number of disjoint sets at the end will be the number of classes. You can also maintain a count of the number of students in each class.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. Initialize an array `size` of size `n+1` where `size[i]` is initially `1`. This means each class initially has one student.
3. For each student relationship, unite their sets using the union operation and update the size of the new set.
4. Count the number of unique parents. This will be the number of classes.
5. Print the sizes of the classes in descending order.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x != root_y:
        parent[root_x] = root_y
        size[root_y] += size[root_x]

n, m = map(int, input().split())
parent = list(range(n + 1))
size = [1] * (n + 1)

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

#classes = [size[find(x)] for x in range(1, n + 1) if x == parent[x]]
classes = [size[x] for x in range(1, n + 1) if x == parent[x]]
print(len(classes))
print(' '.join(map(str, sorted(classes, reverse=True))))
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, counts and prints the number of unique classes, and prints the sizes of the classes in descending order.





#### æ™´é—®9.6.3 æ˜¯å¦ç›¸åŒç­çº§

https://sunnywhy.com/sfbj/9/6/362

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œå¹¶ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ã€‚ç„¶åç»™å‡º k ä¸ªæŸ¥è¯¢ï¼Œæ¯ä¸ªæŸ¥è¯¢è¯¢é—®ä¸¤ä¸ªå­¦ç”Ÿæ˜¯å¦åœ¨åŒä¸€ä¸ªç­çº§ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $nã€m (1 \le n \le 10^5, 1 \le m \le 10^5)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n, a \ne b)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç„¶åä¸€ä¸ªæ•´æ•° $k (1 \le k \le 10^3)$ï¼Œè¡¨ç¤ºæŸ¥è¯¢ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ k è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n)$ï¼Œè¡¨ç¤ºè¯¢é—®ç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿæ˜¯å¦åœ¨åŒä¸€ä¸ªç­çº§ã€‚

**è¾“å‡º**

æ¯ä¸ªæŸ¥è¯¢è¾“å‡ºä¸€è¡Œï¼Œå¦‚æœåœ¨åŒä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆè¾“å‡º`Yes`ï¼Œå¦åˆ™è¾“å‡º`No`ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 3
4 2
1 3
2 5
2
4 5
1 2
```

è¾“å‡º

```
Yes
No
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤ç¼–å·`4`å’Œ`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`å’Œ`2`çš„å­¦ç”Ÿä¸åœ¨åŒä¸€ä¸ªç­çº§ã€‚





To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. For each query, you check if the two students are in the same set.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. For each student relationship, unite their sets using the union operation.
3. For each query, check if the two students are in the same set using the find operation.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

k = int(input())
for _ in range(k):
    a, b = map(int, input().split())
    if find(a) == find(b):
        print('Yes')
    else:
        print('No')
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, and then for each query, checks and prints whether the two students are in the same class.



#### æ™´é—®9.6.4 è¿·å®«è¿é€šæ€§

https://sunnywhy.com/sfbj/9/6/363

ç°æœ‰ä¸€ä¸ªè¿·å®«ï¼Œè¿·å®«ä¸­æœ‰ n ä¸ªæˆ¿é—´ï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œæˆ¿é—´ä¸æˆ¿é—´ä¹‹é—´å¯èƒ½è¿é€šã€‚å¦‚æœæˆ¿é—´`A`å’Œæˆ¿é—´`B`è¿é€šï¼Œæˆ¿é—´`B`å’Œæˆ¿é—´`C`è¿é€šï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°æˆ¿é—´`A`å’Œæˆ¿é—´`C`ä¹Ÿè¿é€šã€‚ç»™å®š m ç»„è¿é€šå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªæˆ¿é—´è¿é€šï¼‰ï¼Œé—®è¿·å®«ä¸­çš„æ‰€æœ‰æˆ¿é—´æ˜¯å¦è¿é€šã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•°$nã€m (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºæˆ¿é—´ä¸ªæ•°ã€è¿é€šå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„æˆ¿é—´å’Œç¼–å·ä¸º`b`çš„æˆ¿é—´æ˜¯è¿é€šçš„ã€‚

**è¾“å‡º**

å¦‚æœæ‰€æœ‰æˆ¿é—´è¿é€šï¼Œé‚£ä¹ˆè¾“å‡º`Yes`ï¼Œå¦åˆ™è¾“å‡º`No`ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 4
4 2
1 3
2 5
1 5
```

è¾“å‡º

```
Yes
```

è§£é‡Š

æ‰€æœ‰æˆ¿é—´éƒ½è¿é€šï¼Œå› æ­¤è¾“å‡º`Yes`ã€‚

æ ·ä¾‹2

è¾“å…¥

```
5 3
4 2
1 3
2 5
```

è¾“å‡º

```
No
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„æˆ¿é—´äº’ç›¸è¿é€šï¼Œç¼–å·`1`ã€`3`çš„æˆ¿é—´äº’ç›¸è¿é€šï¼Œå› æ­¤æ²¡æœ‰å…¨éƒ¨äº’ç›¸è¿é€šï¼Œè¾“å‡º`No`ã€‚



To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each room is initially in its own set. When a connection between two rooms is given, you unite their sets. If at the end there is only one set, then all rooms are connected.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each room is in its own set.
2. For each connection, unite their sets using the union operation.
3. Check if all rooms are in the same set.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

sets = set(find(x) for x in range(1, n + 1))
if len(sets) == 1:
    print('Yes')
else:
    print('No')
```

This code reads the number of rooms and connections from the input, initializes each room to be in its own set, unites the sets of each pair of rooms that have a connection, and then checks and prints whether all rooms are in the same set.





#### æ™´é—®9.6.5 ç­çº§æœ€é«˜åˆ†

https://sunnywhy.com/sfbj/9/6/364

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œæ¯ä¸ªå­¦ç”Ÿæœ‰ä¸€ä¸ªè€ƒè¯•åˆ†æ•°ï¼Œå†ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ï¼Œé—®æ€»å…±æœ‰å¤šå°‘ä¸ªç­çº§ï¼Œå¹¶æŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„æœ€é«˜è€ƒè¯•åˆ†æ•°ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $nã€m (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œä¸ºç”¨ç©ºæ ¼éš”å¼€çš„ n ä¸ªæ•´æ•°ï¼ˆ$0 \le æ¯ä¸ªæ•´æ•° \le 100$ï¼‰ï¼Œè¡¨ç¤ºä¸ªå­¦ç”Ÿçš„è€ƒè¯•åˆ†æ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

**è¾“å‡º**

ç¬¬ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­çº§ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œè‹¥å¹²ä¸ªæ•´æ•°ï¼ŒæŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„æœ€é«˜è€ƒè¯•åˆ†æ•°ã€‚æ•´æ•°ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥



```
5 3
88 90 86 92 95
4 2
1 3
2 5
```

è¾“å‡º

```
2
95 88
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤å…±æœ‰ä¸¤ä¸ªç­çº§ï¼Œæœ€é«˜åˆ†æ•°åˆ†åˆ«æ˜¯ç¼–å·`1`çš„å­¦ç”Ÿçš„`88`åˆ†ã€ç¼–å·`5`çš„å­¦ç”Ÿçš„`95`åˆ†ã€‚



To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. The number of disjoint sets at the end will be the number of classes. You can also maintain a list of scores for each class and find the maximum score for each class.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. Initialize an array `scores` of size `n+1` to store the scores of each student.
3. For each student relationship, unite their sets using the union operation.
4. For each class, find the maximum score.
5. Count the number of unique parents. This will be the number of classes.
6. Print the maximum scores of the classes in descending order.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x != root_y:
        parent[root_x] = root_y
        scores[root_y] = max(scores[root_y], scores[root_x])

n, m = map(int, input().split())
parent = list(range(n + 1))
scores = list(map(int, input().split()))
scores.insert(0, 0)  # to make the scores 1-indexed

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

classes_scores = [scores[find(x)] for x in range(1, n + 1) if x == parent[x]]
print(len(classes_scores))
print(' '.join(map(str, sorted(classes_scores, reverse=True))))
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, finds the maximum score for each class, counts and prints the number of unique classes, and prints the maximum scores of the classes in descending order.





#### T01182: é£Ÿç‰©é“¾

å¹¶æŸ¥é›†, http://cs101.openjudge.cn/practice/01182

åŠ¨ç‰©ç‹å›½ä¸­æœ‰ä¸‰ç±»åŠ¨ç‰©A,B,Cï¼Œè¿™ä¸‰ç±»åŠ¨ç‰©çš„é£Ÿç‰©é“¾æ„æˆäº†æœ‰è¶£çš„ç¯å½¢ã€‚AåƒBï¼Œ BåƒCï¼ŒCåƒAã€‚
ç°æœ‰Nä¸ªåŠ¨ç‰©ï¼Œä»¥1ï¼Nç¼–å·ã€‚æ¯ä¸ªåŠ¨ç‰©éƒ½æ˜¯A,B,Cä¸­çš„ä¸€ç§ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸çŸ¥é“å®ƒåˆ°åº•æ˜¯å“ªä¸€ç§ã€‚
æœ‰äººç”¨ä¸¤ç§è¯´æ³•å¯¹è¿™Nä¸ªåŠ¨ç‰©æ‰€æ„æˆçš„é£Ÿç‰©é“¾å…³ç³»è¿›è¡Œæè¿°ï¼š
ç¬¬ä¸€ç§è¯´æ³•æ˜¯"1 X Y"ï¼Œè¡¨ç¤ºXå’ŒYæ˜¯åŒç±»ã€‚
ç¬¬äºŒç§è¯´æ³•æ˜¯"2 X Y"ï¼Œè¡¨ç¤ºXåƒYã€‚
æ­¤äººå¯¹Nä¸ªåŠ¨ç‰©ï¼Œç”¨ä¸Šè¿°ä¸¤ç§è¯´æ³•ï¼Œä¸€å¥æ¥ä¸€å¥åœ°è¯´å‡ºKå¥è¯ï¼Œè¿™Kå¥è¯æœ‰çš„æ˜¯çœŸçš„ï¼Œæœ‰çš„æ˜¯å‡çš„ã€‚å½“ä¸€å¥è¯æ»¡è¶³ä¸‹åˆ—ä¸‰æ¡ä¹‹ä¸€æ—¶ï¼Œè¿™å¥è¯å°±æ˜¯å‡è¯ï¼Œå¦åˆ™å°±æ˜¯çœŸè¯ã€‚
1ï¼‰ å½“å‰çš„è¯ä¸å‰é¢çš„æŸäº›çœŸçš„è¯å†²çªï¼Œå°±æ˜¯å‡è¯ï¼›
2ï¼‰ å½“å‰çš„è¯ä¸­Xæˆ–Yæ¯”Nå¤§ï¼Œå°±æ˜¯å‡è¯ï¼›
3ï¼‰ å½“å‰çš„è¯è¡¨ç¤ºXåƒXï¼Œå°±æ˜¯å‡è¯ã€‚
ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ç»™å®šçš„Nï¼ˆ1 <= N <= 50,000ï¼‰å’ŒKå¥è¯ï¼ˆ0 <= K <= 100,000ï¼‰ï¼Œè¾“å‡ºå‡è¯çš„æ€»æ•°ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°Nå’ŒKï¼Œä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚
ä»¥ä¸‹Kè¡Œæ¯è¡Œæ˜¯ä¸‰ä¸ªæ­£æ•´æ•° Dï¼ŒXï¼ŒYï¼Œä¸¤æ•°ä¹‹é—´ç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œå…¶ä¸­Dè¡¨ç¤ºè¯´æ³•çš„ç§ç±»ã€‚
è‹¥D=1ï¼Œåˆ™è¡¨ç¤ºXå’ŒYæ˜¯åŒç±»ã€‚
è‹¥D=2ï¼Œåˆ™è¡¨ç¤ºXåƒYã€‚

**è¾“å‡º**

åªæœ‰ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå‡è¯çš„æ•°ç›®ã€‚

æ ·ä¾‹è¾“å…¥

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
```

æ ·ä¾‹è¾“å‡º

```
3
```

æ¥æº: Noi 01



```python
class DisjointSet:
    def __init__(self, n):
        #è®¾[1,n] åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n+1,2*n]è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n+1,3*n]è¡¨ç¤ºåƒxçš„åŠ¨ç‰©ã€‚
        self.parent = [i for i in range(3 * n + 1)] # æ¯ä¸ªåŠ¨ç‰©æœ‰ä¸‰ç§å¯èƒ½çš„ç±»å‹ï¼Œç”¨ 3 * n æ¥è¡¨ç¤ºæ¯ç§ç±»å‹çš„å¹¶æŸ¥é›†
        self.rank = [0] * (3 * n + 1)

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu == pv:
            return False
        if self.rank[pu] > self.rank[pv]:
            self.parent[pv] = pu
        elif self.rank[pu] < self.rank[pv]:
            self.parent[pu] = pv
        else:
            self.parent[pv] = pu
            self.rank[pu] += 1
        return True


def is_valid(n, k, statements):
    dsu = DisjointSet(n)

    def find_disjoint_set(x):
        if x > n:
            return False
        return True

    false_count = 0
    for d, x, y in statements:
        if not find_disjoint_set(x) or not find_disjoint_set(y):
            false_count += 1
            continue
        if d == 1:  # X and Y are of the same type
            if dsu.find(x) == dsu.find(y + n) or dsu.find(x) == dsu.find(y + 2 * n):
                false_count += 1
            else:
                dsu.union(x, y)
                dsu.union(x + n, y + n)
                dsu.union(x + 2 * n, y + 2 * n)
        else:  # X eats Y
            if dsu.find(x) == dsu.find(y) or dsu.find(x + 2*n) == dsu.find(y):
                false_count += 1
            else: #[1,n] åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n+1,2*n]è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n+1,3*n]è¡¨ç¤ºåƒxçš„åŠ¨ç‰©
                dsu.union(x + n, y)
                dsu.union(x, y + 2 * n)
                dsu.union(x + 2 * n, y + n)

    return false_count


if __name__ == "__main__":
    N, K = map(int, input().split())
    statements = []
    for _ in range(K):
        D, X, Y = map(int, input().split())
        statements.append((D, X, Y))
    result = is_valid(N, K, statements)
    print(result)

```



ã€ŠæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›ï¼ˆç¬¬2ç‰ˆï¼‰ã€‹çš„2.4.4å¹¶æŸ¥é›†ï¼Œä¹Ÿæœ‰è®²åˆ°ã€‚

```python
# å¹¶æŸ¥é›†ï¼Œhttps://zhuanlan.zhihu.com/p/93647900/
'''
æˆ‘ä»¬è®¾[0,n)åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n,2*n)åŒºé—´è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n,3*n)è¡¨ç¤ºåƒxçš„åŠ¨ç‰©ã€‚

å¦‚æœæ˜¯å…³ç³»1ï¼š
ã€€ã€€å°†yå’Œxåˆå¹¶ã€‚å°†yåƒçš„ä¸xåƒçš„åˆå¹¶ã€‚å°†åƒyçš„å’Œåƒxçš„åˆå¹¶ã€‚
å¦‚æœæ˜¯å…³ç³»2ï¼š
ã€€ã€€å°†yå’Œxåƒçš„åˆå¹¶ã€‚å°†åƒyçš„ä¸xåˆå¹¶ã€‚å°†yåƒçš„ä¸åƒxçš„åˆå¹¶ã€‚
åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/qq_34594236/article/details/72587829
'''
# p = [0]*150001

def find(x):	# å¹¶æŸ¥é›†æŸ¥è¯¢
    if p[x] == x:
        return x
    else:
        p[x] = find(p[x])	# çˆ¶èŠ‚ç‚¹è®¾ä¸ºæ ¹èŠ‚ç‚¹ã€‚ç›®çš„æ˜¯è·¯å¾„å‹ç¼©ã€‚
        return p[x]

n,k = map(int, input().split())

p = [0]*(3*n + 1)
for i in range(3*n+1):	#å¹¶æŸ¥é›†åˆå§‹åŒ–
    p[i] = i

ans = 0
for _ in range(k):
    a,x,y = map(int, input().split())
    if x>n or y>n:
        ans += 1; continue
    
    if a==1:
        if find(x+n)==find(y) or find(y+n)==find(x):
            ans += 1; continue
        
        # åˆå¹¶
        p[find(x)] = find(y)				
        p[find(x+n)] = find(y+n)
        p[find(x+2*n)] = find(y+2*n)
    else:
        if find(x)==find(y) or find(y+n)==find(x):
            ans += 1; continue
        p[find(x+n)] = find(y)
        p[find(y+2*n)] = find(x)
        p[find(x+2*n)] = find(y+n)

print(ans)
```



# é™„å½•

## A æ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Treeï¼‰

æ ‘çŠ¶æ•°ç»„æˆ–äºŒå‰ç´¢å¼•æ ‘ï¼ˆè‹±è¯­ï¼šBinary Indexed Treeï¼‰ï¼Œåˆä»¥å…¶å‘æ˜è€…å‘½åä¸ºFenwickæ ‘ï¼Œæœ€æ—©ç”±Peter M. Fenwickäº1994å¹´ä»¥A New Data Structure for Cumulative Frequency Tablesä¸ºé¢˜å‘è¡¨ã€‚å…¶åˆè¡·æ˜¯è§£å†³æ•°æ®å‹ç¼©é‡Œçš„ç´¯ç§¯é¢‘ç‡ï¼ˆCumulative Frequencyï¼‰çš„è®¡ç®—é—®é¢˜ï¼Œç°å¤šç”¨äºé«˜æ•ˆè®¡ç®—æ•°åˆ—çš„<mark>å‰ç¼€å’Œï¼Œ åŒºé—´å’Œ</mark>ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœåœ¨æŸ¥è¯¢çš„è¿‡ç¨‹ä¸­å…ƒç´ å¯èƒ½å‘ç”Ÿæ”¹å˜ï¼ˆä¾‹å¦‚æ’å…¥ã€ä¿®æ”¹æˆ–åˆ é™¤ï¼‰ï¼Œå°±ç§°è¿™ç§æŸ¥è¯¢ä¸º<mark>åœ¨çº¿æŸ¥è¯¢</mark>;å¦‚æœåœ¨æŸ¥è¯¢è¿‡ç¨‹ä¸­å…ƒç´ ä¸å‘ç”Ÿæ”¹å˜ï¼Œå°±ç§°ä¸º**ç¦»çº¿æŸ¥è¯¢**ã€‚



> äºŒå‰ç´¢å¼•æ ‘ï¼ˆæ ‘çŠ¶æ•°ç»„ï¼‰ç”¨äºå¤„ç†å¯¹å›ºå®šå¤§å°çš„æ•°ç»„è¿›è¡Œä»¥ä¸‹å¤šç§æ“ä½œçš„è¿™ç±»é—®é¢˜ã€‚
>
> - å‰ç¼€æ“ä½œï¼ˆæ±‚å’Œã€æ±‚ç§¯ã€å¼‚æˆ–ã€æŒ‰ä½æˆ–ç­‰ï¼‰ã€‚æ³¨æ„ï¼ŒåŒºé—´æ“ä½œä¹Ÿå¯ä»¥é€šè¿‡å‰ç¼€æ¥è§£å†³ã€‚ä¾‹å¦‚ï¼Œä»ç´¢å¼•Låˆ°Rçš„åŒºé—´å’Œç­‰äºåˆ°Rï¼ˆåŒ…å«Rï¼‰çš„å‰ç¼€å’Œå‡å»åˆ°L - 1çš„å‰ç¼€å’Œã€‚
> - æ›´æ–°æ•°ç»„ä¸­çš„ä¸€ä¸ªå…ƒç´ 
>
> è¿™ä¸¤ç§æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º$O(logN)$ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬éœ€è¦$O(NlogN)$çš„é¢„å¤„ç†æ—¶é—´å’Œ$O(N)$çš„è¾…åŠ©ç©ºé—´ã€‚
>
> 
>
> è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹é—®é¢˜æ¥ç†è§£äºŒå‰ç´¢å¼•æ ‘ï¼ˆBinary Indexed Tree, BITï¼‰ï¼š
> æˆ‘ä»¬æœ‰ä¸€ä¸ªæ•°ç»„ $arr[0 . . . n-1]$ã€‚æˆ‘ä»¬å¸Œæœ›å®ç°ä¸¤ä¸ªæ“ä½œï¼š
>
> 1. è®¡ç®—å‰iä¸ªå…ƒç´ çš„å’Œã€‚
> 2. ä¿®æ”¹æ•°ç»„ä¸­æŒ‡å®šä½ç½®çš„å€¼ï¼Œå³è®¾ç½® $arr[i] = x$ï¼Œå…¶ä¸­ $0 \leq i \leq n-1$ã€‚
>
> ä¸€ä¸ªç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯ä» 0 åˆ° i-1 éå†å¹¶è®¡ç®—è¿™äº›å…ƒç´ çš„æ€»å’Œã€‚è¦æ›´æ–°ä¸€ä¸ªå€¼ï¼Œåªéœ€æ‰§è¡Œ $arr[i] = x$ã€‚ç¬¬ä¸€ä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(N)$ï¼Œè€Œç¬¬äºŒä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(1)$ã€‚å¦ä¸€ç§ç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åˆ›å»ºä¸€ä¸ªé¢å¤–çš„æ•°ç»„ï¼Œå¹¶åœ¨è¿™ä¸ªæ–°æ•°ç»„çš„ç¬¬iä¸ªä½ç½®å­˜å‚¨å‰iä¸ªå…ƒç´ çš„æ€»å’Œã€‚è¿™æ ·ï¼Œç»™å®šèŒƒå›´çš„å’Œå¯ä»¥åœ¨$O(1)$æ—¶é—´å†…è®¡ç®—å‡ºæ¥ï¼Œä½†æ˜¯æ›´æ–°æ“ä½œç°åœ¨éœ€è¦$O(N)$æ—¶é—´ã€‚å½“æŸ¥è¯¢æ“ä½œéå¸¸å¤šè€Œæ›´æ–°æ“ä½œéå¸¸å°‘æ—¶ï¼Œè¿™ç§æ–¹æ³•è¡¨ç°è‰¯å¥½ã€‚
>
> **æˆ‘ä»¬èƒ½å¦åœ¨$O(log N)$æ—¶é—´å†…åŒæ—¶å®ŒæˆæŸ¥è¯¢å’Œæ›´æ–°æ“ä½œå‘¢ï¼Ÿ**
> ä¸€ç§é«˜æ•ˆçš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨æ®µæ ‘ï¼ˆSegment Treeï¼‰ï¼Œå®ƒèƒ½å¤Ÿåœ¨$O(logN)$æ—¶é—´å†…å®Œæˆè¿™ä¸¤ä¸ªæ“ä½œã€‚
> å¦ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯äºŒå‰ç´¢å¼•æ ‘ï¼ˆBinary Indexed Treeï¼Œä¹Ÿç§°ä½œFenwick Treeï¼‰ï¼ŒåŒæ ·èƒ½å¤Ÿä»¥$O(logN)$çš„æ—¶é—´å¤æ‚åº¦å®ŒæˆæŸ¥è¯¢å’Œæ›´æ–°æ“ä½œã€‚ä¸æ®µæ ‘ç›¸æ¯”ï¼ŒäºŒå‰ç´¢å¼•æ ‘æ‰€éœ€çš„ç©ºé—´æ›´å°‘ï¼Œä¸”å®ç°èµ·æ¥æ›´åŠ ç®€å•ã€‚



### lowbit è¿ç®—

äºŒè¿›åˆ¶ä¸­ä¸€ä¸ªç»å…¸åº”ç”¨æ˜¯ lowbit è¿ç®—ï¼Œå³ `lowbit(x) = x & (-x)`ã€‚

**æ•´æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºå¸¸ç”¨çš„æ–¹å¼ä¹‹ä¸€æ˜¯ä½¿ç”¨è¡¥ç **

è¡¥ç æ˜¯ä¸€ç§è¡¨ç¤ºæœ‰ç¬¦å·æ•´æ•°çš„æ–¹æ³•ï¼Œå®ƒå°†è´Ÿæ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºè½¬æ¢ä¸ºæ­£æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºã€‚è¡¥ç çš„ä¼˜åŠ¿åœ¨äºå¯ä»¥ä½¿ç”¨ç›¸åŒçš„ç®—æœ¯è¿ç®—è§„åˆ™æ¥å¤„ç†æ­£æ•°å’Œè´Ÿæ•°ï¼Œè€Œä¸éœ€è¦ç‰¹æ®Šçš„æ“ä½œã€‚

åœ¨è¡¥ç è¡¨ç¤ºä¸­ï¼Œæœ€é«˜ä½ç”¨äºè¡¨ç¤ºç¬¦å·ä½ï¼Œ0è¡¨ç¤ºæ­£æ•°ï¼Œ1è¡¨ç¤ºè´Ÿæ•°ã€‚å…¶ä»–ä½è¡¨ç¤ºæ•°å€¼éƒ¨åˆ†ã€‚

å…·ä½“å°†ä¸€ä¸ªæ•´æ•°è½¬æ¢ä¸ºè¡¥ç çš„æ­¥éª¤å¦‚ä¸‹ï¼š

1. å¦‚æœæ•´æ•°æ˜¯æ­£æ•°ï¼Œåˆ™è¡¥ç ç­‰äºäºŒè¿›åˆ¶è¡¨ç¤ºæœ¬èº«ã€‚
2. å¦‚æœæ•´æ•°æ˜¯è´Ÿæ•°ï¼Œåˆ™éœ€è¦å…ˆå°†å…¶ç»å¯¹å€¼è½¬æ¢ä¸ºäºŒè¿›åˆ¶ï¼Œç„¶åå–åï¼Œæœ€ååŠ 1ã€‚ç­‰ä»·äº<mark>æŠŠäºŒè¿›åˆ¶æœ€å³è¾¹çš„1çš„å·¦è¾¹çš„æ¯ä¸€ä½éƒ½å–å</mark>ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾è¦å°† -12 è½¬æ¢ä¸ºè¡¥ç ï¼š

1. 12çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸º00001100ã€‚

2. å°†å…¶å–åå¾—åˆ°11110011ã€‚

3. åŠ 1å¾—åˆ°11110100ï¼Œè¿™å°±æ˜¯ -12 çš„è¡¥ç è¡¨ç¤ºã€‚


é€šè¿‡`lowbit(x) = x & (-x)`å°±æ˜¯å– x çš„äºŒè¿›åˆ¶æœ€å³è¾¹çš„1å’Œå®ƒå³è¾¹æ‰€æœ‰çš„0ï¼Œå› æ­¤å®ƒä¸€å®šæ˜¯2çš„å¹‚æ¬¡ï¼Œå³1ã€2ã€4ã€8ç­‰ã€‚

å¯¹ x = 12 = $(00001100)_2$ï¼Œæœ‰ -x = $(11110100)_2$ ï¼Œx & (-x) = 4

å¯¹ x= 6 = $(110)_2$ï¼Œæœ‰ -x = $(010)_2$ï¼Œx & (-x) = 2



### è¡¨ç¤ºæ–¹å¼

æ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Treeï¼ŒBITï¼‰ç”¨æ•°ç»„å½¢å¼è¡¨ç¤ºã€‚å®ƒå…¶å®ä»ç„¶æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”ä¸ sum æ•°ç»„ç±»ä¼¼ï¼Œæ˜¯ä¸€ä¸ªç”¨æ¥è®°å½•å’Œçš„æ•°ç»„ï¼Œåªä¸è¿‡å®ƒå­˜æ”¾çš„ä¸æ˜¯å‰ i ä¸ªæ•´æ•°ä¹‹å’Œï¼Œè€Œæ˜¯åœ¨ <mark>i å·ä½ä¹‹å‰ï¼ˆå«iå·ä½ï¼‰lowbit(i) ä¸ªæ•´æ•°ä¹‹å’Œ</mark>ã€‚æ ‘çŠ¶æ•°ç»„çš„å¤§å°ç­‰äºè¾“å…¥æ•°ç»„çš„å¤§å°ï¼Œè®°ä¸ºnã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œä¸ºäº†ä¾¿äºå®ç°ï¼Œä½¿ç”¨n+1çš„å¤§å°ã€‚

å¦‚ä¸‹å›¾ æ‰€ç¤ºï¼Œæ•°ç»„Aæ˜¯åŸå§‹æ•°ç»„ï¼Œæœ‰ A[1]~ A[16]å…± 16ä¸ªå…ƒç´ ï¼›æ•°ç»„ Cæ˜¯æ ‘çŠ¶æ•°ç»„ï¼Œå…¶ä¸­ C[i]å­˜æ”¾æ•°ç»„ A ä¸­iå·ä½ä¹‹å‰ lowbit(i) ä¸ªå…ƒç´ ä¹‹å’Œã€‚æ˜¾ç„¶ï¼Œ<mark>C[i]çš„è¦†ç›–é•¿åº¦æ˜¯ lowbit(i)ï¼ˆä¹Ÿå¯ä»¥ç†è§£æˆç®¡è¾–èŒƒå›´ï¼‰</mark>ï¼Œå®ƒæ˜¯2çš„å¹‚æ¬¡ï¼Œå³ 1ã€2ã€4ã€8ç­‰ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ ‘çŠ¶æ•°ç»„ä»æ—§æ˜¯ä¸€ä¸ªå¹³å¦çš„æ•°ç»„ï¼Œç”»æˆæ ‘å½¢æ˜¯ä¸ºäº†è®©å­˜å‚¨çš„å…ƒç´ æ›´å®¹æ˜“è§‚å¯Ÿã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250320134426632.png" alt="image-20250320134426632" style="zoom: 67%;" />

<center>å›¾ æ ‘çŠ¶æ•°ç»„å®šä¹‰å›¾</center>



```
C[1] = A[1]  													(é•¿åº¦ä¸º lowbit(1) = 1) 
C[2] = A[1] + A[2]  									(é•¿åº¦ä¸º lowbit(2) = 2) 
C[3] = A[3]  													(é•¿åº¦ä¸º lowbit(3) = 1) 
C[4] = A[1] + A[2] + A[3] + A[4]  		(é•¿åº¦ä¸º lowbit(4) = 4) 
C[5] = A[5]  													(é•¿åº¦ä¸º lowbit(5) = 1) 
C[6] = A[5] + A[6]  									(é•¿åº¦ä¸º lowbit(6) = 2) 
C[7] = A[7]  													(é•¿åº¦ä¸º lowbit(7) = 1) 
C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]  (é•¿åº¦ä¸º lowbit(8) = 8) 
```

<mark>æ ‘çŠ¶æ•°ç»„çš„å®šä¹‰éå¸¸é‡è¦ï¼Œç‰¹åˆ«æ˜¯â€œC[i]çš„è¦†ç›–é•¿åº¦æ˜¯ lowbit(i)â€è¿™ç‚¹ï¼›å¦å¤–ï¼Œæ ‘çŠ¶æ•°ç»„çš„ä¸‹æ ‡å¿…é¡»ä»1å¼€å§‹</mark>ã€‚æ¥ä¸‹æ¥æ€è€ƒä¸€ä¸‹ï¼Œåœ¨è¿™æ ·çš„å®šä¹‰ä¸‹ï¼Œ
æ€æ ·è§£å†³ä¸‹é¢ä¸¤ä¸ªé—®é¢˜ï¼š

â‘  è®¾è®¡å‡½æ•° get_sum(x)ï¼Œè¿”å›å‰xä¸ªæ•°ä¹‹å’Œ A[1]+...+ A[x]ã€‚

â‘¡ è®¾è®¡å‡½æ•° update_bit(x,v)ï¼Œå®ç°å°†ç¬¬xä¸ªæ•°åŠ ä¸Šä¸€ä¸ªæ•°vçš„åŠŸèƒ½ï¼Œå³ A[x]+= vã€‚

å…ˆæ¥çœ‹ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå³å¦‚ä½•è®¾è®¡å‡½æ•° get_sum(x)ï¼Œè¿”å›å‰xä¸ªæ•°ä¹‹å’Œã€‚ä¸å¦¨å…ˆçœ‹ä¸ªä¾‹å­ã€‚å‡è®¾æƒ³è¦æŸ¥è¯¢ A[1]+â€¦+A[14]ï¼Œé‚£ä¹ˆä»æ ‘çŠ¶æ•°ç»„çš„å®šä¹‰å‡ºå‘ï¼Œå®ƒå®é™…æ˜¯ä»€ä¹ˆä¸œè¥¿å‘¢? å›åˆ°ä¸Šå›¾ï¼Œå¾ˆå®¹æ˜“å‘ç° A[1]+â€¦+A[14] = C[8]+C[12]+ C[14]ã€‚åˆæ¯”å¦‚è¦æŸ»è¯¢ A[1]+â€¦A[11]ï¼Œä»å›¾ä¸­åŒæ ·å¯ä»¥å¾—åˆ° A[1]+â€¦+A[11] = C[8]+C[10]+ C[11]ã€‚é‚£ä¹ˆæ€æ ·çŸ¥é“ A[1]+â€¦+ A[x]å¯¹åº”çš„æ˜¯æ ‘çŠ¶æ•°ç»„ä¸­çš„å“ªäº›é¡¹å‘¢ï¼Ÿäº‹å®ä¸Šè¿™å¾ˆç®€å•ã€‚è®° SUM(1,x) = A[1]+â€¦â€¦+A[x]ï¼Œç”±äº C[x]çš„è¦†ç›–é•¿åº¦æ˜¯ lowbit(x)ï¼Œå› æ­¤

C[x] = A[x-lowbit(x)+1]+...+ A[x]

äºæ˜¯å¯ä»¥å¾—åˆ°

```
SUM(1,x) = A[1] +Â·Â·Â·+ A[x]
				=A[1] +Â·Â·Â·+ A[x-lowbit(x)] + A[x-lowbit(x)+1] +Â·Â·Â·+ A[x]
				=SUM(1,x-lowbit(x)) + C[x]
```

è¿™æ ·å°±æŠŠ SUM(1,x)è½¬æ¢ä¸º SUM(1,x-lowbit(x))äº†ã€‚

æ¥ç€å°±èƒ½å†™å‡º get_sum å‡½æ•°äº†ï¼Œå…¶ä¸­BITTreeæ˜¯æ ‘çŠ¶æ•°ç»„ã€‚

```python
def bit_sum(BIT, i):
    s = 0
    i += 1  # index in BIT[] is 1 more than the index in arr[]

    while i > 0:  # Traverse ancestors of BIT[index]
        s += BIT[i]
        i -= i & (-i)  # Move index to parent node
    return s
```

ç”±äº lowbit(i)çš„ä½œç”¨æ˜¯å®šä½içš„äºŒè¿›åˆ¶ä¸­æœ€å³è¾¹çš„1ï¼Œå› æ­¤ `i = i- lowbit(i)` äº‹å®ä¸Šæ˜¯ä¸æ–­æŠŠiçš„äºŒè¿›åˆ¶ä¸­æœ€å³è¾¹çš„1ç½®ä¸º0çš„è¿‡ç¨‹ã€‚æ‰€ä»¥ get_sum å‡½æ•°çš„ for å¾ªç¯æ‰§è¡Œæ¬¡æ•°ä¸ºxçš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ã€‚ä¸€ä¸ªæ•°nçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­è®¾ç½®ä½çš„æ•°é‡æ˜¯O(logn)ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œget_sum å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(logN)$ã€‚ä»å¦ä¸€ä¸ªè§’åº¦ç†è§£,ç»“åˆå›¾ä¼šå‘ç°ï¼Œget_sum å‡½æ•°çš„è¿‡ç¨‹å®é™…ä¸Šæ˜¯åœ¨æ²¿ç€ä¸€æ¡ä¸æ–­å·¦ä¸Šçš„è·¯å¾„è¡Œè¿›ï¼ˆå¯ä»¥æƒ³ä¸€æƒ³ get_sum(14)è·Ÿ get_sum(11)çš„è¿‡ç¨‹ï¼‰ã€‚äºæ˜¯ç”±äºâ€œæ ‘â€é«˜æ˜¯ $O(logN)$çº§åˆ«,å› æ­¤å¯ä»¥åŒæ ·å¾—åˆ° get_sum å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(logN)$ã€‚å¦å¤–ï¼Œ<mark>å¦‚æœè¦æ±‚æ•°ç»„ä¸‹æ ‡åœ¨åŒºé—´[x,y]å†…çš„æ•°ä¹‹å’Œï¼Œå³ A[x] + A[x+1] +â€¦+ A[y]ï¼Œå¯ä»¥è½¬æ¢æˆ get_sum(y) - get_sum(x-1)æ¥è§£å†³ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„æŠ€å·§</mark>ã€‚



æ¥ç€æ¥çœ‹ç¬¬äºŒä¸ªé—®é¢˜ï¼Œå³å¦‚ä½•è®¾è®¡å‡½æ•° update(x,v)ï¼Œå®ç°å°†ç¬¬xä¸ªæ•°åŠ ä¸Šä¸€ä¸ªæ•°vçš„åŠŸ
èƒ½ã€‚
æ¥çœ‹ä¸¤ä¸ªä¾‹å­ã€‚å‡å¦‚è¦è®© A[6]åŠ ä¸Šä¸€ä¸ªæ•° vï¼Œé‚£ä¹ˆå°±è¦å¯»æ‰¾æ ‘çŠ¶æ•°ç»„Cä¸­èƒ½è¦†ç›–äº† A[6]çš„å…ƒç´ ï¼Œè®©å®ƒä»¬éƒ½åŠ ä¸Š vã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœè¦è®© A[6]åŠ ä¸Š vï¼Œå®é™…ä¸Šæ˜¯è¦è®©C[6]ã€C[8]ã€C[16]éƒ½åŠ ä¸Š vã€‚åŒæ ·ï¼Œå¦‚æœè¦å°† A[9]åŠ ä¸Šä¸€ä¸ªæ•° v,å®é™…ä¸Šå°±æ˜¯è¦è®© C[9]ã€C[10]ã€C[12]ã€C[16]éƒ½åŠ ä¸Š vã€‚äºæ˜¯é—®é¢˜åˆæ¥äº†â€”â€”æƒ³è¦ç»™ A[x]åŠ ä¸Švæ—¶ï¼Œæ€æ ·å»å¯»æ‰¾æ ‘çŠ¶æ•°ç»„ä¸­çš„å¯¹åº”é¡¹å‘¢?

è¦è®© A[x]åŠ ä¸Š vï¼Œå°±æ˜¯è¦å¯»æ‰¾æ ‘çŠ¶æ•°ç»„ C ä¸­èƒ½è¦†ç›– A[x]çš„é‚£äº›å…ƒç´ ï¼Œè®©å®ƒä»¬éƒ½åŠ ä¸Š vã€‚è€Œä»å›¾ 1ä¸­ç›´è§‚åœ°çœ‹ï¼Œåªéœ€è¦æ€»æ˜¯å¯»æ‰¾ç¦»å½“å‰çš„â€œçŸ©å½¢â€C[x]æœ€è¿‘çš„â€œçŸ©å½¢â€C[y]ï¼Œä½¿å¾— C[y]èƒ½å¤Ÿè¦†ç›– C[x]å³å¯ã€‚ä¾‹å¦‚è¦è®© A[6]åŠ ä¸Š vï¼Œå°±ä» C[6]å¼€å§‹æ‰¾èµ·ï¼šç¦» C[6]æœ€è¿‘çš„èƒ½è¦†ç›– C[6]çš„â€œçŸ©å½¢â€æ˜¯ C[8]ï¼Œç¦» C[8]æœ€è¿‘çš„èƒ½è¦†ç›– C[8]çš„â€œçŸ©å½¢â€æ˜¯ C[16]ï¼Œäºæ˜¯åªè¦æŠŠ C[6]ã€C[8]ã€C[16]éƒ½åŠ ä¸Švå³å¯ã€‚

é‚£ä¹ˆï¼Œå¦‚ä½•æ‰¾åˆ°è·ç¦»å½“å‰çš„ C[x]æœ€è¿‘çš„èƒ½è¦†ç›– C[x]çš„ C[y]å‘¢ï¼Ÿé¦–å…ˆï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªæ˜¾ç„¶çš„ç»“è®ºï¼šlowbit(y)å¿…é¡»å¤§äº lowbit(x)ï¼ˆä¸ç„¶æ€ä¹ˆè¦†ç›–å‘¢â€¦â€¦ï¼‰ã€‚äºæ˜¯é—®é¢˜ç­‰ä»·äºæ±‚ä¸€ä¸ªå°½å¯èƒ½å°çš„æ•´æ•° aï¼Œä½¿å¾— lowbit(x+a)>lowbit(x)ã€‚æ˜¾ç„¶ï¼Œç”±äº lowbit(x)æ˜¯å–xçš„äºŒè¿›åˆ¶æœ€å³è¾¹çš„1çš„ä½ç½®ï¼Œå› æ­¤å¦‚æœ lowbit(a) < lowbit(x)ï¼Œlowbit(x+ a)å°±ä¼šå°äº lowbit(x)ã€‚ä¸ºæ­¤ lowbit(a)å¿…é¡»ä¸å°äº lowbit(x)ã€‚æ¥ç€å‘ç°ï¼Œå½“aå– lowbit(x)æ—¶ï¼Œç”±äºxå’Œaçš„äºŒè¿›åˆ¶æœ€å³è¾¹çš„1çš„ä½ç½®ç›¸åŒ,å› æ­¤x+aä¼šåœ¨è¿™ä¸ª1çš„ä½ç½®ä¸Šäº§ç”Ÿè¿›ä½ï¼Œä½¿å¾—è¿›ä½è¿‡ç¨‹ä¸­çš„æ‰€æœ‰è¿ç»­çš„1å˜æˆ0ï¼Œç›´åˆ°æŠŠå®ƒä»¬å·¦è¾¹ç¬¬ä¸€ä¸ª0ç½®ä¸º1æ—¶ç»“æŸã€‚äºæ˜¯lowbit(x+a)>lowbit(x)æ˜¾ç„¶æˆç«‹,æœ€å°çš„aå°±æ˜¯lowbit(x)ã€‚äºæ˜¯ update å‡½æ•°çš„åšæ³•å°±å¾ˆæ˜ç¡®äº†ï¼Œåªè¦è®©xä¸æ–­åŠ ä¸Š lowbit(x)ï¼Œå¹¶è®©æ¯æ­¥çš„ C[x]éƒ½åŠ ä¸Š vï¼Œç›´åˆ°xè¶…è¿‡ç»™å®šçš„æ•°æ®èŒƒå›´ä¸ºæ­¢ã€‚ä»£ç å¦‚ä¸‹ï¼š

```python
def bit_update(BIT, n, i, v):
    i += 1  # index in BITree[] is 1 more than the index in arr[]

    while i <= n:  # Traverse all ancestors and add 'val'
        BIT[i] += v
        i += i & (-i)  # Update index to that of parent
```

æ›´æ–°å‡½æ•°éœ€è¦ç¡®ä¿æ‰€æœ‰åŒ…å«arr[i]åœ¨å…¶èŒƒå›´å†…çš„BITèŠ‚ç‚¹éƒ½è¢«æ›´æ–°ã€‚æˆ‘ä»¬é€šè¿‡ä¸æ–­å‘å½“å‰ç´¢å¼•æ·»åŠ å…¶æœ€åä¸€ä½è®¾ç½®ä½å¯¹åº”çš„åè¿›åˆ¶æ•°ï¼Œåœ¨BITä¸­å¾ªç¯éå†è¿™äº›èŠ‚ç‚¹ã€‚



### **å®ç°** 

é¦–å…ˆå°†BIT[]ä¸­çš„æ‰€æœ‰å€¼åˆå§‹åŒ–ä¸º0ã€‚ç„¶åå¯¹æ‰€æœ‰çš„ç´¢å¼•è°ƒç”¨bit_update()å‡½æ•°ã€‚

```python
# Binary Indexed Tree

def bit_sum(BIT, i):
    """è®¡ç®—æ ‘çŠ¶æ•°ç»„ BIT ä»ç´¢å¼• 1 åˆ° i çš„å‰ç¼€å’Œ"""
    s = 0
    while i > 0:
        s += BIT[i]
        i -= i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹
    return s


def bit_update(BIT, i, v):
    """åœ¨æ ‘çŠ¶æ•°ç»„ BIT ä¸­æ›´æ–°ç´¢å¼• i å¤„çš„å€¼ v"""
    while i < len(BIT):
        BIT[i] += v
        i += i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹


# Constructs and returns a Binary Indexed Tree for given array of size n.
def construct(arr, n):
    BIT = [0] * (n + 1)
    for i in range(n):  # Store the actual values in BIT[] using bit_update()
        bit_update(BIT, i + 1, arr[i])

    return BIT


arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
BIT = construct(arr, len(arr))
print(f'BIT: ', *BIT)
print("Sum of elements in arr[0..5] is " + str(bit_sum(BIT, 5)))
arr[3] += 6
bit_update(BIT, 3, 6)
print(f'BIT: ', *BIT)
print("Sum of elements in arr[0..5]" +
      " after update is " + str(bit_sum(BIT, 5)))

```

**Output**

```
BIT:  0 1 3 3 10 5 11 7 36 9 19 11 42 13 27 15 136
Sum of elements in arr[0..5] is 15
BIT:  0 1 3 9 16 5 11 7 42 9 19 11 42 13 27 15 142
Sum of elements in arr[0..5] after update is 21
```

**Time Complexity:** $O(NlogN)$
**Auxiliary Space:** $O(N)$

**Can we extend the Binary Indexed Tree to computing the sum of a range in O(Logn) time?** 
Yes. rangeSum(l, r) = get_sum(r) â€“ get_sum(l-1).

**References:** 
http://en.wikipedia.org/wiki/Fenwick_tree 



### ç¤ºä¾‹20018:èš‚èšç‹å›½çš„è¶Šé‡è·‘

BIT, http://cs101.openjudge.cn/practice/20018/

ä¸ºäº†ä¿ƒè¿›èš‚èšå®¶æ—èº«ä½“å¥åº·ï¼Œæé«˜èšæ—å¥èº«æ„è¯†ï¼Œèš‚èšç‹å›½ä¸¾è¡Œäº†è¶Šé‡è·‘ã€‚å‡è®¾è¶Šé‡è·‘å…±æœ‰Nä¸ªèš‚èšå‚åŠ ï¼Œåœ¨ä¸€æ¡ç¬”ç›´çš„é“è·¯ä¸Šè¿›è¡Œã€‚Nä¸ªèš‚èšåœ¨èµ·ç‚¹å¤„ç«™æˆä¸€åˆ—ï¼Œç›¸é‚»ä¸¤ä¸ªèš‚èšä¹‹é—´ä¿æŒä¸€å®šçš„é—´è·ã€‚æ¯”èµ›å¼€å§‹åï¼ŒNä¸ªèš‚èšåŒæ—¶æ²¿ç€é“è·¯å‘ç›¸åŒçš„æ–¹å‘è·‘å»ã€‚æ¢å¥è¯è¯´ï¼Œè¿™Nä¸ªèš‚èšå¯ä»¥çœ‹ä½œxè½´ä¸Šçš„Nä¸ªç‚¹ï¼Œåœ¨æ¯”èµ›å¼€å§‹åï¼Œå®ƒä»¬åŒæ—¶å‘Xè½´æ­£æ–¹å‘ç§»åŠ¨ã€‚å‡è®¾è¶Šé‡è·‘çš„è·ç¦»è¶³å¤Ÿè¿œï¼Œè¿™Nä¸ªèš‚èšçš„é€Ÿåº¦æœ‰çš„ä¸ç›¸åŒæœ‰çš„ç›¸åŒä¸”ä¿æŒåŒ€é€Ÿè¿åŠ¨ï¼Œé‚£ä¹ˆä¼šæœ‰å¤šå°‘å¯¹å‚èµ›è€…ä¹‹é—´å‘ç”Ÿâ€œèµ¶è¶…â€çš„äº‹ä»¶å‘¢ï¼Ÿæ­¤é¢˜ç»“æœæ¯”è¾ƒå¤§ï¼Œéœ€è¦å®šä¹‰long longç±»å‹ã€‚è¯·çœ‹å¤‡æ³¨ã€‚

<img src="http://media.openjudge.cn/images/upload/1576506586.jpg" alt="img" style="zoom:50%;" />



**è¾“å…¥**

ç¬¬ä¸€è¡Œ1ä¸ªæ•´æ•°Nã€‚
ç¬¬2â€¦ N +1è¡Œï¼šN ä¸ªéè´Ÿæ•´æ•°ï¼ŒæŒ‰ä»å‰åˆ°åçš„é¡ºåºç»™å‡ºæ¯ä¸ªèš‚èšçš„è·‘æ­¥é€Ÿåº¦ã€‚å¯¹äº50%çš„æ•°æ®ï¼Œ2<=N<=1000ã€‚å¯¹äº100%çš„æ•°æ®ï¼Œ2<=N<=100000ã€‚

è¾“å‡º

ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ‰å¤šå°‘å¯¹å‚èµ›è€…ä¹‹é—´å‘ç”Ÿèµ¶è¶…äº‹ä»¶ã€‚

æ ·ä¾‹è¾“å…¥

```
5
1
5
10
7
6

5
1
5
5
7
6
```

æ ·ä¾‹è¾“å‡º

```
7

8
```

æç¤º

æˆ‘ä»¬æŠŠè¿™5ä¸ªèš‚èšä¾æ¬¡ç¼–å·ä¸ºA,B,C,D,Eï¼Œå‡è®¾é€Ÿåº¦åˆ†åˆ«ä¸º1,5,5,7,6ã€‚åœ¨è·‘æ­¥è¿‡ç¨‹ä¸­ï¼šB,C,D,Eå‡ä¼šè¶…è¿‡Aï¼Œå› ä¸ºä»–ä»¬çš„é€Ÿåº¦éƒ½æ¯”Aå¿«ï¼›D,Eéƒ½ä¼šè¶…è¿‡B,Cï¼Œå› ä¸ºä»–ä»¬çš„é€Ÿåº¦éƒ½æ¯”B,Cå¿«ï¼›D,Eä¹‹é—´ä¸ä¼šå‘ç”Ÿèµ¶è¶…ï¼Œå› ä¸ºé€Ÿåº¦å¿«çš„èµ·è·‘æ—¶å°±åœ¨å‰è¾¹ï¼›B,Cä¹‹é—´ä¸ä¼šå‘ç”Ÿèµ¶è¶…ï¼Œå› ä¸ºé€Ÿåº¦ä¸€æ ·ï¼Œåœ¨å‰é¢çš„å°±ä¸€ç›´åœ¨å‰é¢ã€‚

è€ƒè™‘å½’å¹¶æ’åºçš„æ€æƒ³ã€‚

æ­¤é¢˜ç»“æœæ¯”è¾ƒå¤§ï¼Œéœ€è¦å®šä¹‰long longç±»å‹ï¼Œå…¶è¾“å‡ºæ ¼å¼ä¸ºprintf("%lld",x);
long longï¼Œæœ‰ç¬¦å· 64ä½æ•´æ•°ï¼Œæ‰€å 8ä¸ªå­—èŠ‚(Byte)
-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807



```python
# å¼ æ¸…å· 24åŒ–å­¦å­¦é™¢
def bit_sum(BIT, i):
    """è®¡ç®—æ ‘çŠ¶æ•°ç»„ BIT ä»ç´¢å¼• 1 åˆ° i çš„å‰ç¼€å’Œ"""
    s = 0
    while i > 0:
        s += BIT[i]
        i -= i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹
    return s


def bit_update(BIT, i, v):
    """åœ¨æ ‘çŠ¶æ•°ç»„ BIT ä¸­æ›´æ–°ç´¢å¼• i å¤„çš„å€¼ v"""
    while i < len(BIT):
        BIT[i] += v
        i += i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹


# è¯»å–è¾“å…¥å¹¶è¿›è¡Œç¦»æ•£åŒ–
n = int(input())
values = [int(input()) for _ in range(n)]

# ç¦»æ•£åŒ–ï¼šå»ºç«‹å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
sorted_vals = sorted(set(values))
value_to_index = {v: i + 1 for i, v in enumerate(sorted_vals)}

# åˆå§‹åŒ–æ ‘çŠ¶æ•°ç»„
BIT = [0] * (len(sorted_vals) + 1)
count = 0

# è®¡ç®—é€†åºå¯¹
for v in values:
    index = value_to_index[v]
    count += bit_sum(BIT, index - 1)  # æŸ¥è¯¢æ¯”å½“å‰å€¼å°çš„å…ƒç´ ä¸ªæ•°
    bit_update(BIT, index, 1)  # åœ¨æ ‘çŠ¶æ•°ç»„ä¸­è®°å½•å½“å‰å€¼å‡ºç°æ¬¡æ•°

print(count)
```





## B çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰

Segment tree | Efficient implementation

https://www.geeksforgeeks.org/segment-tree-efficient-implementation/



Let us consider the following problem to understand Segment Trees without recursion.
We have an array $arr[0 . . . n-1]$. We should be able to, 

1. Find the sum of elements from index `l` to `r` where $0 \leq l \leq r \leq n-1$
2. Change the value of a specified element of the array to a new value x. We need to do $arr[i] = x$ where $0 \leq i \leq n-1$. 

A **simple solution** is to run a loop from l to r and calculate the sum of elements in the given range. To update a value, simply do $arr[i] = x$. The first operation takes **O(n)** time and the second operation takes **O(1)** time.

**Another solution** is to create another array and store the sum from start to i at the ith index in this array. The sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now. This works well if the number of query operations is large and there are very few updates.
What if the number of queries and updates are equal? Can we perform both the operations in O(log n) time once given the array? We can use a [Segment Tree](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) to do both operations in O(Logn) time. We have discussed the complete implementation of segment trees in our [previous](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) post. In this post, we will discuss the easier and yet efficient implementation of segment trees than in the previous post.
Consider the array and segment tree as shown below:  å¶å­æ˜¯æ•°ç»„å€¼ï¼Œéå¶æ˜¯å’Œ

![img](https://media.geeksforgeeks.org/wp-content/uploads/excl.png)



You can see from the above image that the original array is at the bottom and is 0-indexed with 16 elements. The tree contains a total of 31 nodes where the leaf nodes or the elements of the original array start from node 16. So, we can easily construct a segment tree for this array using a `2*N` sized array where `N` is the number of elements in the original array. The leaf nodes will start from index `N` in this array and will go up to index (2*N â€“ 1). Therefore, the element at index i in the original array will be at index (i + N) in the segment tree array. Now to calculate the parents, we will start from the index (N â€“ 1) and move upward. æ ¹èŠ‚ç‚¹ä¸‹æ ‡ä»1å¼€å§‹ï¼ŒFor index i , the left child will be at (2 * i) and the right child will be at (2*i + 1) index. So the values at nodes at (2 * i) and (2*i + 1) are combined at i-th node to construct the tree. 
As you can see in the above figure, we can query in this tree in an interval [L,R) with left index(L) included and right (R) excluded.
We will implement all of these multiplication and addition operations using bitwise operators.
Let us have a look at the complete implementation: 

```python
# Python3 Code Addition 

# limit for array size 
N = 100000; 

# Max size of tree 
tree = [0] * (2 * N); 

# function to build the tree 
def build(arr) : 

	# insert leaf nodes in tree 
	for i in range(n) : 
		tree[n + i] = arr[i]; 
	
	# build the tree by calculating parents 
	for i in range(n - 1, 0, -1) : 
    # tree[i] = tree[2*i] + tree[2*i+1]
		tree[i] = tree[i << 1] + tree[i << 1 | 1]; 	

# function to update a tree node 
def updateTreeNode(p, value) : 
	
	# set value at position p 
	tree[p + n] = value; 
	p = p + n; 
	
	# move upward and update parents 
	i = p; 
	
	while i > 1 : 
		
		tree[i >> 1] = tree[i] + tree[i ^ 1]; 
		i >>= 1; 

# function to get sum on interval [l, r) 
def query(l, r) : 

	res = 0; 
	
	# loop to find the sum in the range 
	l += n; 
	r += n; 
	
	while l < r : 
	
		if (l & 1) : 
			res += tree[l]; 
			l += 1
	
		if (r & 1) : 
			r -= 1; 
			res += tree[r]; 
			
		l >>= 1; 
		r >>= 1
	
	return res; 

if __name__ == "__main__" : 

	a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; 

	n = len(a); 
	
	build(a); 
	
	# print the sum in range(1,2) index-based 
	print(query(1, 3)); 
	
	# modify element at 2nd index 
	updateTreeNode(2, 1); 
	
	# print the sum in range(1,2) index-based 
	print(query(1, 3)); 

```



**Output:** 

```
5
3
```

Yes! That is all. The complete implementation of the segment tree includes the query and update functions. Let us now understand how each of the functions works: 


1. The picture makes it clear that the leaf nodes are stored at i+n, so we can clearly insert all leaf nodes directly.
2. The next step is to build the tree and it takes O(n) time. The parent always has its less index than its children, so we just process all the nodes in decreasing order, calculating the value of the parent node. If the code inside the build function to calculate parents seems confusing, then you can see this code. It is equivalent to that inside the build function. 

```python
tree[i] = tree[2*i] + tree[2*i+1]
```

 

3. Updating a value at any position is also simple and the time taken will be proportional to the height ï¼ˆâ€œé«˜åº¦â€è¿™ä¸ªæ¦‚å¿µï¼Œå…¶å®å°±æ˜¯ä»ä¸‹å¾€ä¸Šåº¦é‡ï¼Œæ ‘è¿™ç§æ•°æ®ç»“æ„çš„é«˜åº¦æ˜¯ä»æœ€åº•å±‚å¼€å§‹è®¡æ•°ï¼Œå¹¶ä¸”è®¡æ•°çš„èµ·ç‚¹æ˜¯0ï¼‰ of the tree. We only update values in the parents of the given node which is being changed. So to get the parent, we just go up to the parent node, which is p/2 or p>>1, for node p. p^1 turns (2\*i) to (2\*i + 1) and vice versa to get the second child of p.
4. Computing the sum also works in $O(Logn)$ time. If we work through an interval of [3,11), we need to calculate only for nodes 19,26,12, and 5 in that order.  è¦æ¼”ç¤ºè¿™ä¸ªç´¢å¼•ä¸Šè¡Œçš„æ±‚å’Œè¿‡ç¨‹ï¼Œå‰é¢ç¨‹åºæ•°ç»„æ˜¯12ä¸ªå…ƒç´ ï¼Œå›¾ç¤ºæ˜¯16ä¸ªå…ƒç´ ï¼Œéœ€è¦ç¨ä½œä¿®æ”¹ã€‚å¢åŠ äº†printè¾“å‡ºï¼Œä¾¿äºè°ƒè¯•ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202310312148391.png" alt="image-20231031214814445" style="zoom:50%;" />



The idea behind the query function is whether we should include an element in the sum or whether we should include its parent. Letâ€™s look at the image once again for proper understanding. 

![img](https://media.geeksforgeeks.org/wp-content/uploads/excl.png)

Consider that L is the left border of an interval and R is the right border of the interval [L,R). It is clear from the image that if L is odd, then it means that it is the right child of its parent and our interval includes only L and not the parent. So we will simply include this node to sum and move to the parent of its next node by doing L = (L+1)/2. Now, if L is even, then it is the left child of its parent and the interval includes its parent also unless the right borders interfere. Similar conditions are applied to the right border also for faster computation. We will stop this iteration once the left and right borders meet.
The theoretical time complexities of both previous implementation and this implementation is the same, but practically, it is found to be much more efficient as there are no recursive calls. We simply iterate over the elements that we need. Also, this is very easy to implement.

> The algorithm re-evaluates the sum variable only if the idex from and to are odd. Why is that? It's because if the index is even, then it's the left child node. We don't need to bother reading it, since we'll get another chance at doing it on the next level up. Of course, the same logic applies on the next level up, and the decision about even index nodes could always be postponed. Given that the length of the tree array is always twice the size of the input array, which is a constant multiplier. And that on each iteration of the loop, the from and to variables are halved, the loop iterates at most log base two of two multiply by n. Which is a order log n running time complexity. Another way of saying this is, since the algorithm works up the tree and the height of the tree is equal to log n, its running time is order log n.
>
> ä¸ºä»€ä¹ˆåœ¨ç´¢å¼• from å’Œ to æ˜¯å¥‡æ•°æ—¶ï¼Œç®—æ³•æ‰é‡æ–°è®¡ç®—å’Œæ›´æ–° sum å˜é‡ã€‚åŸå› æ˜¯ï¼Œå¦‚æœç´¢å¼•æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„èŠ‚ç‚¹æ˜¯å·¦å­èŠ‚ç‚¹ã€‚æˆ‘ä»¬ä¸éœ€è¦è¯»å–å®ƒï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ä¸‹ä¸€å±‚çº§ä¸­ä¼šæœ‰å¦ä¸€æ¬¡æœºä¼šè¿›è¡Œè¯»å–ã€‚å½“ç„¶ï¼Œç›¸åŒçš„é€»è¾‘ä¹Ÿé€‚ç”¨äºä¸Šä¸€å±‚çº§ï¼Œå¯¹å¶æ•°ç´¢å¼•èŠ‚ç‚¹çš„å†³å®šæ€»æ˜¯å¯ä»¥æ¨è¿Ÿçš„ã€‚è€ƒè™‘åˆ°æ ‘æ•°ç»„çš„é•¿åº¦å§‹ç»ˆæ˜¯è¾“å…¥æ•°ç»„å¤§å°çš„ä¸¤å€ï¼Œè¿™æ˜¯ä¸€ä¸ªæ’å®šçš„ä¹˜æ•°ã€‚è€Œä¸”åœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­ï¼Œfrom å’Œ to å˜é‡éƒ½ä¼šå‡åŠï¼Œå› æ­¤å¾ªç¯çš„æœ€å¤§è¿­ä»£æ¬¡æ•°æ˜¯ä»¥log 2nã€‚è¿™æ˜¯ä¸€ä¸ªå¯¹æ•°å¤æ‚åº¦çš„è¿è¡Œæ—¶é—´ã€‚æ¢å¥è¯è¯´ï¼Œç”±äºç®—æ³•æ˜¯æ²¿ç€æ ‘å‘ä¸Šè¿è¡Œçš„ï¼Œè€Œæ ‘çš„é«˜åº¦ç­‰äº log nï¼Œå› æ­¤å…¶è¿è¡Œæ—¶é—´æ˜¯å¯¹æ•°å¤æ‚åº¦çš„ã€‚



**Time Complexities:**

- Tree Construction: O( n )
- Query in Range: O( Log n )
- Updating an element: O( Log n ).

**Auxiliary Space:** O(2*N)



### ç¤ºä¾‹1364A: A. XXXXX

brute force/data structures/number theory/two pointers, 1200, https://codeforces.com/problemset/problem/1364/A

Ehab loves number theory, but for some reason he hates the number ğ‘¥. Given an array ğ‘, find the length of its longest subarray such that the sum of its elements **isn't** divisible by ğ‘¥, or determine that such subarray doesn't exist.

An array ğ‘ is a subarray of an array ğ‘ if ğ‘ can be obtained from ğ‘ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

**Input**

The first line contains an integer ğ‘¡ (1â‰¤ğ‘¡â‰¤5) â€” the number of test cases you need to solve. The description of the test cases follows.

The first line of each test case contains 2 integers ğ‘› and ğ‘¥ (1â‰¤ğ‘›â‰¤10^5^, 1â‰¤ğ‘¥â‰¤10^4^) â€” the number of elements in the array ğ‘ and the number that Ehab hates.

The second line contains ğ‘› space-separated integers $ğ‘_1, ğ‘_2, â€¦â€¦, ğ‘_ğ‘› (0â‰¤ğ‘_ğ‘–â‰¤10^4)$ â€” the elements of the array ğ‘.

**Output**

For each testcase, print the length of the longest subarray whose sum isn't divisible by ğ‘¥. If there's no such subarray, print âˆ’1.

Example

input

```
3
3 3
1 2 3
3 4
1 2 3
2 2
0 6
```

output

```
2
3
-1
```

Note

In the first test case, the subarray \[2,3\] has sum of elements 5, which isn't divisible by 3.

In the second test case, the sum of elements of the whole array is 6, which isn't divisible by 4.

In the third test case, all subarrays have an even sum, so the answer is âˆ’1.



Pypy3 å¯ä»¥ACã€‚ä½¿ç”¨tree segmentï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n*logn)

```python
# CF 1364A
 
# def prefix_sum(nums):
#     prefix = []
#     total = 0
#     for num in nums:
#         total += num
#         prefix.append(total)
#     return prefix
 
# def suffix_sum(nums):
#     suffix = []
#     total = 0
#     # é¦–å…ˆå°†åˆ—è¡¨åè½¬
#     reversed_nums = nums[::-1]
#     for num in reversed_nums:
#         total += num
#         suffix.append(total)
#     # å°†ç»“æœåè½¬å›æ¥
#     suffix.reverse()
#     return suffix
 
 
t = int(input())
ans = []
for _ in range(t):
    n, x = map(int, input().split())
    a = [int(i) for i in input().split()]


# Segment tree | Efficient implementation
# https://www.geeksforgeeks.org/segment-tree-efficient-implementation/

    # Max size of tree 
    tree = [0] * (2 * n); 

    def build(arr) : 

        # insert leaf nodes in tree 
        for i in range(n) : 
            tree[n + i] = arr[i]; 
        
        # build the tree by calculating parents 
        for i in range(n - 1, 0, -1) : 
            tree[i] = tree[i << 1] + tree[i << 1 | 1]; 

    # function to update a tree node 
    def updateTreeNode(p, value) : 
        
        # set value at position p 
        tree[p + n] = value; 
        p = p + n; 
        
        # move upward and update parents 
        i = p; 
        
        while i > 1 : 
            
            tree[i >> 1] = tree[i] + tree[i ^ 1]; 
            i >>= 1; 

    # function to get sum on interval [l, r) 
    def query(l, r) : 

        res = 0; 
        
        # loop to find the sum in the range 
        l += n; 
        r += n; 
        
        while l < r : 
        
            if (l & 1) : 
                res += tree[l]; 
                l += 1
        
            if (r & 1) : 
                r -= 1; 
                res += tree[r]; 
                
            l >>= 1; 
            r >>= 1
        
        return res; 
    #aprefix_sum = prefix_sum(a)
    #asuffix_sum = suffix_sum(a)
 
    build([i%x for i in a]);
    
    left = 0
    right = n - 1
    if right == 0:
        if a[0] % x !=0:
            print(1)
        else:
            print(-1)
        continue
 
    leftmax = 0
    rightmax = 0
    while left != right:
        #total = asuffix_sum[left]
        total = query(left, right+1)
        if total % x != 0:
            leftmax = right - left + 1
            break
        else:
            left += 1
 
    left = 0
    right = n - 1
    while left != right:
        #total = aprefix_sum[right]
        total = query(left, right+1)
        if total % x != 0:
            rightmax = right - left + 1
            break
        else:
            right -= 1
    
    if leftmax == 0 and rightmax == 0:
        #print(-1)
        ans.append(-1)
    else:
        #print(max(leftmax, rightmax))
        ans.append(max(leftmax, rightmax))

print('\n'.join(map(str,ans)))
```



å¦‚æœç”¨sumæ±‚å’Œï¼ŒO(n^2)ï¼Œpypy3ä¹Ÿä¼šåœ¨test3 è¶…æ—¶ã€‚





## C å‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰

Trie â€“ Data Structure and Algorithm Tutorials

https://www.geeksforgeeks.org/introduction-to-trie-data-structure-and-algorithm-tutorials/

Trie æ•°æ®ç»“æ„å®šä¹‰ä¸ºä¸€ç§åŸºäºæ ‘çš„æ•°æ®ç»“æ„ï¼Œç”¨äºå­˜å‚¨æŸäº›å­—ç¬¦ä¸²é›†åˆå¹¶å¯¹å…¶æ‰§è¡Œé«˜æ•ˆçš„æœç´¢æ“ä½œã€‚Trie è¿™ä¸ªè¯æºè‡ª retrievalï¼ˆæ£€ç´¢ï¼‰ï¼Œæ„å‘³ç€æ‰¾åˆ°æˆ–è·å¾—æŸç‰©ã€‚

å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²æœ‰ä¸€ä¸ªå…±åŒå‰ç¼€ï¼Œé‚£ä¹ˆå®ƒä»¬åœ¨ Trie ä¸­å°†æœ‰ç›¸åŒçš„ç¥–å…ˆã€‚Trie å¯ä»¥ç”¨æ¥å¯¹å­—ç¬¦ä¸²é›†åˆè¿›è¡Œå­—æ¯é¡ºåºæ’åºï¼Œå¹¶ä¸”å¯ä»¥æœç´¢å…·æœ‰ç»™å®šå‰ç¼€çš„å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨äº Trie ä¸­ã€‚

> Trie data structure is defined as a Tree based data structure that is used for storing some collection of strings and performing efficient search operations on them. The word Trie is derived from re**TRIE**val, which means finding something or obtaining it. 
>
> Trie follows some property that If two strings have a common prefix then they will have the same ancestor in the trie. A trie can be used to sort a collection of strings alphabetically as well as search whether a string with a given prefix is present in the trie or not.
>



**ä¸ºä»€ä¹ˆéœ€è¦ Trie æ•°æ®ç»“æ„ï¼Ÿ**

Trie æ•°æ®ç»“æ„ç”¨äºæ•°æ®çš„å­˜å‚¨å’Œæ£€ç´¢ï¼ŒåŒæ ·çš„æ“ä½œä¹Ÿå¯ä»¥ä½¿ç”¨å¦ä¸€ç§æ•°æ®ç»“æ„â€”â€”å“ˆå¸Œè¡¨æ¥å®Œæˆï¼Œä½† Trie åœ¨æ‰§è¡Œè¿™äº›æ“ä½œæ—¶æ¯”å“ˆå¸Œè¡¨æ›´é«˜æ•ˆã€‚æ­¤å¤–ï¼ŒTrie ç›¸å¯¹äºå“ˆå¸Œè¡¨æœ‰è‡ªå·±çš„ä¼˜åŠ¿ã€‚Trie æ•°æ®ç»“æ„å¯ä»¥ç”¨äº**åŸºäºå‰ç¼€çš„**æœç´¢ï¼Œè€Œå“ˆå¸Œè¡¨åˆ™ä¸èƒ½ä»¥ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ã€‚

> **Need for Trie Data Structure?**
>
> A Trie data structure is used for storing and retrieval of data and the same operations could be done using another data structure which is Hash Table but Trie can perform these operations more efficiently than a Hash Table. Moreover, Trie has its own advantage over the Hash table. A Trie data structure can be used for **prefix-based** searching whereas a Hash table canâ€™t be used in the same way. 
>



**Trie æ•°æ®ç»“æ„ç›¸å¯¹äºå“ˆå¸Œè¡¨çš„ä¼˜åŠ¿ï¼š**

Trie æ•°æ®ç»“æ„ç›¸æ¯”å“ˆå¸Œè¡¨å…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

- æˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°è¿›è¡Œ**å‰ç¼€æœç´¢**ï¼ˆæˆ–è‡ªåŠ¨è¡¥å…¨ï¼‰ã€‚
- æˆ‘ä»¬å¯ä»¥è½»æ¾æŒ‰å­—æ¯é¡ºåºæ‰“å°æ‰€æœ‰å•è¯ï¼Œè€Œè¿™åœ¨å“ˆå¸Œè¡¨ä¸­ä¸å®¹æ˜“å®ç°ã€‚
- Trie æ•°æ®ç»“æ„ä¸­æ²¡æœ‰å“ˆå¸Œå‡½æ•°çš„å¼€é”€ã€‚
- å³ä½¿åœ¨å¤§å‹å­—ç¬¦ä¸²é›†åˆä¸­æœç´¢å­—ç¬¦ä¸²ï¼ŒTrie æ•°æ®ç»“æ„ä¹Ÿå¯ä»¥åœ¨**O(L)**çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆï¼Œå…¶ä¸­ L æ˜¯æŸ¥è¯¢å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ•°ã€‚å¦‚æœæŸ¥è¯¢å­—ç¬¦ä¸²ä¸å­˜åœ¨äº Trie ä¸­ï¼Œæœç´¢æ—¶é—´å¯èƒ½ä¼šå°‘äº O(L)ã€‚

> **Advantages of Trie Data Structure over a Hash Table:**
>
> The A trie data structure has the following advantages over a hash table:  
>
> - We can efficiently do **prefix search** (or auto-complete) with Trie.
> - We can easily print all words in alphabetical order which is not easily possible with hashing.
> - There is no overhead of Hash functions in a Trie data structure.
> - Searching for a String even in the large collection of strings in a Trie data structure can be done in **O(L)** Time complexity, Where L is the number of words in the query string. This searching time could be even less than O(L) if the query string does not exist in the trie.
>



**Trie æ•°æ®ç»“æ„çš„å±æ€§**

æ—¢ç„¶æˆ‘ä»¬å·²ç»çŸ¥é“ Trie å…·æœ‰ç±»ä¼¼æ ‘çš„ç»“æ„ï¼Œäº†è§£å…¶å±æ€§å°±éå¸¸é‡è¦äº†ã€‚ä»¥ä¸‹æ˜¯ Trie æ•°æ®ç»“æ„çš„ä¸€äº›é‡è¦å±æ€§ï¼š

- æ¯ä¸ª Trie éƒ½æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚
- Trie çš„æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯æ¡è¾¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ã€‚
- æ¯ä¸ªèŠ‚ç‚¹åŒ…å«å“ˆå¸Œæ˜ å°„æˆ–**æŒ‡é’ˆæ•°ç»„**ï¼Œæ¯ä¸ªç´¢å¼•ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶æœ‰ä¸€ä¸ªæ ‡å¿—æ¥æŒ‡ç¤ºæ˜¯å¦æœ‰ä»»ä½•å­—ç¬¦ä¸²åœ¨æ­¤èŠ‚ç‚¹ç»“æŸã€‚
- Trie æ•°æ®ç»“æ„å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬**å­—æ¯**ã€**æ•°å­—**å’Œ**ç‰¹æ®Šå­—ç¬¦**ã€‚ä½†å¯¹äºæœ¬æ–‡ï¼Œæˆ‘ä»¬å°†è®¨è®ºä»…åŒ…å« a-z å­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚å› æ­¤ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªéœ€è¦ 26 ä¸ªæŒ‡é’ˆï¼Œå…¶ä¸­ç¬¬ **0** ç´¢å¼•è¡¨ç¤ºå­—ç¬¦ **â€˜aâ€™**ï¼Œç¬¬ **25** ç´¢å¼•è¡¨ç¤ºå­—ç¬¦ **â€˜zâ€™**ã€‚
- ä»æ ¹åˆ°ä»»æ„èŠ‚ç‚¹çš„æ¯æ¡è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªå•è¯æˆ–å­—ç¬¦ä¸²ã€‚

> **Properties of a Trie Data Structure**
>
> Now we already know that Trie has a tree-like structure. So, it is very important to know its properties.
> Below are some important properties of the Trie data structure:
>
> - There is one root node in each Trie.
> - Each node of a Trie represents a string and each edge represents a character.
> - Every node consists of hashmaps or **an array of pointers**, with each index representing a character and a flag to indicate if any string ends at the current node.
> - Trie data structure can contain any number of characters including **alphabets**, **numbers**, and **special characters**. But for this article, we will discuss strings with characters a-z. Therefore, only 26 pointers need for every node, where the **0th** index represents **â€˜aâ€™** and the **25th** index represents **â€˜zâ€™** characters.
> - Each path from the root to any node represents a word or string.
>

Below is a simple example of Trie data structure.

![Trie Data Structure](https://raw.githubusercontent.com/GMyhf/img/main/img/Triedatastructure1.png)

Trie Data Structure



**Trie æ•°æ®ç»“æ„æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ**

æˆ‘ä»¬å·²ç»çŸ¥é“ï¼ŒTrie æ•°æ®ç»“æ„å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬**å­—æ¯**ã€**æ•°å­—**å’Œ**ç‰¹æ®Šå­—ç¬¦**ã€‚ä½†åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºä»…åŒ…å«å­—ç¬¦ **a-z** çš„å­—ç¬¦ä¸²ã€‚å› æ­¤ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªéœ€è¦ 26 ä¸ªæŒ‡é’ˆï¼Œå…¶ä¸­ç¬¬ **0** ç´¢å¼•è¡¨ç¤ºå­—ç¬¦ **â€˜aâ€™**ï¼Œç¬¬ **25** ç´¢å¼•è¡¨ç¤ºå­—ç¬¦ **â€˜zâ€™**ã€‚

ä»»ä½•å°å†™è‹±æ–‡å­—æ¯å•è¯éƒ½å¯ä»¥ä»¥ **a-z** å¼€å¤´ï¼Œæ¥ç€å•è¯çš„ä¸‹ä¸€ä¸ªå­—æ¯å¯ä»¥æ˜¯ **a-z**ï¼Œç¬¬ä¸‰ä¸ªå­—æ¯ä¹Ÿå¯ä»¥æ˜¯ **a-z**ï¼Œä¾æ­¤ç±»æ¨ã€‚å› æ­¤ï¼Œä¸ºäº†å­˜å‚¨ä¸€ä¸ªå•è¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¤§å°ä¸º **26** çš„æ•°ç»„ï¼ˆå®¹å™¨ï¼‰ï¼Œåˆå§‹æ—¶æ‰€æœ‰å­—ç¬¦éƒ½ä¸ºç©ºï¼Œå› ä¸ºè¿˜æ²¡æœ‰æ’å…¥ä»»ä½•å•è¯ï¼Œå®ƒçœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºï¼š

> **How does Trie Data Structure work?**
>
> We already know that the Trie data structure can contain any number of characters including **alphabets**, **numbers**, and **special characters**. But for this article, we will discuss strings with characters **a-z**. Therefore, only 26 pointers need for every node, where the **0th** index represents **â€˜aâ€™** and the **25th** index represents **â€˜zâ€™** characters.
>
> Any lowercase English word can start with **a-z**, then the next letter of the word could be **a-z,** the third letter of the word again could be **a-z**, and so on. So for storing a word, we need to take an array (container) of size **26** and initially, all the characters are empty as there are no words and it will look as shown below.
>

![An array of pointers inside every Trie node](https://raw.githubusercontent.com/GMyhf/img/main/img/nodeintrie.png)

An array of pointers inside every Trie node



è®©æˆ‘ä»¬çœ‹çœ‹å•è¯ `and` å’Œ `ant` æ˜¯å¦‚ä½•å­˜å‚¨åœ¨ Trie æ•°æ®ç»“æ„ä¸­çš„ï¼š

1. åœ¨ Trie æ•°æ®ç»“æ„ä¸­å­˜å‚¨ `and`ï¼š
   - å•è¯ `and` ä»¥å­—æ¯ `a` å¼€å¤´ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ Trie èŠ‚ç‚¹ä¸­æ ‡è®°ä½ç½® `a` ä¸ºå·²å ç”¨ï¼Œè¿™è¡¨ç¤ºä½¿ç”¨äº†å­—ç¬¦ `a`ã€‚
   - æ”¾ç½®ç¬¬ä¸€ä¸ªå­—ç¬¦åï¼Œå¯¹äºç¬¬äºŒä¸ªå­—ç¬¦ä»ç„¶æœ‰ `26 ç§å¯èƒ½æ€§`ï¼Œå› æ­¤ä» `a` å‡ºå‘ï¼Œå†æ¬¡æœ‰ä¸€ä¸ªå¤§å°ä¸º `26` çš„æ•°ç»„ï¼Œç”¨äºå­˜å‚¨ç¬¬äºŒä¸ªå­—ç¬¦ã€‚
   - ç¬¬äºŒä¸ªå­—ç¬¦æ˜¯ `n`ï¼Œå› æ­¤ä» `a` å‡ºå‘ï¼Œæˆ‘ä»¬ç§»åŠ¨åˆ° `n` å¹¶åœ¨ç¬¬äºŒä¸ªæ•°ç»„ä¸­æ ‡è®° `n` ä¸ºå·²ä½¿ç”¨ã€‚
   - åœ¨ `n` ä¹‹åï¼Œç¬¬ä¸‰ä¸ªå­—ç¬¦æ˜¯ `d`ï¼Œå› æ­¤åœ¨ç›¸åº”çš„æ•°ç»„ä¸­æ ‡è®°ä½ç½® `d` ä¸ºå·²ä½¿ç”¨ã€‚

2. åœ¨ Trie æ•°æ®ç»“æ„ä¸­å­˜å‚¨ `ant`ï¼š
   - å•è¯ `ant` ä»¥ `a` å¼€å¤´ï¼Œè€Œæ ¹èŠ‚ç‚¹ä¸­ `a` çš„ä½ç½®å·²ç»è¢«å¡«å……ã€‚å› æ­¤ï¼Œæ— éœ€å†æ¬¡å¡«å……å®ƒï¼Œåªéœ€ç§»åŠ¨åˆ° Trie ä¸­çš„èŠ‚ç‚¹ `a`ã€‚
   - å¯¹äºç¬¬äºŒä¸ªå­—ç¬¦ `n`ï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°åœ¨ `a` èŠ‚ç‚¹ä¸­ `n` çš„ä½ç½®å·²ç»è¢«å¡«å……ã€‚å› æ­¤ï¼Œæ— éœ€å†æ¬¡å¡«å……ï¼Œåªéœ€ç§»åŠ¨åˆ° Trie ä¸­çš„èŠ‚ç‚¹ `n`ã€‚
   - å¯¹äºå•è¯çš„æœ€åä¸€ä¸ªå­—ç¬¦ `t`ï¼Œåœ¨ `n` èŠ‚ç‚¹ä¸­ `t` çš„ä½ç½®å°šæœªè¢«å¡«å……ã€‚å› æ­¤ï¼Œå¡«å…… `n` èŠ‚ç‚¹ä¸­ `t` çš„ä½ç½®ï¼Œå¹¶ç§»åŠ¨åˆ° `t` èŠ‚ç‚¹ã€‚

åœ¨å­˜å‚¨å•è¯ `and` å’Œ `ant` åï¼ŒTrie å°†å¦‚ä¸‹æ‰€ç¤ºï¼š

> Letâ€™s see how a word `and` and `ant` is stored in the Trie data structure: 
>
> 1. Store `and` in Trie data structure:
>
>    - The word `and` starts with `a`, So we will mark the position `a` as filled in the Trie node, which represents the use of `a`. 
>    - After placing the first character, for the second character again there are `26 possibilities`, So from `a`, again there is an array of size `26`, for storing the 2nd character.
>    - The second character is `n`, So from `a`, we will move to `n` and mark `n` in the `2nd` array as used.
>    - After `n`, the 3rd character is `d`, So mark the position `d` as used in the respective array.
>
> 2. Store `ant` in the Trie data structure:
>
>    - The word `ant` starts with `a` and the position of `a` in the root node has already been filled. So, no need to fill it again, just move to the node `a` in Trie.
>    - For the second character `n` we can observe that the position of â€˜nâ€™ in the â€˜aâ€™ node has already been filled. So, no need to fill it again, just move to node `n` in Trie.
>    - For the last character `t` of the word, The position for `t` in the `n` node is not filled. So, filled the position of `t`â€˜ in `n` node and move to `t` node.
>
> After storing the word â€œandâ€ and â€œantâ€ the Trie will look like this:
>

![img](https://raw.githubusercontent.com/GMyhf/img/main/img/a1.png)

 

**Representation of Trie Node:**

Every Trie node consists of a character pointer array or hashmap and a flag to represent if the word is ending at that node or not. But if the words contain only **lower-case** letters (i.e. a-z), then we can define Trie Node with an array instead of a hashmap.



```python
# Python code
class TrieNode:

	# Trie node class
	def _init_(self):
		self.children = [None for _ in range(26)]

		# This will keep track of number of strings that are
		# stored in the Trie from root node to any Trie node.
		self.wordCount = 0
		
		# This code is contributed by ishankhandelwals.

```

**Basic Operations on Trie Data Structure:**

1. Insertion
2. Search
3. Deletion

**1. Insertion in Trie Data Structure:**

This operation is used to insert new strings into the Trie data structure. Let us see how this works:

Let us try to Insert â€œandâ€ & â€œantâ€ in this Trie:

![Insert "and" & "ant"](https://raw.githubusercontent.com/GMyhf/img/main/img/ex1-660x399.png)



From the above representation of insertion, we can see that the word â€œandâ€ & â€œantâ€ have shared some common node (i.e â€œanâ€) this is because of the property of the Trie data structure that If two strings have a common prefix then they will have the same ancestor in the trie.

Now let us try to Insert â€œdadâ€ & â€œdoâ€:

![Insertion in Trie Data Structure](https://raw.githubusercontent.com/GMyhf/img/main/img/ex2.png)

Insertion in Trie Data Structure

**Implementation of Insertion in Trie data structure:**

Algorithm:

1. Define a function `insert(TrieNode root, string &word)` which will take two parameters one for the root and the other for the string that we want to insert in the Trie data structure.

2. Now take another pointer `currentNode` and initialize it with the `root` node.

3. Iterate over the length of the given string and check if the value is `NULL` or not in the array of pointers at the current character of the string.

   - If Itâ€™s `NULL` then, make a new node and point the current character to this newly created node.
   - Move the curr to the newly created node.

4. Finally, increment the `wordCount` of the last `currentNode`, this implies that there is a string ending currentNode.

Below is the implementation of the above algorithm:



```python
def insert_key(root, key):
	# Initialize the currentNode pointer
	# with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current
		# character in the Trie.
		if currentNode.childNode[ord(c) - ord('a')] == None:
			# If node for current character does not exist
			# then make a new node
			newNode = TrieNode()

			# Keep the reference for the newly created
			# node.
			currentNode.childNode[ord(c) - ord('a')] = newNode

		# Now, move the current node pointer to the newly
		# created node.
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	# Increment the wordEndCount for the last currentNode
	# pointer this implies that there is a string ending at
	# currentNode.
	currentNode.wordCount += 1

```

**2. Searching in Trie Data Structure:**

Search operation in Trie is performed in a similar way as the insertion operation but the only difference is that whenever we find that the array of pointers in `curr node` does not point to the `current character` of the `word` then return false instead of creating a new node for that current character of the word. 

This operation is used to search whether a string is present in the Trie data structure or not. There are two search approaches in the Trie data structure.

1. Find whether the given word exists in Trie.
2. Find whether any word that starts with the given prefix exists in Trie.

There is a similar search pattern in both approaches. The first step in searching a given word in Trie is to convert the word to characters and then compare every character with the trie node from the root node. If the current character is present in the node, move forward to its children. Repeat this process until all characters are found.

**2.1 Searching Prefix in Trie Data Structure:**

Search for the prefix â€œanâ€ in the Trie Data Structure.

![Search for the prefix "an" in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/searchforprefix.png)

Search for the prefix â€œanâ€ in Trie



Implementation of Prefix Search in Trie data structure:

```python
def is_prefix_exist(root, key):
	# Initialize the currentNode pointer
	# with the root node
	current_node = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current
		# character in the Trie.
		if current_node.child_node[ord(c) - ord('a')] is None:
			# Given word as a prefix does not exist in Trie
			return False

		# Move the currentNode pointer to the already 
		# existing node for current character.
		current_node = current_node.child_node[ord(c) - ord('a')]

	# Prefix exist in the Trie
	return True

```

**2.2 Searching Complete word in Trie Data Structure:**

It is similar to prefix search but additionally, we have to check if the word is ending at the last character of the word or not.

![Searching in Trie Data Structure](https://raw.githubusercontent.com/GMyhf/img/main/img/search1.png)

Search â€œdadâ€ in the Trie data structure

Implementation of Search in Trie data structure:

```python
def search_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie
		if currentNode.childNode[ord(c) - ord('a')] is None:
			# Given word does not exist in Trie
			return False

		# Move the currentNode pointer to the already existing node for current character
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	# Return if the wordCount is greater than 0
	return currentNode.wordCount > 0

```

**3. Deletion in Trie Data Structure**

This operation is used to delete strings from the Trie data structure. There are three cases when deleting a word from Trie.

1. The deleted word is a prefix of other words in Trie.
2. The deleted word shares a common prefix with other words in Trie.
3. The deleted word does not share any common prefix with other words in Trie.

Example :

**3.1 The deleted word is a prefix of other words in Trie.**

As shown in the following figure, the deleted word â€œanâ€ share a complete prefix with another word â€œandâ€ and â€œantâ€œ.

![Deletion of word which is a prefix of other words in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/case1.png)

Deletion of word which is a prefix of other words in Trie


An easy solution to perform a delete operation for this case is to just decrement the **wordCount** by 1 at the ending node of the word.

**3.2 The deleted word shares a common prefix with other words in Trie.**

As shown in the following figure, the deleted word â€œandâ€ has some common prefixes with other words â€˜antâ€™. They share the prefix â€˜anâ€™.

![Deletion of word which shares a common prefix with other words in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/Case2.png)

Deletion of word which shares a common prefix with other words in Trie


The solution for this case is to delete all the nodes starting from the end of the prefix to the last character of the given word.

3.3 The deleted word does not share any common prefix with other words in Trie.

As shown in the following figure, the word â€œgeekâ€ does not share any common prefix with any other words.

![Deletion of a word that does not share any common prefix with other words in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/case3.png)

Deletion of a word that does not share any common prefix with other words in Trie


The solution for this case is just to delete all the nodes.

Below is the implementation that handles all the above cases:

```python
def delete_key(root, word):
	current_node = root
	last_branch_node = None
	last_branch_char = 'a'

	# loop through each character in the word
	for c in word:
		# if the current node doesn't have a child with the current character,
		# return False as the word is not present in Trie
		if current_node.childNode[ord(c) - ord('a')] is None:
			return False
		else:
			count = 0
			# count the number of children nodes of the current node
			for i in range(26):
				if current_node.childNode[i] is not None:
					count += 1

			# if the count of children is more than 1,
			# store the node and the current character
			if count > 1:
				last_branch_node = current_node
				last_branch_char = c

			current_node = current_node.childNode[ord(c) - ord('a')]

	count = 0
	# count the number of children nodes of the current node
	for i in range(26):
		if current_node.childNode[i] is not None:
			count += 1

	# Case 1: The deleted word is a prefix of other words in Trie
	if count > 0:
		current_node.wordCount -= 1
		return True

	# Case 2: The deleted word shares a common prefix with other words in Trie
	if last_branch_node is not None:
		last_branch_node.childNode[ord(last_branch_char) - ord('a')] = None
		return True

	# Case 3: The deleted word does not share any common prefix with other words in Trie
	else:
		root.childNode[ord(word[0]) - ord('a')] = None
		return True

```

**How to implement Trie Data Structure?**

- Create a root node with the help of `TrieNode()` constructor.

- Store a collection of strings that we have to insert in the trie in a vector of strings say, `arr`.

- Inserting all strings in Trie with the help of the `insertkey()` function,

- Search strings from `searchQueryStrings\` with the help of `search_key()` function.

- Delete the strings present in the `deleteQueryStrings` with the help of `delete_key`.

  

```python
# Trie implementation in Python 

class TrieNode:
	def __init__(self):
		# pointer array for child nodes of each node
		self.childNode = [None] * 26
		self.wordCount = 0
		
def insert_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie.
		if not currentNode.childNode[ord(c) - ord('a')]:
			# If node for current character does not exist
			# then make a new node
			newNode = TrieNode()
			# Keep the reference for the newly created node.
			currentNode.childNode[ord(c) - ord('a')] = newNode
		# Now, move the current node pointer to the newly created node.
		currentNode = currentNode.childNode[ord(c) - ord('a')]
	# Increment the wordEndCount for the last currentNode
	# pointer this implies that there is a string ending at currentNode.
	currentNode.wordCount += 1
	
def search_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie.
		if not currentNode.childNode[ord(c) - ord('a')]:
			# Given word does not exist in Trie
			return False
		# Move the currentNode pointer to the already existing node for current character.
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	return currentNode.wordCount > 0

def delete_key(root, word):
	currentNode = root
	lastBranchNode = None
	lastBrachChar = 'a'

	for c in word:
		if not currentNode.childNode[ord(c) - ord('a')]:
			return False
		else:
			count = 0
			for i in range(26):
				if currentNode.childNode[i]:
					count += 1
			if count > 1:
				lastBranchNode = currentNode
				lastBrachChar = c
			currentNode = currentNode.childNode[ord(c) - ord('a')]

	count = 0
	for i in range(26):
		if currentNode.childNode[i]:
			count += 1

	# Case 1: The deleted word is a prefix of other words in Trie.
	if count > 0:
		currentNode.wordCount -= 1
		return True

	# Case 2: The deleted word shares a common prefix with other words in Trie.
	if lastBranchNode:
		lastBranchNode.childNode[ord(lastBrachChar) - ord('a')] = None
		return True
	# Case 3: The deleted word does not share any common prefix with other words in Trie.
	else:
		root.childNode[ord(word[0]) - ord('a')] = None
		return True
# Driver Code
if __name__ == '__main__':
	# Make a root node for the Trie
	root = TrieNode()

	# Stores the strings that we want to insert in the Trie
	input_strings = ["and", "ant", "do", "geek", "dad", "ball"]

	# number of insert operations in the Trie
	n = len(input_strings)

	for i in range(n):
		insert_key(root, input_strings[i])

	# Stores the strings that we want to search in the Trie
	search_query_strings = ["do", "geek", "bat"]

	# number of search operations in the Trie
	search_queries = len(search_query_strings)

	for i in range(search_queries):
		print("Query String:", search_query_strings[i])
		if search_key(root, search_query_strings[i]):
			# the queryString is present in the Trie
			print("The query string is present in the Trie")
		else:
			# the queryString is not present in the Trie
			print("The query string is not present in the Trie")

	# stores the strings that we want to delete from the Trie
	delete_query_strings = ["geek", "tea"]

	# number of delete operations from the Trie
	delete_queries = len(delete_query_strings)

	for i in range(delete_queries):
		print("Query String:", delete_query_strings[i])
		if delete_key(root, delete_query_strings[i]):
			# The queryString is successfully deleted from the Trie
			print("The query string is successfully deleted")
		else:
			# The query string is not present in the Trie
			print("The query string is not present in the Trie")

# This code is contributed by Vikram_Shirsat

```

**Output**

```
Query String: do
The query string is present in the Trie
Query String: geek
The query string is present in the Trie
Query String: bat
The query string is not present in the Trie
Query String: geek
The query string is successfully deleted
Query String: tea
The query string is not present in the Trie
```

**Complexity Analysis of Trie Data Structure**

| Operation | Time Complexity | Auxiliary Space |
| :-------: | :-------------: | :-------------: |
| Insertion |      O(n)       |     O(n*m)      |
| Searching |      O(n)       |      O(1)       |
| Deletion  |      O(n)       |      O(1)       |

**Note:** In the above complexity table `n`, `m` represents the size of the string and the number of strings that are stored in the trie.

**Applications of Trie data structure:** 

1. Autocomplete Feature: Autocomplete provides suggestions based on what you type in the search box. Trie data structure is used to implement autocomplete functionality.  





![Autocomplete feature of Trie Data Structure](https://media.geeksforgeeks.org/wp-content/uploads/20220831154521/AutoComplete.png)

Autocomplete feature of Trie Data Structure

2. Spell Checkers: If the word typed does not appear in the dictionary, then it shows suggestions based on what you typed.
   It is a 3-step process that includes :

- Checking for the word in the data dictionary.

- Generating potential suggestions.

- Sorting the suggestions with higher priority on top.

Trie stores the data dictionary and makes it easier to build an algorithm for searching the word from the dictionary and provides the list of valid words for the suggestion.

3. Longest Prefix Matching Algorithm(Maximum Prefix Length Match): This algorithm is used in networking by the routing devices in IP networking. Optimization of network routes requires contiguous masking that bound the complexity of lookup a time to O(n), where n is the length of the URL address in bits.

To speed up the lookup process, Multiple Bit trie schemes were developed that perform the lookups of multiple bits faster.

**Advantages of Trie data structure:**

- Trie allows us to input and finds strings in O(l) time, where l is the length of a single word. It is faster as compared to both hash tables and binary search trees.
- It provides alphabetical filtering of entries by the key of the node and hence makes it easier to print all words in alphabetical order.
- Trie takes less space when compared to BST because the keys are not explicitly saved instead each key requires just an amortized fixed amount of space to be stored.
- Prefix search/Longest prefix matching can be efficiently done with the help of trie data structure.
- Since trie doesnâ€™t need any hash function for its implementation so they are generally faster than hash tables for small keys like integers and pointers.
- Tries support ordered iteration whereas iteration in a hash table will result in pseudorandom order given by the hash function which is usually more cumbersome.
- Deletion is also a straightforward algorithm with O(l) as its time complexity, where l is the length of the word to be deleted.

**Disadvantages of Trie data structure:**

- The main disadvantage of the trie is that it takes a lot of memory to store all the strings. For each node, we have too many node pointers which are equal to the no of characters in the worst case.
- An efficiently constructed hash table(i.e. a good hash function and a reasonable load factor) has O(1) as lookup time which is way faster than O(l) in the case of a trie, where l is the length of the string.



**Frequently asked questions (FAQs) about Trie Data Structure:**

**1. Is trie an advanced data structure?**

A Trie is an advanced data structure that is sometimes also known as a prefix tree

**2. What is the difference between trie and tree data structure?**

A tree is a general structure of recursive nodes. There are many types of trees. Popular ones are the binary tree and balanced tree. A Trie is a kind of tree, known by many names including prefix tree, digital search tree, and retrieval tree (hence the name â€˜trieâ€™).

**3. What are some applications of Trie?**

The longest common prefix, pattern searching, autocomplete and implementation of the dictionary are some of the common applications of a Trie Data Structure.

**4. Does Google use trie?**

Google even stores each word/sentence in the form of a trie.

**5. What is the advantage of trie?**

The main disadvantage of Trie is that it takes a lot of memory to store all the Strings. For each node, we have too many node pointers (equal to the number of characters of the alphabet).

**Conclusion:**

Our discussion so far has led us to the conclusion that the Trie data structure is a Tree based data structure that is used for storing some collection of strings and performing efficient search operations on them and we have also discussed the various advantage and applications of trie data structure.





## D $kd$ æ ‘ï¼ˆK Dimensional treeï¼‰

$k$è¿‘é‚»æ³•çš„å®ç°ï¼š$kd$æ ‘

$k$ è¿‘é‚»ç®—æ³•ï¼šç»™å®šä¸€ä¸ªè®­ç»ƒæ•°æ®é›†ï¼Œå¯¹æ–°çš„è¾“å…¥å®ä¾‹ï¼Œåœ¨è®­ç»ƒæ•°æ®é›†ä¸­æ‰¾åˆ°ä¸è¯¥å®ä¾‹æœ€é‚»è¿‘çš„ $k$ ä¸ªå®ä¾‹ï¼Œè¿™ $k$ ä¸ªå®ä¾‹çš„å¤šæ•°å±äºæŸä¸ªç±»ï¼Œå°±æŠŠè¯¥è¾“å…¥å®ä¾‹åˆ†ä¸ºè¿™ä¸ªç±»ã€‚

> **sklearn.neighbors.KNeighborsClassifier**
>
> - n_neighbors: ä¸´è¿‘ç‚¹ä¸ªæ•°
>
> - p: è·ç¦»åº¦é‡
>
> - algorithm: è¿‘é‚»ç®—æ³•ï¼Œå¯é€‰{'auto', 'ball_tree', 'kd_tree', 'brute'}
>
> - weights: ç¡®å®šè¿‘é‚»çš„æƒé‡
>
>   

$kd$ æ ‘æ˜¯ä¸€ç§å¯¹kç»´ç©ºé—´ä¸­çš„å®ä¾‹ç‚¹è¿›è¡Œå­˜å‚¨ä»¥ä¾¿å¯¹å…¶è¿›è¡Œå¿«é€Ÿæ£€ç´¢çš„æ ‘å½¢æ•°æ®ç»“æ„ã€‚

$kd$ æ ‘æ˜¯äºŒå‰æ ‘ï¼Œè¡¨ç¤ºå¯¹ $k$ ç»´ç©ºé—´çš„ä¸€ä¸ªåˆ’åˆ†ï¼ˆpartitionï¼‰ã€‚æ„é€  $kd$ æ ‘ç›¸å½“äºä¸æ–­åœ°ç”¨å‚ç›´äºåæ ‡è½´çš„è¶…å¹³é¢å°† $k$ ç»´ç©ºé—´åˆ‡åˆ†ï¼Œæ„æˆä¸€ç³»åˆ—çš„kç»´è¶…çŸ©å½¢åŒºåŸŸã€‚$kd$ æ ‘çš„æ¯ä¸ªç»“ç‚¹å¯¹åº”äºä¸€ä¸ª$k$ç»´è¶…çŸ©å½¢åŒºåŸŸã€‚

æ„é€ $kd$æ ‘çš„æ–¹æ³•å¦‚ä¸‹ï¼š

æ„é€ æ ¹ç»“ç‚¹ï¼Œä½¿æ ¹ç»“ç‚¹å¯¹åº”äº$k$ç»´ç©ºé—´ä¸­åŒ…å«æ‰€æœ‰å®ä¾‹ç‚¹çš„è¶…çŸ©å½¢åŒºåŸŸï¼›é€šè¿‡ä¸‹é¢çš„é€’å½’æ–¹æ³•ï¼Œä¸æ–­åœ°å¯¹$k$ç»´ç©ºé—´è¿›è¡Œåˆ‡åˆ†ï¼Œç”Ÿæˆå­ç»“ç‚¹ã€‚åœ¨è¶…çŸ©å½¢åŒºåŸŸï¼ˆç»“ç‚¹ï¼‰ä¸Šé€‰æ‹©ä¸€ä¸ªåæ ‡è½´å’Œåœ¨æ­¤åæ ‡è½´ä¸Šçš„ä¸€ä¸ªåˆ‡åˆ†ç‚¹ï¼Œç¡®å®šä¸€ä¸ªè¶…å¹³é¢ï¼Œè¿™ä¸ªè¶…å¹³é¢é€šè¿‡é€‰å®šçš„åˆ‡åˆ†ç‚¹å¹¶å‚ç›´äºé€‰å®šçš„åæ ‡è½´ï¼Œå°†å½“å‰è¶…çŸ©å½¢åŒºåŸŸåˆ‡åˆ†ä¸ºå·¦å³ä¸¤ä¸ªå­åŒºåŸŸ ï¼ˆå­ç»“ç‚¹ï¼‰ï¼›è¿™æ—¶ï¼Œå®ä¾‹è¢«åˆ†åˆ°ä¸¤ä¸ªå­åŒºåŸŸã€‚è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°å­åŒºåŸŸå†…æ²¡æœ‰å®ä¾‹æ—¶ç»ˆæ­¢ï¼ˆç»ˆæ­¢æ—¶çš„ç»“ç‚¹ä¸ºå¶ç»“ç‚¹ï¼‰ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œå°†å®ä¾‹ä¿å­˜åœ¨ç›¸åº”çš„ç»“ç‚¹ä¸Šã€‚

é€šå¸¸ï¼Œä¾æ¬¡é€‰æ‹©åæ ‡è½´å¯¹ç©ºé—´åˆ‡åˆ†ï¼Œé€‰æ‹©è®­ç»ƒå®ä¾‹ç‚¹åœ¨é€‰å®šåæ ‡è½´ä¸Šçš„ä¸­ä½æ•° ï¼ˆmedianï¼‰ä¸ºåˆ‡åˆ†ç‚¹ï¼Œè¿™æ ·å¾—åˆ°çš„$kd$æ ‘æ˜¯å¹³è¡¡çš„ã€‚æ³¨æ„ï¼Œå¹³è¡¡çš„$kd$æ ‘æœç´¢æ—¶çš„æ•ˆç‡æœªå¿…æ˜¯æœ€ä¼˜çš„ã€‚



### D.1 æ„é€ å¹³è¡¡$kd$æ ‘ç®—æ³•

è¾“å…¥ï¼š$k$ç»´ç©ºé—´æ•°æ®é›†$Tï¼\{x1ï¼Œx2,â€¦,xN\}$ï¼Œ

å…¶ä¸­$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}$

è¾“å‡ºï¼š$kd$æ ‘ã€‚

ï¼ˆ1ï¼‰å¼€å§‹ï¼šæ„é€ æ ¹ç»“ç‚¹ï¼Œæ ¹ç»“ç‚¹å¯¹åº”äºåŒ…å«Tçš„kç»´ç©ºé—´çš„è¶…çŸ©å½¢åŒºåŸŸã€‚

é€‰æ‹© $x^{(1)}$ ä¸ºåæ ‡è½´ï¼Œä»¥Tä¸­æ‰€æœ‰å®ä¾‹çš„ $x^{(1)}$ åæ ‡çš„ä¸­ä½æ•°ä¸ºåˆ‡åˆ†ç‚¹ï¼Œå°†æ ¹ç»“ç‚¹å¯¹åº”çš„è¶…çŸ©å½¢åŒºåŸŸåˆ‡åˆ†ä¸ºä¸¤ä¸ªå­åŒºåŸŸã€‚åˆ‡åˆ†ç”±é€šè¿‡åˆ‡åˆ†ç‚¹å¹¶ä¸åæ ‡è½´ $x^{(1)}$ å‚ç›´çš„è¶…å¹³é¢å®ç°ã€‚

ç”±æ ¹ç»“ç‚¹ç”Ÿæˆæ·±åº¦ä¸º1çš„å·¦ã€å³å­ç»“ç‚¹ï¼šå·¦å­ç»“ç‚¹å¯¹åº”åæ ‡ $x^{(1)}$ å°äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸï¼Œ å³å­ç»“ç‚¹å¯¹åº”äºåæ ‡ $x^{(1)}$ å¤§äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸã€‚

å°†è½åœ¨åˆ‡åˆ†è¶…å¹³é¢ä¸Šçš„å®ä¾‹ç‚¹ä¿å­˜åœ¨æ ¹ç»“ç‚¹ã€‚

ï¼ˆ2ï¼‰é‡å¤ï¼šå¯¹æ·±åº¦ä¸ºjçš„ç»“ç‚¹ï¼Œé€‰æ‹© $x^{(1)}$ ä¸ºåˆ‡åˆ†çš„åæ ‡è½´ï¼Œ$lï¼j(modk)+1$ï¼Œä»¥è¯¥ç»“ç‚¹çš„åŒºåŸŸä¸­æ‰€æœ‰å®ä¾‹çš„$x^{(1)}$åæ ‡çš„ä¸­ä½æ•°ä¸ºåˆ‡åˆ†ç‚¹ï¼Œå°†è¯¥ç»“ç‚¹å¯¹åº”çš„è¶…çŸ©å½¢åŒºåŸŸåˆ‡åˆ†ä¸ºä¸¤ä¸ªå­åŒºåŸŸã€‚åˆ‡åˆ†ç”±é€šè¿‡åˆ‡åˆ†ç‚¹å¹¶ä¸åæ ‡è½´x(1)å‚ç›´çš„è¶…å¹³é¢å®ç°ã€‚

ç”±è¯¥ç»“ç‚¹ç”Ÿæˆæ·±åº¦ä¸º $j+1$ çš„å·¦ã€å³å­ç»“ç‚¹ï¼šå·¦å­ç»“ç‚¹å¯¹åº”åæ ‡ $x^{(1)}$ å°äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸï¼Œå³å­ç»“ç‚¹å¯¹åº”åæ ‡ $x^{(1)}$ å¤§äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸã€‚

å°†è½åœ¨åˆ‡åˆ†è¶…å¹³é¢ä¸Šçš„å®ä¾‹ç‚¹ä¿å­˜åœ¨è¯¥ç»“ç‚¹ã€‚

ï¼ˆ3ï¼‰ç›´åˆ°ä¸¤ä¸ªå­åŒºåŸŸæ²¡æœ‰å®ä¾‹å­˜åœ¨æ—¶åœæ­¢ã€‚ä»è€Œå½¢æˆ $kd$ æ ‘çš„åŒºåŸŸåˆ’åˆ†ã€‚



> ã€$kd$ æ ‘æ˜¯å¦‚ä½•æ„é€ çš„ï¼Ÿ-å“”å“©å“”å“©ã€‘ https://b23.tv/KdKiJUb



### D.2 æœç´¢$kd$æ ‘

**æœ€è¿‘é‚»æœç´¢**

`find_nearest` å‡½æ•°ï¼š

- é€’å½’æœç´¢ $kd$ æ ‘ï¼Œå¯»æ‰¾ä¸ç›®æ ‡ç‚¹æœ€è¿‘çš„æ ·æœ¬ç‚¹ã€‚
- æ ¸å¿ƒé€»è¾‘ï¼š
  1. **é€’å½’åˆ°å¶èŠ‚ç‚¹**ï¼šç¡®å®šç›®æ ‡ç‚¹æ‰€åœ¨çš„å­ç©ºé—´ã€‚
  2. **æ›´æ–°æœ€è¿‘é‚»ä¿¡æ¯**ï¼šä»å¶èŠ‚ç‚¹å‘ä¸Šå›æº¯ï¼Œæ›´æ–°æœ€è¿‘é‚»ç‚¹å’Œè·ç¦»ã€‚
  3. å‰ªæä¼˜åŒ–ï¼šåˆ¤æ–­è¶…çƒä½“ï¼ˆç›®æ ‡ç‚¹ä¸ºçƒå¿ƒï¼Œå½“å‰æœ€è¿‘è·ç¦»ä¸ºåŠå¾„ï¼‰æ˜¯å¦ä¸åˆ†å‰²è¶…å¹³é¢ç›¸äº¤ã€‚
     - å¦‚æœä¸ç›¸äº¤ï¼Œåˆ™æ— éœ€è®¿é—®å¦ä¸€å­ç©ºé—´ã€‚
  4. **æ£€æŸ¥å¦ä¸€å­ç©ºé—´**ï¼šå¦‚æœè¶…çƒä½“ä¸åˆ†å‰²è¶…å¹³é¢ç›¸äº¤ï¼Œé€’å½’æ£€æŸ¥å¦ä¸€å­ç©ºé—´ï¼Œæ›´æ–°æœ€è¿‘é‚»ä¿¡æ¯ã€‚



> ã€$kd$ æ ‘çš„æœç´¢è¿‡ç¨‹-å“”å“©å“”å“©ã€‘ https://b23.tv/xzctdn1



### ç¤ºä¾‹ä»£ç  sklearn_kd_tree_demo.py

```python
#!/usr/bin/env python
# encoding: utf-8
"""
@author: HuRuiFeng
@file: kd_tree_demo.py
@time: 2021/8/3 17:08
@project: statistical-learning-method-solutions-manual
@desc: ä¹ é¢˜3.2 kdæ ‘çš„æ„å»ºä¸æ±‚æœ€è¿‘é‚»ç‚¹
"""

import numpy as np
from sklearn.neighbors import KDTree

# æ„é€ ä¾‹é¢˜3.2çš„æ•°æ®é›†
train_data = np.array([[2, 3],
                       [5, 4],
                       [9, 6],
                       [4, 7],
                       [8, 1],
                       [7, 2]])
# ï¼ˆ1ï¼‰ä½¿ç”¨sklearnçš„KDTreeç±»ï¼Œæ„å»ºå¹³è¡¡kdæ ‘
# è®¾ç½®leaf_sizeä¸º2ï¼Œè¡¨ç¤ºå¹³è¡¡æ ‘
tree = KDTree(train_data, leaf_size=2)

# ï¼ˆ2ï¼‰ä½¿ç”¨tree.queryæ–¹æ³•ï¼Œè®¾ç½®k=1ï¼ŒæŸ¥æ‰¾(3, 4.5)çš„æœ€è¿‘é‚»ç‚¹
# distè¡¨ç¤ºä¸æœ€è¿‘é‚»ç‚¹çš„è·ç¦»ï¼Œindè¡¨ç¤ºæœ€è¿‘é‚»ç‚¹åœ¨train_dataçš„ä½ç½®
dist, ind = tree.query(np.array([[3, 4.5]]), k=1)
node_index = ind[0]

# å¾—åˆ°æœ€è¿‘é‚»ç‚¹
x1 = train_data[node_index][0][0]
x2 = train_data[node_index][0][1]
print("xç‚¹çš„æœ€è¿‘é‚»ç‚¹æ˜¯({0}, {1})".format(x1, x2))
# è¾“å‡ºç»“æœä¸ºï¼šxç‚¹çš„æœ€è¿‘é‚»ç‚¹æ˜¯(2, 3)
```



### ç¤ºä¾‹ä»£ç  my_kd_tree.py

```python
from math import sqrt
from collections import namedtuple
import time
from random import random

# å®šä¹‰ä¸€ä¸ªnamedtuple,åˆ†åˆ«å­˜æ”¾æœ€è¿‘åæ ‡ç‚¹ã€æœ€è¿‘è·ç¦»å’Œè®¿é—®è¿‡çš„èŠ‚ç‚¹æ•°
result = namedtuple("Result_tuple",
                    "nearest_point  nearest_dist  nodes_visited")


# kd-treeæ¯ä¸ªç»“ç‚¹ä¸­ä¸»è¦åŒ…å«çš„æ•°æ®ç»“æ„å¦‚ä¸‹
class KdNode:
    def __init__(self, dom_elt, split, left, right):
        self.dom_elt = dom_elt  # kç»´å‘é‡èŠ‚ç‚¹(kç»´ç©ºé—´ä¸­çš„ä¸€ä¸ªæ ·æœ¬ç‚¹)
        self.split = split  # æ•´æ•°ï¼ˆè¿›è¡Œåˆ†å‰²ç»´åº¦çš„åºå·ï¼‰
        self.left = left  # è¯¥ç»“ç‚¹åˆ†å‰²è¶…å¹³é¢å·¦å­ç©ºé—´æ„æˆçš„kd-tree
        self.right = right  # è¯¥ç»“ç‚¹åˆ†å‰²è¶…å¹³é¢å³å­ç©ºé—´æ„æˆçš„kd-tree


class KdTree:
    def __init__(self, data):
        k = len(data[0])  # æ•°æ®ç»´åº¦

        def create_node(split, data_set):  # æŒ‰ç¬¬splitç»´åˆ’åˆ†æ•°æ®é›†,åˆ›å»ºKdNode
            if not data_set:  # æ•°æ®é›†ä¸ºç©º
                return None

            data_set.sort(key=lambda x: x[split])  # æŒ‰è¦è¿›è¡Œåˆ†å‰²çš„é‚£ä¸€ç»´æ•°æ®æ’åº
            split_pos = len(data_set) // 2  # æ•´æ•°é™¤æ³•å¾—åˆ°ä¸­é—´ä½ç½®
            median = data_set[split_pos]  # ä¸­ä½æ•°åˆ†å‰²ç‚¹
            split_next = (split + 1) % k  # cycle coordinates

            # é€’å½’çš„åˆ›å»ºkdæ ‘
            return KdNode(
                median,
                split,
                create_node(split_next, data_set[:split_pos]),  # åˆ›å»ºå·¦å­æ ‘
                create_node(split_next, data_set[split_pos + 1:]))  # åˆ›å»ºå³å­æ ‘

        self.root = create_node(0, data)  # ä»ç¬¬0ç»´åˆ†é‡å¼€å§‹æ„å»ºkdæ ‘,è¿”å›æ ¹èŠ‚ç‚¹


# KDTreeçš„å‰åºéå†
def preorder(root):
    print(root.dom_elt)
    if root.left:  # èŠ‚ç‚¹ä¸ä¸ºç©º
        preorder(root.left)
    if root.right:
        preorder(root.right)


# å¯¹æ„å»ºå¥½çš„kdæ ‘è¿›è¡Œæœç´¢ï¼Œå¯»æ‰¾ä¸ç›®æ ‡ç‚¹æœ€è¿‘çš„æ ·æœ¬ç‚¹ï¼š


def find_nearest(tree, point):
    k = len(point)  # æ•°æ®ç»´åº¦

    def travel(kd_node, target, max_dist):
        if kd_node is None:
            return result([0] * k, float("inf"), 0)

        nodes_visited = 1

        s = kd_node.split  # è¿›è¡Œåˆ†å‰²çš„ç»´åº¦
        pivot = kd_node.dom_elt  # è¿›è¡Œåˆ†å‰²çš„â€œè½´â€

        if target[s] <= pivot[s]:  # å¦‚æœç›®æ ‡ç‚¹ç¬¬sç»´å°äºåˆ†å‰²è½´çš„å¯¹åº”å€¼(ç›®æ ‡ç¦»å·¦å­æ ‘æ›´è¿‘)
            nearer_node = kd_node.left  # ä¸‹ä¸€ä¸ªè®¿é—®èŠ‚ç‚¹ä¸ºå·¦å­æ ‘æ ¹èŠ‚ç‚¹
            further_node = kd_node.right  # åŒæ—¶è®°å½•ä¸‹å³å­æ ‘
        else:  # ç›®æ ‡ç¦»å³å­æ ‘æ›´è¿‘
            nearer_node = kd_node.right  # ä¸‹ä¸€ä¸ªè®¿é—®èŠ‚ç‚¹ä¸ºå³å­æ ‘æ ¹èŠ‚ç‚¹
            further_node = kd_node.left

        temp1 = travel(nearer_node, target, max_dist)  # è¿›è¡Œéå†æ‰¾åˆ°åŒ…å«ç›®æ ‡ç‚¹çš„åŒºåŸŸ

        nearest = temp1.nearest_point  # ä»¥æ­¤å¶ç»“ç‚¹ä½œä¸ºâ€œå½“å‰æœ€è¿‘ç‚¹â€
        dist = temp1.nearest_dist  # æ›´æ–°æœ€è¿‘è·ç¦»

        nodes_visited += temp1.nodes_visited

        if dist < max_dist:
            max_dist = dist  # æœ€è¿‘ç‚¹å°†åœ¨ä»¥ç›®æ ‡ç‚¹ä¸ºçƒå¿ƒï¼Œmax_distä¸ºåŠå¾„çš„è¶…çƒä½“å†…

        temp_dist = abs(pivot[s] - target[s])  # ç¬¬sç»´ä¸Šç›®æ ‡ç‚¹ä¸åˆ†å‰²è¶…å¹³é¢çš„è·ç¦»
        if max_dist < temp_dist:  # åˆ¤æ–­è¶…çƒä½“æ˜¯å¦ä¸è¶…å¹³é¢ç›¸äº¤
            return result(nearest, dist, nodes_visited)  # ä¸ç›¸äº¤åˆ™å¯ä»¥ç›´æ¥è¿”å›ï¼Œä¸ç”¨ç»§ç»­åˆ¤æ–­

        # ----------------------------------------------------------------------
        # è®¡ç®—ç›®æ ‡ç‚¹ä¸åˆ†å‰²ç‚¹çš„æ¬§æ°è·ç¦»
        temp_dist = sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(pivot, target)))

        if temp_dist < dist:  # å¦‚æœâ€œæ›´è¿‘â€
            nearest = pivot  # æ›´æ–°æœ€è¿‘ç‚¹
            dist = temp_dist  # æ›´æ–°æœ€è¿‘è·ç¦»
            max_dist = dist  # æ›´æ–°è¶…çƒä½“åŠå¾„

        # æ£€æŸ¥å¦ä¸€ä¸ªå­ç»“ç‚¹å¯¹åº”çš„åŒºåŸŸæ˜¯å¦æœ‰æ›´è¿‘çš„ç‚¹
        temp2 = travel(further_node, target, max_dist)

        nodes_visited += temp2.nodes_visited
        if temp2.nearest_dist < dist:  # å¦‚æœå¦ä¸€ä¸ªå­ç»“ç‚¹å†…å­˜åœ¨æ›´è¿‘è·ç¦»
            nearest = temp2.nearest_point  # æ›´æ–°æœ€è¿‘ç‚¹
            dist = temp2.nearest_dist  # æ›´æ–°æœ€è¿‘è·ç¦»

        return result(nearest, dist, nodes_visited)

    return travel(tree.root, point, float("inf"))  # ä»æ ¹èŠ‚ç‚¹å¼€å§‹é€’å½’


data = [[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]]
kd = KdTree(data)
preorder(kd.root)
"""
[7, 2]
[5, 4]
[2, 3]
[4, 7]
[9, 6]
[8, 1]
"""

ret = find_nearest(kd, [3, 4.5])
print(ret)
# Result_tuple(nearest_point=[2, 3], nearest_dist=1.8027756377319946, nodes_visited=4)

# äº§ç”Ÿä¸€ä¸ªkç»´éšæœºå‘é‡ï¼Œæ¯ç»´åˆ†é‡å€¼åœ¨0~1ä¹‹é—´
def random_point(k):
    return [random() for _ in range(k)]


# äº§ç”Ÿnä¸ªkç»´éšæœºå‘é‡
def random_points(k, n):
    return [random_point(k) for _ in range(n)]


N = 400000
# åœ¨å¼€å§‹æ—¶è®°å½•è¿›ç¨‹æ—¶é—´
start_cpu_time = time.process_time()

kd2 = KdTree(random_points(3, N))  # æ„å»ºåŒ…å«å››åä¸‡ä¸ª3ç»´ç©ºé—´æ ·æœ¬ç‚¹çš„kdæ ‘
ret2 = find_nearest(kd2, [0.1, 0.5, 0.8])  # å››åä¸‡ä¸ªæ ·æœ¬ç‚¹ä¸­å¯»æ‰¾ç¦»ç›®æ ‡æœ€è¿‘çš„ç‚¹

# åœ¨ç»“æŸæ—¶å†æ¬¡è®°å½•è¿›ç¨‹æ—¶é—´
end_cpu_time = time.process_time()

# è®¡ç®—å¹¶æ‰“å°æ‰€ç”¨çš„CPUæ—¶é—´
elapsed_cpu_time = end_cpu_time - start_cpu_time
print(f"Elapsed CPU time: {elapsed_cpu_time:0.4f} seconds")

print(ret2)
# Elapsed CPU time: 3.9399 seconds
# Result_tuple(nearest_point=[0.09951475212182137, 0.4971758210372218, 0.8019299872473542], nearest_dist=0.0034548955254863362, nodes_visited=46)

```





## E æ ‘è¿™ç« ç¨‹åºå¯¹åº”ç±»å›¾

### E.1 ç”Ÿæˆç±»å›¾

https://github.com/Yuqiu-Yang/problem_solving_with_algorithms_and_data_structures_using_python

ä¸‹è½½åï¼Œåˆ°ch6ç›®å½•ï¼Œç”Ÿæˆç±»å›¾ã€‚



> https://stackoverflow.com/questions/260165/whats-the-best-way-to-generate-a-uml-diagram-from-python-source-code
>
> You may have heard of [Pylint](http://www.pylint.org/) that helps statically checking Python code. Few people know that it comes with a tool named [Pyreverse](https://pylint.pycqa.org/en/latest/pyreverse.html) that draws UML diagrams from the Python code it reads. Pyreverse uses Graphviz as a backend.
>
> It is used like this:
>
> ```none
> pyreverse -o png -p yourpackage .
> ```
>
> where the `.` can also be a single file.



Generating UML Diagrams

https://www.bhavaniravi.com/python/generate-uml-diagrams-from-python-code

brew install pylint

brew install Graphviz 



åœ¨ ch6ç›®å½•ä¸‹è¿è¡Œ

% pyreverse -o png *.py                     

> Format png is not supported natively. Pyreverse will try to generate it using Graphviz...
>
> Analysed 12 modules with a total of 6 imports

äº§ç”Ÿä¿©æ–‡ä»¶

![image-20240204154709659](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240204154709659.png)

å›¾ packages.png





![image-20240204154437448](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240204154437448.png)

å›¾ classes.png



### E.2 åœ¨UMLç±»å›¾ä¸­ï¼Œå¸¸è§çš„è¿çº¿å’Œç¬¦å·



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/891cfde691e54661923699d89c198373.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 67%;" />



åœ¨UMLï¼ˆç»Ÿä¸€å»ºæ¨¡è¯­è¨€ï¼‰ç±»å›¾ä¸­ï¼Œå¸¸è§çš„è¿çº¿å’Œç¬¦å·åŒ…æ‹¬ä»¥ä¸‹è¿™äº›ï¼š

1. å…³è”(Association)

   - æ™®é€šå…³è”ï¼šç”¨ä¸€æ¡ç›´çº¿è¡¨ç¤ºä¸¤ä¸ªç±»ä¹‹é—´çš„å…³ç³»ï¼Œé€šå¸¸åœ¨å…³è”çš„ä¸¤ç«¯å¯ä»¥æœ‰ç®­å¤´ï¼Œç®­å¤´æŒ‡å‘è¢«å…³è”çš„ç±»ï¼Œè¡¨ç¤ºå¯¼èˆªæ–¹å‘ã€‚

   - åŒå‘å…³è”ï¼šä¸€æ¡ç®€å•çš„çº¿ï¼Œè¡¨ç¤ºä¸¤ä¸ªç±»ç›¸äº’çŸ¥é“å¯¹æ–¹ã€‚

   - èšåˆå…³ç³»(Aggregation)ï¼šç”¨ä¸€ä¸ªç©ºå¿ƒçš„è±å½¢åŠ ä¸€æ¡çº¿æ¥è¡¨ç¤ºï¼Œç©ºå¿ƒè±å½¢ä½äºæ•´ä½“çš„ä¸€ç«¯ã€‚è¡¨ç¤ºä¸€ä¸ªç±»æ˜¯å¦ä¸€ä¸ªç±»çš„éƒ¨åˆ†ï¼Œä½†å®ƒä»¬ä¹‹é—´æ²¡æœ‰å¼ºè€¦åˆå…³ç³»ï¼Œéƒ¨åˆ†å¯ä»¥å­˜åœ¨ç‹¬ç«‹äºæ•´ä½“çš„æƒ…å†µã€‚è±å½¢æŒ‡å‘æ•´ä½“ç±»ã€‚ä¾‹å¦‚ï¼š

     <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/381dc758d91249208d20709e4fd67a8e.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 67%;" />

   - ç»„åˆå…³ç³»(Composition)ï¼šç”¨ä¸€ä¸ªå®å¿ƒçš„è±å½¢åŠ ä¸€æ¡çº¿æ¥è¡¨ç¤ºï¼Œå®å¿ƒè±å½¢ä½äºæ•´ä½“çš„ä¸€ç«¯ã€‚è¡¨ç¤ºä¸€ä¸ªç±»æ˜¯å¦ä¸€ä¸ªç±»çš„æ•´ä½“éƒ¨åˆ†ï¼Œå®ƒä»¬å…·æœ‰ç”Ÿå‘½å‘¨æœŸä¸Šçš„æ•´ä½“å…³ç³»ã€‚è±å½¢æŒ‡å‘æ•´ä½“ç±»ã€‚ä¾‹å¦‚ï¼š

     <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/338de2b8eaf2425cbf060ade0f38a0f6.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom:67%;" />

2. æ³›åŒ–(Generalization)

   - ç”¨ä¸€æ¡å¸¦æœ‰ç©ºå¿ƒç®­å¤´çš„ç›´çº¿è¡¨ç¤ºï¼Œç®­å¤´æŒ‡å‘çˆ¶ç±»ï¼Œè¡¨ç¤ºå­ç±»ç»§æ‰¿è‡ªçˆ¶ç±»ã€‚è¡¨ç¤ºç»§æ‰¿å…³ç³»ï¼Œä¸€ä¸ªç±»æ˜¯å¦ä¸€ä¸ªç±»çš„å­ç±»ï¼Œç»§æ‰¿äº†çˆ¶ç±»çš„å±æ€§å’Œæ–¹æ³•ã€‚ä¾‹å¦‚ï¼š

     <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/7b6c62e666e44a56987f1e222c498b6f.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom:67%;" />

3. å®ç°(Implementation)

   - ç”¨ä¸€æ¡å¸¦æœ‰ç©ºå¿ƒç®­å¤´çš„è™šçº¿è¡¨ç¤ºï¼Œç®­å¤´æŒ‡å‘æ¥å£ï¼Œè¡¨ç¤ºç±»å®ç°äº†æ¥å£ã€‚

4. ä¾èµ–(Dependency)

   - ç”¨ä¸€æ¡å¸¦æœ‰ç®­å¤´çš„è™šçº¿è¡¨ç¤ºï¼Œç®­å¤´æŒ‡å‘è¢«ä¾èµ–çš„ç±»ã€‚

åœ¨ç±»å›¾ä¸­ï¼Œç±»é€šå¸¸ç”¨å¸¦æœ‰ä¸‰ä¸ªéƒ¨åˆ†çš„çŸ©å½¢æ¥è¡¨ç¤ºï¼š

- é¡¶éƒ¨éƒ¨åˆ†ï¼šæ˜¾ç¤ºç±»åï¼Œå¦‚æœæ˜¯æŠ½è±¡ç±»ï¼Œåˆ™ç”¨æ–œä½“è¡¨ç¤ºã€‚
- ä¸­é—´éƒ¨åˆ†ï¼šæ˜¾ç¤ºç±»çš„å±æ€§æˆ–å­—æ®µã€‚
- åº•éƒ¨éƒ¨åˆ†ï¼šæ˜¾ç¤ºç±»çš„æ–¹æ³•æˆ–æ“ä½œã€‚

è¿˜æœ‰ä¸€äº›å…¶ä»–çš„ç¬¦å·å’Œçº¦å®šï¼Œæ¯”å¦‚è¡¨ç¤ºå¤šé‡æ€§çš„æ•°å­—ï¼ˆä¾‹å¦‚ï¼Œ1â€¦* è¡¨ç¤ºä¸€ä¸ªåˆ°å¤šä¸ªï¼‰ï¼Œä»¥åŠç”¨æ¥è¡¨ç¤ºæ¥å£ã€æŠ½è±¡ç±»ç­‰çš„ç‰¹æ®Šå›¾æ ‡ã€‚åœ¨ç±»å›¾ä¸­ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨æ³¨é‡Šæ¡†ï¼ˆç”¨ä¸€æ¡è™šçº¿è¿æ¥çš„çŸ©å½¢æ¡†ï¼‰æ¥æ·»åŠ å¯¹å…³ç³»æˆ–ç±»çš„é¢å¤–è¯´æ˜ã€‚







# å‚è€ƒ

Problem Solving with Algorithms and Data Structures using Python

https://runestone.academy/ns/books/published/pythonds3/index.html



https://github.com/Yuqiu-Yang/problem_solving_with_algorithms_and_data_structures_using_python

https://github.com/wesleyjtann/Problem-Solving-with-Algorithms-and-Data-Structures-Using-Python

ã€å°æ²å­¦Pythonã€‘UMLç±»å›¾çš„ç®­å¤´è¿çº¿å…³ç³»æ€»ç»“ï¼ˆpython+graphvizï¼‰

https://blog.csdn.net/hhy321/article/details/132651062
